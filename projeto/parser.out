Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ASSERT
    BIN_NUMBER
    BITWISE_NOT
    BREAK
    BYTE_NUMBER
    CASE
    CATCH
    CHAR
    CONST
    CONTINUE
    DEFAULT
    DOT
    DOUBLE_NUMBER
    ENUM
    FINALLY
    GOTO
    HEXA_NUMBER
    IMPORT
    INSTANCEOF
    INTERFACE
    LONG_NUMBER
    MULTICOMMENT
    NATIVE
    NEW
    OCTAL_NUMBER
    POT
    RETURN
    SHORT
    STRICTFP
    SUPER
    SWITCH
    SYNCHRONIZED
    TERNARY
    THIS
    THROW
    THROWS
    TRANSIENT
    TRY
    UNICOMMENT
    VOLATILE

Grammar

Rule 0     S' -> program
Rule 1     program -> class
Rule 2     class -> visibility classmodifier CLASS ID EXTENDS ID LCHAV membros RCHAV
Rule 3     class -> visibility classmodifier CLASS ID LCHAV membros RCHAV
Rule 4     class -> visibility classmodifier CLASS ID IMPLEMENTS LCHAV membros RCHAV
Rule 5     visibility -> PUBLIC
Rule 6     visibility -> PRIVATE
Rule 7     visibility -> PROTECTED
Rule 8     visibility -> <empty>
Rule 9     classmodifier -> <empty>
Rule 10    classmodifier -> ABSTRACT
Rule 11    classmodifier -> FINAL
Rule 12    classmodifier -> PACKAGE
Rule 13    membros -> membro
Rule 14    membros -> membro membros
Rule 15    membro -> atribute
Rule 16    membro -> function
Rule 17    atribute -> visibility atributemodifier type ID SEMICOLON
Rule 18    atribute -> visibility atributemodifier type ID EQUAL ID SEMICOLON
Rule 19    atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON
Rule 20    atributemodifier -> <empty>
Rule 21    atributemodifier -> STATIC
Rule 22    atributemodifier -> FINAL
Rule 23    function -> signature body
Rule 24    signature -> visibility atributemodifier type ID LPAREN sigparams RPAREN
Rule 25    sigparams -> ID brackets_expression
Rule 26    sigparams -> ID brackets_expression COMMA sigparams
Rule 27    body -> LCHAV stms RCHAV
Rule 28    stms -> stm
Rule 29    stms -> stm stms
Rule 30    stm -> expression SEMICOLON
Rule 31    stm -> WHILE LPAREN expression RPAREN bodyorstm
Rule 32    stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON
Rule 33    stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm
Rule 34    stm -> IF LPAREN expression RPAREN bodyorstm
Rule 35    stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm
Rule 36    stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm
Rule 37    stm -> SEMICOLON
Rule 38    bodyorstm -> body
Rule 39    expression -> operator
Rule 40    expression -> call
Rule 41    expression -> FLOAT_NUMBER
Rule 42    expression -> INT_NUMBER
Rule 43    expression -> STRING
Rule 44    expression -> ID
Rule 45    operator -> expression arithmetic expression
Rule 46    operator -> ID assign expression
Rule 47    operator -> expression operatorcomparator expression
Rule 48    operator -> unaryoperatorprefx ID
Rule 49    operator -> ID unaryoperatorsufx
Rule 50    operator -> expression operatorbittobit
Rule 51    brackets_expression -> LBRACKET RBRACKET
Rule 52    brackets_expression -> LBRACKET INT_NUMBER RBRACKET
Rule 53    brackets_expression -> LBRACKET ID RBRACKET
Rule 54    type -> primitivetypes
Rule 55    primitivetypes -> TYPE_INT
Rule 56    primitivetypes -> TYPE_FLOAT
Rule 57    primitivetypes -> TYPE_DOUBLE
Rule 58    primitivetypes -> TYPE_BYTE
Rule 59    primitivetypes -> TYPE_BOOLEAN
Rule 60    primitivetypes -> TYPE_CHAR
Rule 61    primitivetypes -> TYPE_STRING
Rule 62    primitivetypes -> TYPE_LONG
Rule 63    primitivetypes -> TYPE_VOID
Rule 64    arithmetic -> TIMES
Rule 65    arithmetic -> DIVIDE
Rule 66    arithmetic -> MODULE
Rule 67    arithmetic -> PLUS
Rule 68    arithmetic -> MINUS
Rule 69    assign -> EQUAL
Rule 70    assign -> MINUS_EQ
Rule 71    assign -> TIMES_EQ
Rule 72    assign -> PLUS_EQ
Rule 73    assign -> DIVIDE_EQ
Rule 74    assign -> MOD_EQ
Rule 75    assign -> BITWISE_AND_EQ
Rule 76    assign -> BITWISE_OR_EQ
Rule 77    assign -> BITWISE_XOR_EQ
Rule 78    assign -> URSHIFT_EQ
Rule 79    assign -> LSHIFT_EQ
Rule 80    assign -> RSHIFT_EQ
Rule 81    operatorcomparator -> LEQ
Rule 82    operatorcomparator -> GEQ
Rule 83    operatorcomparator -> LT
Rule 84    operatorcomparator -> GT
Rule 85    operatorcomparator -> NEQ
Rule 86    operatorcomparator -> EQ
Rule 87    operatorcomparator -> AND
Rule 88    operatorcomparator -> OR
Rule 89    operatorcomparator -> BITWISE_AND
Rule 90    operatorcomparator -> BITWISE_OR
Rule 91    operatorcomparator -> BITWISE_XOR
Rule 92    unaryoperatorprefx -> INCREMENT
Rule 93    unaryoperatorprefx -> DECREMENT
Rule 94    unaryoperatorprefx -> MINUS
Rule 95    unaryoperatorprefx -> PLUS
Rule 96    unaryoperatorprefx -> NOT
Rule 97    unaryoperatorsufx -> INCREMENT
Rule 98    unaryoperatorsufx -> DECREMENT
Rule 99    operatorbittobit -> URSHIFT
Rule 100   operatorbittobit -> LSHIFT
Rule 101   operatorbittobit -> RSHIFT
Rule 102   call -> ID LPAREN params RPAREN
Rule 103   call -> ID LPAREN RPAREN
Rule 104   params -> expression COMMA params
Rule 105   params -> expression

Terminals, with rules where they appear

ABSTRACT             : 10
AND                  : 87
ASSERT               : 
BIN_NUMBER           : 
BITWISE_AND          : 89
BITWISE_AND_EQ       : 75
BITWISE_NOT          : 
BITWISE_OR           : 90
BITWISE_OR_EQ        : 76
BITWISE_XOR          : 91
BITWISE_XOR_EQ       : 77
BREAK                : 
BYTE_NUMBER          : 
CASE                 : 
CATCH                : 
CHAR                 : 
CLASS                : 2 3 4
COMMA                : 26 104
CONST                : 
CONTINUE             : 
DECREMENT            : 93 98
DEFAULT              : 
DIVIDE               : 65
DIVIDE_EQ            : 73
DO                   : 32
DOT                  : 
DOUBLE_NUMBER        : 
ELSE                 : 35 36
ENUM                 : 
EQ                   : 86
EQUAL                : 18 19 69
EXTENDS              : 2
FINAL                : 11 22
FINALLY              : 
FLOAT_NUMBER         : 41
FOR                  : 33
GEQ                  : 82
GOTO                 : 
GT                   : 84
HEXA_NUMBER          : 
ID                   : 2 2 3 4 17 18 18 19 24 25 26 44 46 48 49 53 102 103
IF                   : 34 35 36 36
IMPLEMENTS           : 4
IMPORT               : 
INCREMENT            : 92 97
INSTANCEOF           : 
INTERFACE            : 
INT_NUMBER           : 42 52
LBRACKET             : 51 52 53
LCHAV                : 2 3 4 27
LEQ                  : 81
LONG_NUMBER          : 
LPAREN               : 24 31 32 33 34 35 36 102 103
LSHIFT               : 100
LSHIFT_EQ            : 79
LT                   : 83
MINUS                : 68 94
MINUS_EQ             : 70
MODULE               : 66
MOD_EQ               : 74
MULTICOMMENT         : 
NATIVE               : 
NEQ                  : 85
NEW                  : 
NOT                  : 96
OCTAL_NUMBER         : 
OR                   : 88
PACKAGE              : 12
PLUS                 : 67 95
PLUS_EQ              : 72
POT                  : 
PRIVATE              : 6
PROTECTED            : 7
PUBLIC               : 5
RBRACKET             : 51 52 53
RCHAV                : 2 3 4 27
RETURN               : 
RPAREN               : 24 31 32 33 34 35 36 102 103
RSHIFT               : 101
RSHIFT_EQ            : 80
SEMICOLON            : 17 18 19 30 32 33 33 33 37
SHORT                : 
STATIC               : 21
STRICTFP             : 
STRING               : 43
SUPER                : 
SWITCH               : 
SYNCHRONIZED         : 
TERNARY              : 
THIS                 : 
THROW                : 
THROWS               : 
TIMES                : 64
TIMES_EQ             : 71
TRANSIENT            : 
TRY                  : 
TYPE_BOOLEAN         : 59
TYPE_BYTE            : 58
TYPE_CHAR            : 60
TYPE_DOUBLE          : 57
TYPE_FLOAT           : 56
TYPE_INT             : 55
TYPE_LONG            : 62
TYPE_STRING          : 61
TYPE_VOID            : 63
UNICOMMENT           : 
URSHIFT              : 99
URSHIFT_EQ           : 78
VOLATILE             : 
WHILE                : 31 32
error                : 

Nonterminals, with rules where they appear

arithmetic           : 45
assign               : 46
atribute             : 15
atributemodifier     : 17 18 19 24
body                 : 23 38
bodyorstm            : 31 32 33 34 35 35 36 36
brackets_expression  : 25 26
call                 : 40
class                : 1
classmodifier        : 2 3 4
expression           : 19 30 31 32 33 33 33 34 35 36 45 45 46 47 47 50 104 105
function             : 16
membro               : 13 14
membros              : 2 3 4 14
operator             : 39
operatorbittobit     : 50
operatorcomparator   : 47
params               : 102 104
primitivetypes       : 54
program              : 0
signature            : 23
sigparams            : 24 26
stm                  : 28 29
stms                 : 27 29
type                 : 17 18 19 24
unaryoperatorprefx   : 48
unaryoperatorsufx    : 49
visibility           : 2 3 4 17 18 19 24

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . class
    (2) class -> . visibility classmodifier CLASS ID EXTENDS ID LCHAV membros RCHAV
    (3) class -> . visibility classmodifier CLASS ID LCHAV membros RCHAV
    (4) class -> . visibility classmodifier CLASS ID IMPLEMENTS LCHAV membros RCHAV
    (5) visibility -> . PUBLIC
    (6) visibility -> . PRIVATE
    (7) visibility -> . PROTECTED
    (8) visibility -> .

    PUBLIC          shift and go to state 4
    PRIVATE         shift and go to state 5
    PROTECTED       shift and go to state 6
    ABSTRACT        reduce using rule 8 (visibility -> .)
    FINAL           reduce using rule 8 (visibility -> .)
    PACKAGE         reduce using rule 8 (visibility -> .)
    CLASS           reduce using rule 8 (visibility -> .)

    program                        shift and go to state 1
    class                          shift and go to state 2
    visibility                     shift and go to state 3

state 1

    (0) S' -> program .



state 2

    (1) program -> class .

    $end            reduce using rule 1 (program -> class .)


state 3

    (2) class -> visibility . classmodifier CLASS ID EXTENDS ID LCHAV membros RCHAV
    (3) class -> visibility . classmodifier CLASS ID LCHAV membros RCHAV
    (4) class -> visibility . classmodifier CLASS ID IMPLEMENTS LCHAV membros RCHAV
    (9) classmodifier -> .
    (10) classmodifier -> . ABSTRACT
    (11) classmodifier -> . FINAL
    (12) classmodifier -> . PACKAGE

    CLASS           reduce using rule 9 (classmodifier -> .)
    ABSTRACT        shift and go to state 8
    FINAL           shift and go to state 9
    PACKAGE         shift and go to state 10

    classmodifier                  shift and go to state 7

state 4

    (5) visibility -> PUBLIC .

    ABSTRACT        reduce using rule 5 (visibility -> PUBLIC .)
    FINAL           reduce using rule 5 (visibility -> PUBLIC .)
    PACKAGE         reduce using rule 5 (visibility -> PUBLIC .)
    CLASS           reduce using rule 5 (visibility -> PUBLIC .)
    STATIC          reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_INT        reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_FLOAT      reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_DOUBLE     reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_BYTE       reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_BOOLEAN    reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_CHAR       reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_STRING     reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_LONG       reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_VOID       reduce using rule 5 (visibility -> PUBLIC .)


state 5

    (6) visibility -> PRIVATE .

    ABSTRACT        reduce using rule 6 (visibility -> PRIVATE .)
    FINAL           reduce using rule 6 (visibility -> PRIVATE .)
    PACKAGE         reduce using rule 6 (visibility -> PRIVATE .)
    CLASS           reduce using rule 6 (visibility -> PRIVATE .)
    STATIC          reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_INT        reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_FLOAT      reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_DOUBLE     reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_BYTE       reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_BOOLEAN    reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_CHAR       reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_STRING     reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_LONG       reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_VOID       reduce using rule 6 (visibility -> PRIVATE .)


state 6

    (7) visibility -> PROTECTED .

    ABSTRACT        reduce using rule 7 (visibility -> PROTECTED .)
    FINAL           reduce using rule 7 (visibility -> PROTECTED .)
    PACKAGE         reduce using rule 7 (visibility -> PROTECTED .)
    CLASS           reduce using rule 7 (visibility -> PROTECTED .)
    STATIC          reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_INT        reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_FLOAT      reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_DOUBLE     reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_BYTE       reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_BOOLEAN    reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_CHAR       reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_STRING     reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_LONG       reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_VOID       reduce using rule 7 (visibility -> PROTECTED .)


state 7

    (2) class -> visibility classmodifier . CLASS ID EXTENDS ID LCHAV membros RCHAV
    (3) class -> visibility classmodifier . CLASS ID LCHAV membros RCHAV
    (4) class -> visibility classmodifier . CLASS ID IMPLEMENTS LCHAV membros RCHAV

    CLASS           shift and go to state 11


state 8

    (10) classmodifier -> ABSTRACT .

    CLASS           reduce using rule 10 (classmodifier -> ABSTRACT .)


state 9

    (11) classmodifier -> FINAL .

    CLASS           reduce using rule 11 (classmodifier -> FINAL .)


state 10

    (12) classmodifier -> PACKAGE .

    CLASS           reduce using rule 12 (classmodifier -> PACKAGE .)


state 11

    (2) class -> visibility classmodifier CLASS . ID EXTENDS ID LCHAV membros RCHAV
    (3) class -> visibility classmodifier CLASS . ID LCHAV membros RCHAV
    (4) class -> visibility classmodifier CLASS . ID IMPLEMENTS LCHAV membros RCHAV

    ID              shift and go to state 12


state 12

    (2) class -> visibility classmodifier CLASS ID . EXTENDS ID LCHAV membros RCHAV
    (3) class -> visibility classmodifier CLASS ID . LCHAV membros RCHAV
    (4) class -> visibility classmodifier CLASS ID . IMPLEMENTS LCHAV membros RCHAV

    EXTENDS         shift and go to state 13
    LCHAV           shift and go to state 14
    IMPLEMENTS      shift and go to state 15


state 13

    (2) class -> visibility classmodifier CLASS ID EXTENDS . ID LCHAV membros RCHAV

    ID              shift and go to state 16


state 14

    (3) class -> visibility classmodifier CLASS ID LCHAV . membros RCHAV
    (13) membros -> . membro
    (14) membros -> . membro membros
    (15) membro -> . atribute
    (16) membro -> . function
    (17) atribute -> . visibility atributemodifier type ID SEMICOLON
    (18) atribute -> . visibility atributemodifier type ID EQUAL ID SEMICOLON
    (19) atribute -> . visibility atributemodifier type ID EQUAL expression SEMICOLON
    (23) function -> . signature body
    (5) visibility -> . PUBLIC
    (6) visibility -> . PRIVATE
    (7) visibility -> . PROTECTED
    (8) visibility -> .
    (24) signature -> . visibility atributemodifier type ID LPAREN sigparams RPAREN

    PUBLIC          shift and go to state 4
    PRIVATE         shift and go to state 5
    PROTECTED       shift and go to state 6
    STATIC          reduce using rule 8 (visibility -> .)
    FINAL           reduce using rule 8 (visibility -> .)
    TYPE_INT        reduce using rule 8 (visibility -> .)
    TYPE_FLOAT      reduce using rule 8 (visibility -> .)
    TYPE_DOUBLE     reduce using rule 8 (visibility -> .)
    TYPE_BYTE       reduce using rule 8 (visibility -> .)
    TYPE_BOOLEAN    reduce using rule 8 (visibility -> .)
    TYPE_CHAR       reduce using rule 8 (visibility -> .)
    TYPE_STRING     reduce using rule 8 (visibility -> .)
    TYPE_LONG       reduce using rule 8 (visibility -> .)
    TYPE_VOID       reduce using rule 8 (visibility -> .)

    visibility                     shift and go to state 17
    membros                        shift and go to state 18
    membro                         shift and go to state 19
    atribute                       shift and go to state 20
    function                       shift and go to state 21
    signature                      shift and go to state 22

state 15

    (4) class -> visibility classmodifier CLASS ID IMPLEMENTS . LCHAV membros RCHAV

    LCHAV           shift and go to state 23


state 16

    (2) class -> visibility classmodifier CLASS ID EXTENDS ID . LCHAV membros RCHAV

    LCHAV           shift and go to state 24


state 17

    (17) atribute -> visibility . atributemodifier type ID SEMICOLON
    (18) atribute -> visibility . atributemodifier type ID EQUAL ID SEMICOLON
    (19) atribute -> visibility . atributemodifier type ID EQUAL expression SEMICOLON
    (24) signature -> visibility . atributemodifier type ID LPAREN sigparams RPAREN
    (20) atributemodifier -> .
    (21) atributemodifier -> . STATIC
    (22) atributemodifier -> . FINAL

    TYPE_INT        reduce using rule 20 (atributemodifier -> .)
    TYPE_FLOAT      reduce using rule 20 (atributemodifier -> .)
    TYPE_DOUBLE     reduce using rule 20 (atributemodifier -> .)
    TYPE_BYTE       reduce using rule 20 (atributemodifier -> .)
    TYPE_BOOLEAN    reduce using rule 20 (atributemodifier -> .)
    TYPE_CHAR       reduce using rule 20 (atributemodifier -> .)
    TYPE_STRING     reduce using rule 20 (atributemodifier -> .)
    TYPE_LONG       reduce using rule 20 (atributemodifier -> .)
    TYPE_VOID       reduce using rule 20 (atributemodifier -> .)
    STATIC          shift and go to state 26
    FINAL           shift and go to state 27

    atributemodifier               shift and go to state 25

state 18

    (3) class -> visibility classmodifier CLASS ID LCHAV membros . RCHAV

    RCHAV           shift and go to state 28


state 19

    (13) membros -> membro .
    (14) membros -> membro . membros
    (13) membros -> . membro
    (14) membros -> . membro membros
    (15) membro -> . atribute
    (16) membro -> . function
    (17) atribute -> . visibility atributemodifier type ID SEMICOLON
    (18) atribute -> . visibility atributemodifier type ID EQUAL ID SEMICOLON
    (19) atribute -> . visibility atributemodifier type ID EQUAL expression SEMICOLON
    (23) function -> . signature body
    (5) visibility -> . PUBLIC
    (6) visibility -> . PRIVATE
    (7) visibility -> . PROTECTED
    (8) visibility -> .
    (24) signature -> . visibility atributemodifier type ID LPAREN sigparams RPAREN

    RCHAV           reduce using rule 13 (membros -> membro .)
    PUBLIC          shift and go to state 4
    PRIVATE         shift and go to state 5
    PROTECTED       shift and go to state 6
    STATIC          reduce using rule 8 (visibility -> .)
    FINAL           reduce using rule 8 (visibility -> .)
    TYPE_INT        reduce using rule 8 (visibility -> .)
    TYPE_FLOAT      reduce using rule 8 (visibility -> .)
    TYPE_DOUBLE     reduce using rule 8 (visibility -> .)
    TYPE_BYTE       reduce using rule 8 (visibility -> .)
    TYPE_BOOLEAN    reduce using rule 8 (visibility -> .)
    TYPE_CHAR       reduce using rule 8 (visibility -> .)
    TYPE_STRING     reduce using rule 8 (visibility -> .)
    TYPE_LONG       reduce using rule 8 (visibility -> .)
    TYPE_VOID       reduce using rule 8 (visibility -> .)

    membro                         shift and go to state 19
    membros                        shift and go to state 29
    atribute                       shift and go to state 20
    function                       shift and go to state 21
    visibility                     shift and go to state 17
    signature                      shift and go to state 22

state 20

    (15) membro -> atribute .

    PUBLIC          reduce using rule 15 (membro -> atribute .)
    PRIVATE         reduce using rule 15 (membro -> atribute .)
    PROTECTED       reduce using rule 15 (membro -> atribute .)
    STATIC          reduce using rule 15 (membro -> atribute .)
    FINAL           reduce using rule 15 (membro -> atribute .)
    TYPE_INT        reduce using rule 15 (membro -> atribute .)
    TYPE_FLOAT      reduce using rule 15 (membro -> atribute .)
    TYPE_DOUBLE     reduce using rule 15 (membro -> atribute .)
    TYPE_BYTE       reduce using rule 15 (membro -> atribute .)
    TYPE_BOOLEAN    reduce using rule 15 (membro -> atribute .)
    TYPE_CHAR       reduce using rule 15 (membro -> atribute .)
    TYPE_STRING     reduce using rule 15 (membro -> atribute .)
    TYPE_LONG       reduce using rule 15 (membro -> atribute .)
    TYPE_VOID       reduce using rule 15 (membro -> atribute .)
    RCHAV           reduce using rule 15 (membro -> atribute .)


state 21

    (16) membro -> function .

    PUBLIC          reduce using rule 16 (membro -> function .)
    PRIVATE         reduce using rule 16 (membro -> function .)
    PROTECTED       reduce using rule 16 (membro -> function .)
    STATIC          reduce using rule 16 (membro -> function .)
    FINAL           reduce using rule 16 (membro -> function .)
    TYPE_INT        reduce using rule 16 (membro -> function .)
    TYPE_FLOAT      reduce using rule 16 (membro -> function .)
    TYPE_DOUBLE     reduce using rule 16 (membro -> function .)
    TYPE_BYTE       reduce using rule 16 (membro -> function .)
    TYPE_BOOLEAN    reduce using rule 16 (membro -> function .)
    TYPE_CHAR       reduce using rule 16 (membro -> function .)
    TYPE_STRING     reduce using rule 16 (membro -> function .)
    TYPE_LONG       reduce using rule 16 (membro -> function .)
    TYPE_VOID       reduce using rule 16 (membro -> function .)
    RCHAV           reduce using rule 16 (membro -> function .)


state 22

    (23) function -> signature . body
    (27) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 31

    body                           shift and go to state 30

state 23

    (4) class -> visibility classmodifier CLASS ID IMPLEMENTS LCHAV . membros RCHAV
    (13) membros -> . membro
    (14) membros -> . membro membros
    (15) membro -> . atribute
    (16) membro -> . function
    (17) atribute -> . visibility atributemodifier type ID SEMICOLON
    (18) atribute -> . visibility atributemodifier type ID EQUAL ID SEMICOLON
    (19) atribute -> . visibility atributemodifier type ID EQUAL expression SEMICOLON
    (23) function -> . signature body
    (5) visibility -> . PUBLIC
    (6) visibility -> . PRIVATE
    (7) visibility -> . PROTECTED
    (8) visibility -> .
    (24) signature -> . visibility atributemodifier type ID LPAREN sigparams RPAREN

    PUBLIC          shift and go to state 4
    PRIVATE         shift and go to state 5
    PROTECTED       shift and go to state 6
    STATIC          reduce using rule 8 (visibility -> .)
    FINAL           reduce using rule 8 (visibility -> .)
    TYPE_INT        reduce using rule 8 (visibility -> .)
    TYPE_FLOAT      reduce using rule 8 (visibility -> .)
    TYPE_DOUBLE     reduce using rule 8 (visibility -> .)
    TYPE_BYTE       reduce using rule 8 (visibility -> .)
    TYPE_BOOLEAN    reduce using rule 8 (visibility -> .)
    TYPE_CHAR       reduce using rule 8 (visibility -> .)
    TYPE_STRING     reduce using rule 8 (visibility -> .)
    TYPE_LONG       reduce using rule 8 (visibility -> .)
    TYPE_VOID       reduce using rule 8 (visibility -> .)

    visibility                     shift and go to state 17
    membros                        shift and go to state 32
    membro                         shift and go to state 19
    atribute                       shift and go to state 20
    function                       shift and go to state 21
    signature                      shift and go to state 22

state 24

    (2) class -> visibility classmodifier CLASS ID EXTENDS ID LCHAV . membros RCHAV
    (13) membros -> . membro
    (14) membros -> . membro membros
    (15) membro -> . atribute
    (16) membro -> . function
    (17) atribute -> . visibility atributemodifier type ID SEMICOLON
    (18) atribute -> . visibility atributemodifier type ID EQUAL ID SEMICOLON
    (19) atribute -> . visibility atributemodifier type ID EQUAL expression SEMICOLON
    (23) function -> . signature body
    (5) visibility -> . PUBLIC
    (6) visibility -> . PRIVATE
    (7) visibility -> . PROTECTED
    (8) visibility -> .
    (24) signature -> . visibility atributemodifier type ID LPAREN sigparams RPAREN

    PUBLIC          shift and go to state 4
    PRIVATE         shift and go to state 5
    PROTECTED       shift and go to state 6
    STATIC          reduce using rule 8 (visibility -> .)
    FINAL           reduce using rule 8 (visibility -> .)
    TYPE_INT        reduce using rule 8 (visibility -> .)
    TYPE_FLOAT      reduce using rule 8 (visibility -> .)
    TYPE_DOUBLE     reduce using rule 8 (visibility -> .)
    TYPE_BYTE       reduce using rule 8 (visibility -> .)
    TYPE_BOOLEAN    reduce using rule 8 (visibility -> .)
    TYPE_CHAR       reduce using rule 8 (visibility -> .)
    TYPE_STRING     reduce using rule 8 (visibility -> .)
    TYPE_LONG       reduce using rule 8 (visibility -> .)
    TYPE_VOID       reduce using rule 8 (visibility -> .)

    visibility                     shift and go to state 17
    membros                        shift and go to state 33
    membro                         shift and go to state 19
    atribute                       shift and go to state 20
    function                       shift and go to state 21
    signature                      shift and go to state 22

state 25

    (17) atribute -> visibility atributemodifier . type ID SEMICOLON
    (18) atribute -> visibility atributemodifier . type ID EQUAL ID SEMICOLON
    (19) atribute -> visibility atributemodifier . type ID EQUAL expression SEMICOLON
    (24) signature -> visibility atributemodifier . type ID LPAREN sigparams RPAREN
    (54) type -> . primitivetypes
    (55) primitivetypes -> . TYPE_INT
    (56) primitivetypes -> . TYPE_FLOAT
    (57) primitivetypes -> . TYPE_DOUBLE
    (58) primitivetypes -> . TYPE_BYTE
    (59) primitivetypes -> . TYPE_BOOLEAN
    (60) primitivetypes -> . TYPE_CHAR
    (61) primitivetypes -> . TYPE_STRING
    (62) primitivetypes -> . TYPE_LONG
    (63) primitivetypes -> . TYPE_VOID

    TYPE_INT        shift and go to state 36
    TYPE_FLOAT      shift and go to state 37
    TYPE_DOUBLE     shift and go to state 38
    TYPE_BYTE       shift and go to state 39
    TYPE_BOOLEAN    shift and go to state 40
    TYPE_CHAR       shift and go to state 41
    TYPE_STRING     shift and go to state 42
    TYPE_LONG       shift and go to state 43
    TYPE_VOID       shift and go to state 44

    type                           shift and go to state 34
    primitivetypes                 shift and go to state 35

state 26

    (21) atributemodifier -> STATIC .

    TYPE_INT        reduce using rule 21 (atributemodifier -> STATIC .)
    TYPE_FLOAT      reduce using rule 21 (atributemodifier -> STATIC .)
    TYPE_DOUBLE     reduce using rule 21 (atributemodifier -> STATIC .)
    TYPE_BYTE       reduce using rule 21 (atributemodifier -> STATIC .)
    TYPE_BOOLEAN    reduce using rule 21 (atributemodifier -> STATIC .)
    TYPE_CHAR       reduce using rule 21 (atributemodifier -> STATIC .)
    TYPE_STRING     reduce using rule 21 (atributemodifier -> STATIC .)
    TYPE_LONG       reduce using rule 21 (atributemodifier -> STATIC .)
    TYPE_VOID       reduce using rule 21 (atributemodifier -> STATIC .)


state 27

    (22) atributemodifier -> FINAL .

    TYPE_INT        reduce using rule 22 (atributemodifier -> FINAL .)
    TYPE_FLOAT      reduce using rule 22 (atributemodifier -> FINAL .)
    TYPE_DOUBLE     reduce using rule 22 (atributemodifier -> FINAL .)
    TYPE_BYTE       reduce using rule 22 (atributemodifier -> FINAL .)
    TYPE_BOOLEAN    reduce using rule 22 (atributemodifier -> FINAL .)
    TYPE_CHAR       reduce using rule 22 (atributemodifier -> FINAL .)
    TYPE_STRING     reduce using rule 22 (atributemodifier -> FINAL .)
    TYPE_LONG       reduce using rule 22 (atributemodifier -> FINAL .)
    TYPE_VOID       reduce using rule 22 (atributemodifier -> FINAL .)


state 28

    (3) class -> visibility classmodifier CLASS ID LCHAV membros RCHAV .

    $end            reduce using rule 3 (class -> visibility classmodifier CLASS ID LCHAV membros RCHAV .)


state 29

    (14) membros -> membro membros .

    RCHAV           reduce using rule 14 (membros -> membro membros .)


state 30

    (23) function -> signature body .

    PUBLIC          reduce using rule 23 (function -> signature body .)
    PRIVATE         reduce using rule 23 (function -> signature body .)
    PROTECTED       reduce using rule 23 (function -> signature body .)
    STATIC          reduce using rule 23 (function -> signature body .)
    FINAL           reduce using rule 23 (function -> signature body .)
    TYPE_INT        reduce using rule 23 (function -> signature body .)
    TYPE_FLOAT      reduce using rule 23 (function -> signature body .)
    TYPE_DOUBLE     reduce using rule 23 (function -> signature body .)
    TYPE_BYTE       reduce using rule 23 (function -> signature body .)
    TYPE_BOOLEAN    reduce using rule 23 (function -> signature body .)
    TYPE_CHAR       reduce using rule 23 (function -> signature body .)
    TYPE_STRING     reduce using rule 23 (function -> signature body .)
    TYPE_LONG       reduce using rule 23 (function -> signature body .)
    TYPE_VOID       reduce using rule 23 (function -> signature body .)
    RCHAV           reduce using rule 23 (function -> signature body .)


state 31

    (27) body -> LCHAV . stms RCHAV
    (28) stms -> . stm
    (29) stms -> . stm stms
    (30) stm -> . expression SEMICOLON
    (31) stm -> . WHILE LPAREN expression RPAREN bodyorstm
    (32) stm -> . DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON
    (33) stm -> . FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm
    (34) stm -> . IF LPAREN expression RPAREN bodyorstm
    (35) stm -> . IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm
    (36) stm -> . IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm
    (37) stm -> . SEMICOLON
    (39) expression -> . operator
    (40) expression -> . call
    (41) expression -> . FLOAT_NUMBER
    (42) expression -> . INT_NUMBER
    (43) expression -> . STRING
    (44) expression -> . ID
    (45) operator -> . expression arithmetic expression
    (46) operator -> . ID assign expression
    (47) operator -> . expression operatorcomparator expression
    (48) operator -> . unaryoperatorprefx ID
    (49) operator -> . ID unaryoperatorsufx
    (50) operator -> . expression operatorbittobit
    (102) call -> . ID LPAREN params RPAREN
    (103) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    WHILE           shift and go to state 49
    DO              shift and go to state 50
    FOR             shift and go to state 51
    IF              shift and go to state 52
    SEMICOLON       shift and go to state 48
    FLOAT_NUMBER    shift and go to state 55
    INT_NUMBER      shift and go to state 56
    STRING          shift and go to state 57
    ID              shift and go to state 58
    INCREMENT       shift and go to state 60
    DECREMENT       shift and go to state 61
    MINUS           shift and go to state 62
    PLUS            shift and go to state 63
    NOT             shift and go to state 64

    stms                           shift and go to state 45
    stm                            shift and go to state 46
    expression                     shift and go to state 47
    operator                       shift and go to state 53
    call                           shift and go to state 54
    unaryoperatorprefx             shift and go to state 59

state 32

    (4) class -> visibility classmodifier CLASS ID IMPLEMENTS LCHAV membros . RCHAV

    RCHAV           shift and go to state 65


state 33

    (2) class -> visibility classmodifier CLASS ID EXTENDS ID LCHAV membros . RCHAV

    RCHAV           shift and go to state 66


state 34

    (17) atribute -> visibility atributemodifier type . ID SEMICOLON
    (18) atribute -> visibility atributemodifier type . ID EQUAL ID SEMICOLON
    (19) atribute -> visibility atributemodifier type . ID EQUAL expression SEMICOLON
    (24) signature -> visibility atributemodifier type . ID LPAREN sigparams RPAREN

    ID              shift and go to state 67


state 35

    (54) type -> primitivetypes .

    ID              reduce using rule 54 (type -> primitivetypes .)


state 36

    (55) primitivetypes -> TYPE_INT .

    ID              reduce using rule 55 (primitivetypes -> TYPE_INT .)


state 37

    (56) primitivetypes -> TYPE_FLOAT .

    ID              reduce using rule 56 (primitivetypes -> TYPE_FLOAT .)


state 38

    (57) primitivetypes -> TYPE_DOUBLE .

    ID              reduce using rule 57 (primitivetypes -> TYPE_DOUBLE .)


state 39

    (58) primitivetypes -> TYPE_BYTE .

    ID              reduce using rule 58 (primitivetypes -> TYPE_BYTE .)


state 40

    (59) primitivetypes -> TYPE_BOOLEAN .

    ID              reduce using rule 59 (primitivetypes -> TYPE_BOOLEAN .)


state 41

    (60) primitivetypes -> TYPE_CHAR .

    ID              reduce using rule 60 (primitivetypes -> TYPE_CHAR .)


state 42

    (61) primitivetypes -> TYPE_STRING .

    ID              reduce using rule 61 (primitivetypes -> TYPE_STRING .)


state 43

    (62) primitivetypes -> TYPE_LONG .

    ID              reduce using rule 62 (primitivetypes -> TYPE_LONG .)


state 44

    (63) primitivetypes -> TYPE_VOID .

    ID              reduce using rule 63 (primitivetypes -> TYPE_VOID .)


state 45

    (27) body -> LCHAV stms . RCHAV

    RCHAV           shift and go to state 68


state 46

    (28) stms -> stm .
    (29) stms -> stm . stms
    (28) stms -> . stm
    (29) stms -> . stm stms
    (30) stm -> . expression SEMICOLON
    (31) stm -> . WHILE LPAREN expression RPAREN bodyorstm
    (32) stm -> . DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON
    (33) stm -> . FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm
    (34) stm -> . IF LPAREN expression RPAREN bodyorstm
    (35) stm -> . IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm
    (36) stm -> . IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm
    (37) stm -> . SEMICOLON
    (39) expression -> . operator
    (40) expression -> . call
    (41) expression -> . FLOAT_NUMBER
    (42) expression -> . INT_NUMBER
    (43) expression -> . STRING
    (44) expression -> . ID
    (45) operator -> . expression arithmetic expression
    (46) operator -> . ID assign expression
    (47) operator -> . expression operatorcomparator expression
    (48) operator -> . unaryoperatorprefx ID
    (49) operator -> . ID unaryoperatorsufx
    (50) operator -> . expression operatorbittobit
    (102) call -> . ID LPAREN params RPAREN
    (103) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    RCHAV           reduce using rule 28 (stms -> stm .)
    WHILE           shift and go to state 49
    DO              shift and go to state 50
    FOR             shift and go to state 51
    IF              shift and go to state 52
    SEMICOLON       shift and go to state 48
    FLOAT_NUMBER    shift and go to state 55
    INT_NUMBER      shift and go to state 56
    STRING          shift and go to state 57
    ID              shift and go to state 58
    INCREMENT       shift and go to state 60
    DECREMENT       shift and go to state 61
    MINUS           shift and go to state 62
    PLUS            shift and go to state 63
    NOT             shift and go to state 64

    stm                            shift and go to state 46
    stms                           shift and go to state 69
    expression                     shift and go to state 47
    operator                       shift and go to state 53
    call                           shift and go to state 54
    unaryoperatorprefx             shift and go to state 59

state 47

    (30) stm -> expression . SEMICOLON
    (45) operator -> expression . arithmetic expression
    (47) operator -> expression . operatorcomparator expression
    (50) operator -> expression . operatorbittobit
    (64) arithmetic -> . TIMES
    (65) arithmetic -> . DIVIDE
    (66) arithmetic -> . MODULE
    (67) arithmetic -> . PLUS
    (68) arithmetic -> . MINUS
    (81) operatorcomparator -> . LEQ
    (82) operatorcomparator -> . GEQ
    (83) operatorcomparator -> . LT
    (84) operatorcomparator -> . GT
    (85) operatorcomparator -> . NEQ
    (86) operatorcomparator -> . EQ
    (87) operatorcomparator -> . AND
    (88) operatorcomparator -> . OR
    (89) operatorcomparator -> . BITWISE_AND
    (90) operatorcomparator -> . BITWISE_OR
    (91) operatorcomparator -> . BITWISE_XOR
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       shift and go to state 70
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75
    MODULE          shift and go to state 76
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78
    LEQ             shift and go to state 79
    GEQ             shift and go to state 80
    LT              shift and go to state 81
    GT              shift and go to state 82
    NEQ             shift and go to state 83
    EQ              shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86
    BITWISE_AND     shift and go to state 87
    BITWISE_OR      shift and go to state 88
    BITWISE_XOR     shift and go to state 89
    URSHIFT         shift and go to state 90
    LSHIFT          shift and go to state 91
    RSHIFT          shift and go to state 92

    arithmetic                     shift and go to state 71
    operatorcomparator             shift and go to state 72
    operatorbittobit               shift and go to state 73

state 48

    (37) stm -> SEMICOLON .

    WHILE           reduce using rule 37 (stm -> SEMICOLON .)
    DO              reduce using rule 37 (stm -> SEMICOLON .)
    FOR             reduce using rule 37 (stm -> SEMICOLON .)
    IF              reduce using rule 37 (stm -> SEMICOLON .)
    SEMICOLON       reduce using rule 37 (stm -> SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 37 (stm -> SEMICOLON .)
    INT_NUMBER      reduce using rule 37 (stm -> SEMICOLON .)
    STRING          reduce using rule 37 (stm -> SEMICOLON .)
    ID              reduce using rule 37 (stm -> SEMICOLON .)
    INCREMENT       reduce using rule 37 (stm -> SEMICOLON .)
    DECREMENT       reduce using rule 37 (stm -> SEMICOLON .)
    MINUS           reduce using rule 37 (stm -> SEMICOLON .)
    PLUS            reduce using rule 37 (stm -> SEMICOLON .)
    NOT             reduce using rule 37 (stm -> SEMICOLON .)
    RCHAV           reduce using rule 37 (stm -> SEMICOLON .)


state 49

    (31) stm -> WHILE . LPAREN expression RPAREN bodyorstm

    LPAREN          shift and go to state 93


state 50

    (32) stm -> DO . bodyorstm WHILE LPAREN expression RPAREN SEMICOLON
    (38) bodyorstm -> . body
    (27) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 31

    bodyorstm                      shift and go to state 94
    body                           shift and go to state 95

state 51

    (33) stm -> FOR . LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm

    LPAREN          shift and go to state 96


state 52

    (34) stm -> IF . LPAREN expression RPAREN bodyorstm
    (35) stm -> IF . LPAREN expression RPAREN bodyorstm ELSE bodyorstm
    (36) stm -> IF . LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm

    LPAREN          shift and go to state 97


state 53

    (39) expression -> operator .

    SEMICOLON       reduce using rule 39 (expression -> operator .)
    TIMES           reduce using rule 39 (expression -> operator .)
    DIVIDE          reduce using rule 39 (expression -> operator .)
    MODULE          reduce using rule 39 (expression -> operator .)
    PLUS            reduce using rule 39 (expression -> operator .)
    MINUS           reduce using rule 39 (expression -> operator .)
    LEQ             reduce using rule 39 (expression -> operator .)
    GEQ             reduce using rule 39 (expression -> operator .)
    LT              reduce using rule 39 (expression -> operator .)
    GT              reduce using rule 39 (expression -> operator .)
    NEQ             reduce using rule 39 (expression -> operator .)
    EQ              reduce using rule 39 (expression -> operator .)
    AND             reduce using rule 39 (expression -> operator .)
    OR              reduce using rule 39 (expression -> operator .)
    BITWISE_AND     reduce using rule 39 (expression -> operator .)
    BITWISE_OR      reduce using rule 39 (expression -> operator .)
    BITWISE_XOR     reduce using rule 39 (expression -> operator .)
    URSHIFT         reduce using rule 39 (expression -> operator .)
    LSHIFT          reduce using rule 39 (expression -> operator .)
    RSHIFT          reduce using rule 39 (expression -> operator .)
    RPAREN          reduce using rule 39 (expression -> operator .)
    COMMA           reduce using rule 39 (expression -> operator .)


state 54

    (40) expression -> call .

    SEMICOLON       reduce using rule 40 (expression -> call .)
    TIMES           reduce using rule 40 (expression -> call .)
    DIVIDE          reduce using rule 40 (expression -> call .)
    MODULE          reduce using rule 40 (expression -> call .)
    PLUS            reduce using rule 40 (expression -> call .)
    MINUS           reduce using rule 40 (expression -> call .)
    LEQ             reduce using rule 40 (expression -> call .)
    GEQ             reduce using rule 40 (expression -> call .)
    LT              reduce using rule 40 (expression -> call .)
    GT              reduce using rule 40 (expression -> call .)
    NEQ             reduce using rule 40 (expression -> call .)
    EQ              reduce using rule 40 (expression -> call .)
    AND             reduce using rule 40 (expression -> call .)
    OR              reduce using rule 40 (expression -> call .)
    BITWISE_AND     reduce using rule 40 (expression -> call .)
    BITWISE_OR      reduce using rule 40 (expression -> call .)
    BITWISE_XOR     reduce using rule 40 (expression -> call .)
    URSHIFT         reduce using rule 40 (expression -> call .)
    LSHIFT          reduce using rule 40 (expression -> call .)
    RSHIFT          reduce using rule 40 (expression -> call .)
    RPAREN          reduce using rule 40 (expression -> call .)
    COMMA           reduce using rule 40 (expression -> call .)


state 55

    (41) expression -> FLOAT_NUMBER .

    SEMICOLON       reduce using rule 41 (expression -> FLOAT_NUMBER .)
    TIMES           reduce using rule 41 (expression -> FLOAT_NUMBER .)
    DIVIDE          reduce using rule 41 (expression -> FLOAT_NUMBER .)
    MODULE          reduce using rule 41 (expression -> FLOAT_NUMBER .)
    PLUS            reduce using rule 41 (expression -> FLOAT_NUMBER .)
    MINUS           reduce using rule 41 (expression -> FLOAT_NUMBER .)
    LEQ             reduce using rule 41 (expression -> FLOAT_NUMBER .)
    GEQ             reduce using rule 41 (expression -> FLOAT_NUMBER .)
    LT              reduce using rule 41 (expression -> FLOAT_NUMBER .)
    GT              reduce using rule 41 (expression -> FLOAT_NUMBER .)
    NEQ             reduce using rule 41 (expression -> FLOAT_NUMBER .)
    EQ              reduce using rule 41 (expression -> FLOAT_NUMBER .)
    AND             reduce using rule 41 (expression -> FLOAT_NUMBER .)
    OR              reduce using rule 41 (expression -> FLOAT_NUMBER .)
    BITWISE_AND     reduce using rule 41 (expression -> FLOAT_NUMBER .)
    BITWISE_OR      reduce using rule 41 (expression -> FLOAT_NUMBER .)
    BITWISE_XOR     reduce using rule 41 (expression -> FLOAT_NUMBER .)
    URSHIFT         reduce using rule 41 (expression -> FLOAT_NUMBER .)
    LSHIFT          reduce using rule 41 (expression -> FLOAT_NUMBER .)
    RSHIFT          reduce using rule 41 (expression -> FLOAT_NUMBER .)
    RPAREN          reduce using rule 41 (expression -> FLOAT_NUMBER .)
    COMMA           reduce using rule 41 (expression -> FLOAT_NUMBER .)


state 56

    (42) expression -> INT_NUMBER .

    SEMICOLON       reduce using rule 42 (expression -> INT_NUMBER .)
    TIMES           reduce using rule 42 (expression -> INT_NUMBER .)
    DIVIDE          reduce using rule 42 (expression -> INT_NUMBER .)
    MODULE          reduce using rule 42 (expression -> INT_NUMBER .)
    PLUS            reduce using rule 42 (expression -> INT_NUMBER .)
    MINUS           reduce using rule 42 (expression -> INT_NUMBER .)
    LEQ             reduce using rule 42 (expression -> INT_NUMBER .)
    GEQ             reduce using rule 42 (expression -> INT_NUMBER .)
    LT              reduce using rule 42 (expression -> INT_NUMBER .)
    GT              reduce using rule 42 (expression -> INT_NUMBER .)
    NEQ             reduce using rule 42 (expression -> INT_NUMBER .)
    EQ              reduce using rule 42 (expression -> INT_NUMBER .)
    AND             reduce using rule 42 (expression -> INT_NUMBER .)
    OR              reduce using rule 42 (expression -> INT_NUMBER .)
    BITWISE_AND     reduce using rule 42 (expression -> INT_NUMBER .)
    BITWISE_OR      reduce using rule 42 (expression -> INT_NUMBER .)
    BITWISE_XOR     reduce using rule 42 (expression -> INT_NUMBER .)
    URSHIFT         reduce using rule 42 (expression -> INT_NUMBER .)
    LSHIFT          reduce using rule 42 (expression -> INT_NUMBER .)
    RSHIFT          reduce using rule 42 (expression -> INT_NUMBER .)
    RPAREN          reduce using rule 42 (expression -> INT_NUMBER .)
    COMMA           reduce using rule 42 (expression -> INT_NUMBER .)


state 57

    (43) expression -> STRING .

    SEMICOLON       reduce using rule 43 (expression -> STRING .)
    TIMES           reduce using rule 43 (expression -> STRING .)
    DIVIDE          reduce using rule 43 (expression -> STRING .)
    MODULE          reduce using rule 43 (expression -> STRING .)
    PLUS            reduce using rule 43 (expression -> STRING .)
    MINUS           reduce using rule 43 (expression -> STRING .)
    LEQ             reduce using rule 43 (expression -> STRING .)
    GEQ             reduce using rule 43 (expression -> STRING .)
    LT              reduce using rule 43 (expression -> STRING .)
    GT              reduce using rule 43 (expression -> STRING .)
    NEQ             reduce using rule 43 (expression -> STRING .)
    EQ              reduce using rule 43 (expression -> STRING .)
    AND             reduce using rule 43 (expression -> STRING .)
    OR              reduce using rule 43 (expression -> STRING .)
    BITWISE_AND     reduce using rule 43 (expression -> STRING .)
    BITWISE_OR      reduce using rule 43 (expression -> STRING .)
    BITWISE_XOR     reduce using rule 43 (expression -> STRING .)
    URSHIFT         reduce using rule 43 (expression -> STRING .)
    LSHIFT          reduce using rule 43 (expression -> STRING .)
    RSHIFT          reduce using rule 43 (expression -> STRING .)
    RPAREN          reduce using rule 43 (expression -> STRING .)
    COMMA           reduce using rule 43 (expression -> STRING .)


state 58

    (44) expression -> ID .
    (46) operator -> ID . assign expression
    (49) operator -> ID . unaryoperatorsufx
    (102) call -> ID . LPAREN params RPAREN
    (103) call -> ID . LPAREN RPAREN
    (69) assign -> . EQUAL
    (70) assign -> . MINUS_EQ
    (71) assign -> . TIMES_EQ
    (72) assign -> . PLUS_EQ
    (73) assign -> . DIVIDE_EQ
    (74) assign -> . MOD_EQ
    (75) assign -> . BITWISE_AND_EQ
    (76) assign -> . BITWISE_OR_EQ
    (77) assign -> . BITWISE_XOR_EQ
    (78) assign -> . URSHIFT_EQ
    (79) assign -> . LSHIFT_EQ
    (80) assign -> . RSHIFT_EQ
    (97) unaryoperatorsufx -> . INCREMENT
    (98) unaryoperatorsufx -> . DECREMENT

    SEMICOLON       reduce using rule 44 (expression -> ID .)
    TIMES           reduce using rule 44 (expression -> ID .)
    DIVIDE          reduce using rule 44 (expression -> ID .)
    MODULE          reduce using rule 44 (expression -> ID .)
    PLUS            reduce using rule 44 (expression -> ID .)
    MINUS           reduce using rule 44 (expression -> ID .)
    LEQ             reduce using rule 44 (expression -> ID .)
    GEQ             reduce using rule 44 (expression -> ID .)
    LT              reduce using rule 44 (expression -> ID .)
    GT              reduce using rule 44 (expression -> ID .)
    NEQ             reduce using rule 44 (expression -> ID .)
    EQ              reduce using rule 44 (expression -> ID .)
    AND             reduce using rule 44 (expression -> ID .)
    OR              reduce using rule 44 (expression -> ID .)
    BITWISE_AND     reduce using rule 44 (expression -> ID .)
    BITWISE_OR      reduce using rule 44 (expression -> ID .)
    BITWISE_XOR     reduce using rule 44 (expression -> ID .)
    URSHIFT         reduce using rule 44 (expression -> ID .)
    LSHIFT          reduce using rule 44 (expression -> ID .)
    RSHIFT          reduce using rule 44 (expression -> ID .)
    RPAREN          reduce using rule 44 (expression -> ID .)
    COMMA           reduce using rule 44 (expression -> ID .)
    LPAREN          shift and go to state 100
    EQUAL           shift and go to state 101
    MINUS_EQ        shift and go to state 102
    TIMES_EQ        shift and go to state 103
    PLUS_EQ         shift and go to state 104
    DIVIDE_EQ       shift and go to state 105
    MOD_EQ          shift and go to state 106
    BITWISE_AND_EQ  shift and go to state 107
    BITWISE_OR_EQ   shift and go to state 108
    BITWISE_XOR_EQ  shift and go to state 109
    URSHIFT_EQ      shift and go to state 110
    LSHIFT_EQ       shift and go to state 111
    RSHIFT_EQ       shift and go to state 112
    INCREMENT       shift and go to state 113
    DECREMENT       shift and go to state 114

    assign                         shift and go to state 98
    unaryoperatorsufx              shift and go to state 99

state 59

    (48) operator -> unaryoperatorprefx . ID

    ID              shift and go to state 115


state 60

    (92) unaryoperatorprefx -> INCREMENT .

    ID              reduce using rule 92 (unaryoperatorprefx -> INCREMENT .)


state 61

    (93) unaryoperatorprefx -> DECREMENT .

    ID              reduce using rule 93 (unaryoperatorprefx -> DECREMENT .)


state 62

    (94) unaryoperatorprefx -> MINUS .

    ID              reduce using rule 94 (unaryoperatorprefx -> MINUS .)


state 63

    (95) unaryoperatorprefx -> PLUS .

    ID              reduce using rule 95 (unaryoperatorprefx -> PLUS .)


state 64

    (96) unaryoperatorprefx -> NOT .

    ID              reduce using rule 96 (unaryoperatorprefx -> NOT .)


state 65

    (4) class -> visibility classmodifier CLASS ID IMPLEMENTS LCHAV membros RCHAV .

    $end            reduce using rule 4 (class -> visibility classmodifier CLASS ID IMPLEMENTS LCHAV membros RCHAV .)


state 66

    (2) class -> visibility classmodifier CLASS ID EXTENDS ID LCHAV membros RCHAV .

    $end            reduce using rule 2 (class -> visibility classmodifier CLASS ID EXTENDS ID LCHAV membros RCHAV .)


state 67

    (17) atribute -> visibility atributemodifier type ID . SEMICOLON
    (18) atribute -> visibility atributemodifier type ID . EQUAL ID SEMICOLON
    (19) atribute -> visibility atributemodifier type ID . EQUAL expression SEMICOLON
    (24) signature -> visibility atributemodifier type ID . LPAREN sigparams RPAREN

    SEMICOLON       shift and go to state 116
    EQUAL           shift and go to state 117
    LPAREN          shift and go to state 118


state 68

    (27) body -> LCHAV stms RCHAV .

    PUBLIC          reduce using rule 27 (body -> LCHAV stms RCHAV .)
    PRIVATE         reduce using rule 27 (body -> LCHAV stms RCHAV .)
    PROTECTED       reduce using rule 27 (body -> LCHAV stms RCHAV .)
    STATIC          reduce using rule 27 (body -> LCHAV stms RCHAV .)
    FINAL           reduce using rule 27 (body -> LCHAV stms RCHAV .)
    TYPE_INT        reduce using rule 27 (body -> LCHAV stms RCHAV .)
    TYPE_FLOAT      reduce using rule 27 (body -> LCHAV stms RCHAV .)
    TYPE_DOUBLE     reduce using rule 27 (body -> LCHAV stms RCHAV .)
    TYPE_BYTE       reduce using rule 27 (body -> LCHAV stms RCHAV .)
    TYPE_BOOLEAN    reduce using rule 27 (body -> LCHAV stms RCHAV .)
    TYPE_CHAR       reduce using rule 27 (body -> LCHAV stms RCHAV .)
    TYPE_STRING     reduce using rule 27 (body -> LCHAV stms RCHAV .)
    TYPE_LONG       reduce using rule 27 (body -> LCHAV stms RCHAV .)
    TYPE_VOID       reduce using rule 27 (body -> LCHAV stms RCHAV .)
    RCHAV           reduce using rule 27 (body -> LCHAV stms RCHAV .)
    WHILE           reduce using rule 27 (body -> LCHAV stms RCHAV .)
    DO              reduce using rule 27 (body -> LCHAV stms RCHAV .)
    FOR             reduce using rule 27 (body -> LCHAV stms RCHAV .)
    IF              reduce using rule 27 (body -> LCHAV stms RCHAV .)
    SEMICOLON       reduce using rule 27 (body -> LCHAV stms RCHAV .)
    FLOAT_NUMBER    reduce using rule 27 (body -> LCHAV stms RCHAV .)
    INT_NUMBER      reduce using rule 27 (body -> LCHAV stms RCHAV .)
    STRING          reduce using rule 27 (body -> LCHAV stms RCHAV .)
    ID              reduce using rule 27 (body -> LCHAV stms RCHAV .)
    INCREMENT       reduce using rule 27 (body -> LCHAV stms RCHAV .)
    DECREMENT       reduce using rule 27 (body -> LCHAV stms RCHAV .)
    MINUS           reduce using rule 27 (body -> LCHAV stms RCHAV .)
    PLUS            reduce using rule 27 (body -> LCHAV stms RCHAV .)
    NOT             reduce using rule 27 (body -> LCHAV stms RCHAV .)
    ELSE            reduce using rule 27 (body -> LCHAV stms RCHAV .)


state 69

    (29) stms -> stm stms .

    RCHAV           reduce using rule 29 (stms -> stm stms .)


state 70

    (30) stm -> expression SEMICOLON .

    WHILE           reduce using rule 30 (stm -> expression SEMICOLON .)
    DO              reduce using rule 30 (stm -> expression SEMICOLON .)
    FOR             reduce using rule 30 (stm -> expression SEMICOLON .)
    IF              reduce using rule 30 (stm -> expression SEMICOLON .)
    SEMICOLON       reduce using rule 30 (stm -> expression SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 30 (stm -> expression SEMICOLON .)
    INT_NUMBER      reduce using rule 30 (stm -> expression SEMICOLON .)
    STRING          reduce using rule 30 (stm -> expression SEMICOLON .)
    ID              reduce using rule 30 (stm -> expression SEMICOLON .)
    INCREMENT       reduce using rule 30 (stm -> expression SEMICOLON .)
    DECREMENT       reduce using rule 30 (stm -> expression SEMICOLON .)
    MINUS           reduce using rule 30 (stm -> expression SEMICOLON .)
    PLUS            reduce using rule 30 (stm -> expression SEMICOLON .)
    NOT             reduce using rule 30 (stm -> expression SEMICOLON .)
    RCHAV           reduce using rule 30 (stm -> expression SEMICOLON .)


state 71

    (45) operator -> expression arithmetic . expression
    (39) expression -> . operator
    (40) expression -> . call
    (41) expression -> . FLOAT_NUMBER
    (42) expression -> . INT_NUMBER
    (43) expression -> . STRING
    (44) expression -> . ID
    (45) operator -> . expression arithmetic expression
    (46) operator -> . ID assign expression
    (47) operator -> . expression operatorcomparator expression
    (48) operator -> . unaryoperatorprefx ID
    (49) operator -> . ID unaryoperatorsufx
    (50) operator -> . expression operatorbittobit
    (102) call -> . ID LPAREN params RPAREN
    (103) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 55
    INT_NUMBER      shift and go to state 56
    STRING          shift and go to state 57
    ID              shift and go to state 58
    INCREMENT       shift and go to state 60
    DECREMENT       shift and go to state 61
    MINUS           shift and go to state 62
    PLUS            shift and go to state 63
    NOT             shift and go to state 64

    expression                     shift and go to state 119
    operator                       shift and go to state 53
    call                           shift and go to state 54
    unaryoperatorprefx             shift and go to state 59

state 72

    (47) operator -> expression operatorcomparator . expression
    (39) expression -> . operator
    (40) expression -> . call
    (41) expression -> . FLOAT_NUMBER
    (42) expression -> . INT_NUMBER
    (43) expression -> . STRING
    (44) expression -> . ID
    (45) operator -> . expression arithmetic expression
    (46) operator -> . ID assign expression
    (47) operator -> . expression operatorcomparator expression
    (48) operator -> . unaryoperatorprefx ID
    (49) operator -> . ID unaryoperatorsufx
    (50) operator -> . expression operatorbittobit
    (102) call -> . ID LPAREN params RPAREN
    (103) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 55
    INT_NUMBER      shift and go to state 56
    STRING          shift and go to state 57
    ID              shift and go to state 58
    INCREMENT       shift and go to state 60
    DECREMENT       shift and go to state 61
    MINUS           shift and go to state 62
    PLUS            shift and go to state 63
    NOT             shift and go to state 64

    expression                     shift and go to state 120
    operator                       shift and go to state 53
    call                           shift and go to state 54
    unaryoperatorprefx             shift and go to state 59

state 73

    (50) operator -> expression operatorbittobit .

    SEMICOLON       reduce using rule 50 (operator -> expression operatorbittobit .)
    TIMES           reduce using rule 50 (operator -> expression operatorbittobit .)
    DIVIDE          reduce using rule 50 (operator -> expression operatorbittobit .)
    MODULE          reduce using rule 50 (operator -> expression operatorbittobit .)
    PLUS            reduce using rule 50 (operator -> expression operatorbittobit .)
    MINUS           reduce using rule 50 (operator -> expression operatorbittobit .)
    LEQ             reduce using rule 50 (operator -> expression operatorbittobit .)
    GEQ             reduce using rule 50 (operator -> expression operatorbittobit .)
    LT              reduce using rule 50 (operator -> expression operatorbittobit .)
    GT              reduce using rule 50 (operator -> expression operatorbittobit .)
    NEQ             reduce using rule 50 (operator -> expression operatorbittobit .)
    EQ              reduce using rule 50 (operator -> expression operatorbittobit .)
    AND             reduce using rule 50 (operator -> expression operatorbittobit .)
    OR              reduce using rule 50 (operator -> expression operatorbittobit .)
    BITWISE_AND     reduce using rule 50 (operator -> expression operatorbittobit .)
    BITWISE_OR      reduce using rule 50 (operator -> expression operatorbittobit .)
    BITWISE_XOR     reduce using rule 50 (operator -> expression operatorbittobit .)
    URSHIFT         reduce using rule 50 (operator -> expression operatorbittobit .)
    LSHIFT          reduce using rule 50 (operator -> expression operatorbittobit .)
    RSHIFT          reduce using rule 50 (operator -> expression operatorbittobit .)
    RPAREN          reduce using rule 50 (operator -> expression operatorbittobit .)
    COMMA           reduce using rule 50 (operator -> expression operatorbittobit .)


state 74

    (64) arithmetic -> TIMES .

    FLOAT_NUMBER    reduce using rule 64 (arithmetic -> TIMES .)
    INT_NUMBER      reduce using rule 64 (arithmetic -> TIMES .)
    STRING          reduce using rule 64 (arithmetic -> TIMES .)
    ID              reduce using rule 64 (arithmetic -> TIMES .)
    INCREMENT       reduce using rule 64 (arithmetic -> TIMES .)
    DECREMENT       reduce using rule 64 (arithmetic -> TIMES .)
    MINUS           reduce using rule 64 (arithmetic -> TIMES .)
    PLUS            reduce using rule 64 (arithmetic -> TIMES .)
    NOT             reduce using rule 64 (arithmetic -> TIMES .)


state 75

    (65) arithmetic -> DIVIDE .

    FLOAT_NUMBER    reduce using rule 65 (arithmetic -> DIVIDE .)
    INT_NUMBER      reduce using rule 65 (arithmetic -> DIVIDE .)
    STRING          reduce using rule 65 (arithmetic -> DIVIDE .)
    ID              reduce using rule 65 (arithmetic -> DIVIDE .)
    INCREMENT       reduce using rule 65 (arithmetic -> DIVIDE .)
    DECREMENT       reduce using rule 65 (arithmetic -> DIVIDE .)
    MINUS           reduce using rule 65 (arithmetic -> DIVIDE .)
    PLUS            reduce using rule 65 (arithmetic -> DIVIDE .)
    NOT             reduce using rule 65 (arithmetic -> DIVIDE .)


state 76

    (66) arithmetic -> MODULE .

    FLOAT_NUMBER    reduce using rule 66 (arithmetic -> MODULE .)
    INT_NUMBER      reduce using rule 66 (arithmetic -> MODULE .)
    STRING          reduce using rule 66 (arithmetic -> MODULE .)
    ID              reduce using rule 66 (arithmetic -> MODULE .)
    INCREMENT       reduce using rule 66 (arithmetic -> MODULE .)
    DECREMENT       reduce using rule 66 (arithmetic -> MODULE .)
    MINUS           reduce using rule 66 (arithmetic -> MODULE .)
    PLUS            reduce using rule 66 (arithmetic -> MODULE .)
    NOT             reduce using rule 66 (arithmetic -> MODULE .)


state 77

    (67) arithmetic -> PLUS .

    FLOAT_NUMBER    reduce using rule 67 (arithmetic -> PLUS .)
    INT_NUMBER      reduce using rule 67 (arithmetic -> PLUS .)
    STRING          reduce using rule 67 (arithmetic -> PLUS .)
    ID              reduce using rule 67 (arithmetic -> PLUS .)
    INCREMENT       reduce using rule 67 (arithmetic -> PLUS .)
    DECREMENT       reduce using rule 67 (arithmetic -> PLUS .)
    MINUS           reduce using rule 67 (arithmetic -> PLUS .)
    PLUS            reduce using rule 67 (arithmetic -> PLUS .)
    NOT             reduce using rule 67 (arithmetic -> PLUS .)


state 78

    (68) arithmetic -> MINUS .

    FLOAT_NUMBER    reduce using rule 68 (arithmetic -> MINUS .)
    INT_NUMBER      reduce using rule 68 (arithmetic -> MINUS .)
    STRING          reduce using rule 68 (arithmetic -> MINUS .)
    ID              reduce using rule 68 (arithmetic -> MINUS .)
    INCREMENT       reduce using rule 68 (arithmetic -> MINUS .)
    DECREMENT       reduce using rule 68 (arithmetic -> MINUS .)
    MINUS           reduce using rule 68 (arithmetic -> MINUS .)
    PLUS            reduce using rule 68 (arithmetic -> MINUS .)
    NOT             reduce using rule 68 (arithmetic -> MINUS .)


state 79

    (81) operatorcomparator -> LEQ .

    FLOAT_NUMBER    reduce using rule 81 (operatorcomparator -> LEQ .)
    INT_NUMBER      reduce using rule 81 (operatorcomparator -> LEQ .)
    STRING          reduce using rule 81 (operatorcomparator -> LEQ .)
    ID              reduce using rule 81 (operatorcomparator -> LEQ .)
    INCREMENT       reduce using rule 81 (operatorcomparator -> LEQ .)
    DECREMENT       reduce using rule 81 (operatorcomparator -> LEQ .)
    MINUS           reduce using rule 81 (operatorcomparator -> LEQ .)
    PLUS            reduce using rule 81 (operatorcomparator -> LEQ .)
    NOT             reduce using rule 81 (operatorcomparator -> LEQ .)


state 80

    (82) operatorcomparator -> GEQ .

    FLOAT_NUMBER    reduce using rule 82 (operatorcomparator -> GEQ .)
    INT_NUMBER      reduce using rule 82 (operatorcomparator -> GEQ .)
    STRING          reduce using rule 82 (operatorcomparator -> GEQ .)
    ID              reduce using rule 82 (operatorcomparator -> GEQ .)
    INCREMENT       reduce using rule 82 (operatorcomparator -> GEQ .)
    DECREMENT       reduce using rule 82 (operatorcomparator -> GEQ .)
    MINUS           reduce using rule 82 (operatorcomparator -> GEQ .)
    PLUS            reduce using rule 82 (operatorcomparator -> GEQ .)
    NOT             reduce using rule 82 (operatorcomparator -> GEQ .)


state 81

    (83) operatorcomparator -> LT .

    FLOAT_NUMBER    reduce using rule 83 (operatorcomparator -> LT .)
    INT_NUMBER      reduce using rule 83 (operatorcomparator -> LT .)
    STRING          reduce using rule 83 (operatorcomparator -> LT .)
    ID              reduce using rule 83 (operatorcomparator -> LT .)
    INCREMENT       reduce using rule 83 (operatorcomparator -> LT .)
    DECREMENT       reduce using rule 83 (operatorcomparator -> LT .)
    MINUS           reduce using rule 83 (operatorcomparator -> LT .)
    PLUS            reduce using rule 83 (operatorcomparator -> LT .)
    NOT             reduce using rule 83 (operatorcomparator -> LT .)


state 82

    (84) operatorcomparator -> GT .

    FLOAT_NUMBER    reduce using rule 84 (operatorcomparator -> GT .)
    INT_NUMBER      reduce using rule 84 (operatorcomparator -> GT .)
    STRING          reduce using rule 84 (operatorcomparator -> GT .)
    ID              reduce using rule 84 (operatorcomparator -> GT .)
    INCREMENT       reduce using rule 84 (operatorcomparator -> GT .)
    DECREMENT       reduce using rule 84 (operatorcomparator -> GT .)
    MINUS           reduce using rule 84 (operatorcomparator -> GT .)
    PLUS            reduce using rule 84 (operatorcomparator -> GT .)
    NOT             reduce using rule 84 (operatorcomparator -> GT .)


state 83

    (85) operatorcomparator -> NEQ .

    FLOAT_NUMBER    reduce using rule 85 (operatorcomparator -> NEQ .)
    INT_NUMBER      reduce using rule 85 (operatorcomparator -> NEQ .)
    STRING          reduce using rule 85 (operatorcomparator -> NEQ .)
    ID              reduce using rule 85 (operatorcomparator -> NEQ .)
    INCREMENT       reduce using rule 85 (operatorcomparator -> NEQ .)
    DECREMENT       reduce using rule 85 (operatorcomparator -> NEQ .)
    MINUS           reduce using rule 85 (operatorcomparator -> NEQ .)
    PLUS            reduce using rule 85 (operatorcomparator -> NEQ .)
    NOT             reduce using rule 85 (operatorcomparator -> NEQ .)


state 84

    (86) operatorcomparator -> EQ .

    FLOAT_NUMBER    reduce using rule 86 (operatorcomparator -> EQ .)
    INT_NUMBER      reduce using rule 86 (operatorcomparator -> EQ .)
    STRING          reduce using rule 86 (operatorcomparator -> EQ .)
    ID              reduce using rule 86 (operatorcomparator -> EQ .)
    INCREMENT       reduce using rule 86 (operatorcomparator -> EQ .)
    DECREMENT       reduce using rule 86 (operatorcomparator -> EQ .)
    MINUS           reduce using rule 86 (operatorcomparator -> EQ .)
    PLUS            reduce using rule 86 (operatorcomparator -> EQ .)
    NOT             reduce using rule 86 (operatorcomparator -> EQ .)


state 85

    (87) operatorcomparator -> AND .

    FLOAT_NUMBER    reduce using rule 87 (operatorcomparator -> AND .)
    INT_NUMBER      reduce using rule 87 (operatorcomparator -> AND .)
    STRING          reduce using rule 87 (operatorcomparator -> AND .)
    ID              reduce using rule 87 (operatorcomparator -> AND .)
    INCREMENT       reduce using rule 87 (operatorcomparator -> AND .)
    DECREMENT       reduce using rule 87 (operatorcomparator -> AND .)
    MINUS           reduce using rule 87 (operatorcomparator -> AND .)
    PLUS            reduce using rule 87 (operatorcomparator -> AND .)
    NOT             reduce using rule 87 (operatorcomparator -> AND .)


state 86

    (88) operatorcomparator -> OR .

    FLOAT_NUMBER    reduce using rule 88 (operatorcomparator -> OR .)
    INT_NUMBER      reduce using rule 88 (operatorcomparator -> OR .)
    STRING          reduce using rule 88 (operatorcomparator -> OR .)
    ID              reduce using rule 88 (operatorcomparator -> OR .)
    INCREMENT       reduce using rule 88 (operatorcomparator -> OR .)
    DECREMENT       reduce using rule 88 (operatorcomparator -> OR .)
    MINUS           reduce using rule 88 (operatorcomparator -> OR .)
    PLUS            reduce using rule 88 (operatorcomparator -> OR .)
    NOT             reduce using rule 88 (operatorcomparator -> OR .)


state 87

    (89) operatorcomparator -> BITWISE_AND .

    FLOAT_NUMBER    reduce using rule 89 (operatorcomparator -> BITWISE_AND .)
    INT_NUMBER      reduce using rule 89 (operatorcomparator -> BITWISE_AND .)
    STRING          reduce using rule 89 (operatorcomparator -> BITWISE_AND .)
    ID              reduce using rule 89 (operatorcomparator -> BITWISE_AND .)
    INCREMENT       reduce using rule 89 (operatorcomparator -> BITWISE_AND .)
    DECREMENT       reduce using rule 89 (operatorcomparator -> BITWISE_AND .)
    MINUS           reduce using rule 89 (operatorcomparator -> BITWISE_AND .)
    PLUS            reduce using rule 89 (operatorcomparator -> BITWISE_AND .)
    NOT             reduce using rule 89 (operatorcomparator -> BITWISE_AND .)


state 88

    (90) operatorcomparator -> BITWISE_OR .

    FLOAT_NUMBER    reduce using rule 90 (operatorcomparator -> BITWISE_OR .)
    INT_NUMBER      reduce using rule 90 (operatorcomparator -> BITWISE_OR .)
    STRING          reduce using rule 90 (operatorcomparator -> BITWISE_OR .)
    ID              reduce using rule 90 (operatorcomparator -> BITWISE_OR .)
    INCREMENT       reduce using rule 90 (operatorcomparator -> BITWISE_OR .)
    DECREMENT       reduce using rule 90 (operatorcomparator -> BITWISE_OR .)
    MINUS           reduce using rule 90 (operatorcomparator -> BITWISE_OR .)
    PLUS            reduce using rule 90 (operatorcomparator -> BITWISE_OR .)
    NOT             reduce using rule 90 (operatorcomparator -> BITWISE_OR .)


state 89

    (91) operatorcomparator -> BITWISE_XOR .

    FLOAT_NUMBER    reduce using rule 91 (operatorcomparator -> BITWISE_XOR .)
    INT_NUMBER      reduce using rule 91 (operatorcomparator -> BITWISE_XOR .)
    STRING          reduce using rule 91 (operatorcomparator -> BITWISE_XOR .)
    ID              reduce using rule 91 (operatorcomparator -> BITWISE_XOR .)
    INCREMENT       reduce using rule 91 (operatorcomparator -> BITWISE_XOR .)
    DECREMENT       reduce using rule 91 (operatorcomparator -> BITWISE_XOR .)
    MINUS           reduce using rule 91 (operatorcomparator -> BITWISE_XOR .)
    PLUS            reduce using rule 91 (operatorcomparator -> BITWISE_XOR .)
    NOT             reduce using rule 91 (operatorcomparator -> BITWISE_XOR .)


state 90

    (99) operatorbittobit -> URSHIFT .

    SEMICOLON       reduce using rule 99 (operatorbittobit -> URSHIFT .)
    TIMES           reduce using rule 99 (operatorbittobit -> URSHIFT .)
    DIVIDE          reduce using rule 99 (operatorbittobit -> URSHIFT .)
    MODULE          reduce using rule 99 (operatorbittobit -> URSHIFT .)
    PLUS            reduce using rule 99 (operatorbittobit -> URSHIFT .)
    MINUS           reduce using rule 99 (operatorbittobit -> URSHIFT .)
    LEQ             reduce using rule 99 (operatorbittobit -> URSHIFT .)
    GEQ             reduce using rule 99 (operatorbittobit -> URSHIFT .)
    LT              reduce using rule 99 (operatorbittobit -> URSHIFT .)
    GT              reduce using rule 99 (operatorbittobit -> URSHIFT .)
    NEQ             reduce using rule 99 (operatorbittobit -> URSHIFT .)
    EQ              reduce using rule 99 (operatorbittobit -> URSHIFT .)
    AND             reduce using rule 99 (operatorbittobit -> URSHIFT .)
    OR              reduce using rule 99 (operatorbittobit -> URSHIFT .)
    BITWISE_AND     reduce using rule 99 (operatorbittobit -> URSHIFT .)
    BITWISE_OR      reduce using rule 99 (operatorbittobit -> URSHIFT .)
    BITWISE_XOR     reduce using rule 99 (operatorbittobit -> URSHIFT .)
    URSHIFT         reduce using rule 99 (operatorbittobit -> URSHIFT .)
    LSHIFT          reduce using rule 99 (operatorbittobit -> URSHIFT .)
    RSHIFT          reduce using rule 99 (operatorbittobit -> URSHIFT .)
    RPAREN          reduce using rule 99 (operatorbittobit -> URSHIFT .)
    COMMA           reduce using rule 99 (operatorbittobit -> URSHIFT .)


state 91

    (100) operatorbittobit -> LSHIFT .

    SEMICOLON       reduce using rule 100 (operatorbittobit -> LSHIFT .)
    TIMES           reduce using rule 100 (operatorbittobit -> LSHIFT .)
    DIVIDE          reduce using rule 100 (operatorbittobit -> LSHIFT .)
    MODULE          reduce using rule 100 (operatorbittobit -> LSHIFT .)
    PLUS            reduce using rule 100 (operatorbittobit -> LSHIFT .)
    MINUS           reduce using rule 100 (operatorbittobit -> LSHIFT .)
    LEQ             reduce using rule 100 (operatorbittobit -> LSHIFT .)
    GEQ             reduce using rule 100 (operatorbittobit -> LSHIFT .)
    LT              reduce using rule 100 (operatorbittobit -> LSHIFT .)
    GT              reduce using rule 100 (operatorbittobit -> LSHIFT .)
    NEQ             reduce using rule 100 (operatorbittobit -> LSHIFT .)
    EQ              reduce using rule 100 (operatorbittobit -> LSHIFT .)
    AND             reduce using rule 100 (operatorbittobit -> LSHIFT .)
    OR              reduce using rule 100 (operatorbittobit -> LSHIFT .)
    BITWISE_AND     reduce using rule 100 (operatorbittobit -> LSHIFT .)
    BITWISE_OR      reduce using rule 100 (operatorbittobit -> LSHIFT .)
    BITWISE_XOR     reduce using rule 100 (operatorbittobit -> LSHIFT .)
    URSHIFT         reduce using rule 100 (operatorbittobit -> LSHIFT .)
    LSHIFT          reduce using rule 100 (operatorbittobit -> LSHIFT .)
    RSHIFT          reduce using rule 100 (operatorbittobit -> LSHIFT .)
    RPAREN          reduce using rule 100 (operatorbittobit -> LSHIFT .)
    COMMA           reduce using rule 100 (operatorbittobit -> LSHIFT .)


state 92

    (101) operatorbittobit -> RSHIFT .

    SEMICOLON       reduce using rule 101 (operatorbittobit -> RSHIFT .)
    TIMES           reduce using rule 101 (operatorbittobit -> RSHIFT .)
    DIVIDE          reduce using rule 101 (operatorbittobit -> RSHIFT .)
    MODULE          reduce using rule 101 (operatorbittobit -> RSHIFT .)
    PLUS            reduce using rule 101 (operatorbittobit -> RSHIFT .)
    MINUS           reduce using rule 101 (operatorbittobit -> RSHIFT .)
    LEQ             reduce using rule 101 (operatorbittobit -> RSHIFT .)
    GEQ             reduce using rule 101 (operatorbittobit -> RSHIFT .)
    LT              reduce using rule 101 (operatorbittobit -> RSHIFT .)
    GT              reduce using rule 101 (operatorbittobit -> RSHIFT .)
    NEQ             reduce using rule 101 (operatorbittobit -> RSHIFT .)
    EQ              reduce using rule 101 (operatorbittobit -> RSHIFT .)
    AND             reduce using rule 101 (operatorbittobit -> RSHIFT .)
    OR              reduce using rule 101 (operatorbittobit -> RSHIFT .)
    BITWISE_AND     reduce using rule 101 (operatorbittobit -> RSHIFT .)
    BITWISE_OR      reduce using rule 101 (operatorbittobit -> RSHIFT .)
    BITWISE_XOR     reduce using rule 101 (operatorbittobit -> RSHIFT .)
    URSHIFT         reduce using rule 101 (operatorbittobit -> RSHIFT .)
    LSHIFT          reduce using rule 101 (operatorbittobit -> RSHIFT .)
    RSHIFT          reduce using rule 101 (operatorbittobit -> RSHIFT .)
    RPAREN          reduce using rule 101 (operatorbittobit -> RSHIFT .)
    COMMA           reduce using rule 101 (operatorbittobit -> RSHIFT .)


state 93

    (31) stm -> WHILE LPAREN . expression RPAREN bodyorstm
    (39) expression -> . operator
    (40) expression -> . call
    (41) expression -> . FLOAT_NUMBER
    (42) expression -> . INT_NUMBER
    (43) expression -> . STRING
    (44) expression -> . ID
    (45) operator -> . expression arithmetic expression
    (46) operator -> . ID assign expression
    (47) operator -> . expression operatorcomparator expression
    (48) operator -> . unaryoperatorprefx ID
    (49) operator -> . ID unaryoperatorsufx
    (50) operator -> . expression operatorbittobit
    (102) call -> . ID LPAREN params RPAREN
    (103) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 55
    INT_NUMBER      shift and go to state 56
    STRING          shift and go to state 57
    ID              shift and go to state 58
    INCREMENT       shift and go to state 60
    DECREMENT       shift and go to state 61
    MINUS           shift and go to state 62
    PLUS            shift and go to state 63
    NOT             shift and go to state 64

    expression                     shift and go to state 121
    operator                       shift and go to state 53
    call                           shift and go to state 54
    unaryoperatorprefx             shift and go to state 59

state 94

    (32) stm -> DO bodyorstm . WHILE LPAREN expression RPAREN SEMICOLON

    WHILE           shift and go to state 122


state 95

    (38) bodyorstm -> body .

    WHILE           reduce using rule 38 (bodyorstm -> body .)
    DO              reduce using rule 38 (bodyorstm -> body .)
    FOR             reduce using rule 38 (bodyorstm -> body .)
    IF              reduce using rule 38 (bodyorstm -> body .)
    SEMICOLON       reduce using rule 38 (bodyorstm -> body .)
    FLOAT_NUMBER    reduce using rule 38 (bodyorstm -> body .)
    INT_NUMBER      reduce using rule 38 (bodyorstm -> body .)
    STRING          reduce using rule 38 (bodyorstm -> body .)
    ID              reduce using rule 38 (bodyorstm -> body .)
    INCREMENT       reduce using rule 38 (bodyorstm -> body .)
    DECREMENT       reduce using rule 38 (bodyorstm -> body .)
    MINUS           reduce using rule 38 (bodyorstm -> body .)
    PLUS            reduce using rule 38 (bodyorstm -> body .)
    NOT             reduce using rule 38 (bodyorstm -> body .)
    RCHAV           reduce using rule 38 (bodyorstm -> body .)
    ELSE            reduce using rule 38 (bodyorstm -> body .)


state 96

    (33) stm -> FOR LPAREN . expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm
    (39) expression -> . operator
    (40) expression -> . call
    (41) expression -> . FLOAT_NUMBER
    (42) expression -> . INT_NUMBER
    (43) expression -> . STRING
    (44) expression -> . ID
    (45) operator -> . expression arithmetic expression
    (46) operator -> . ID assign expression
    (47) operator -> . expression operatorcomparator expression
    (48) operator -> . unaryoperatorprefx ID
    (49) operator -> . ID unaryoperatorsufx
    (50) operator -> . expression operatorbittobit
    (102) call -> . ID LPAREN params RPAREN
    (103) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 55
    INT_NUMBER      shift and go to state 56
    STRING          shift and go to state 57
    ID              shift and go to state 58
    INCREMENT       shift and go to state 60
    DECREMENT       shift and go to state 61
    MINUS           shift and go to state 62
    PLUS            shift and go to state 63
    NOT             shift and go to state 64

    expression                     shift and go to state 123
    operator                       shift and go to state 53
    call                           shift and go to state 54
    unaryoperatorprefx             shift and go to state 59

state 97

    (34) stm -> IF LPAREN . expression RPAREN bodyorstm
    (35) stm -> IF LPAREN . expression RPAREN bodyorstm ELSE bodyorstm
    (36) stm -> IF LPAREN . expression RPAREN bodyorstm ELSE IF bodyorstm
    (39) expression -> . operator
    (40) expression -> . call
    (41) expression -> . FLOAT_NUMBER
    (42) expression -> . INT_NUMBER
    (43) expression -> . STRING
    (44) expression -> . ID
    (45) operator -> . expression arithmetic expression
    (46) operator -> . ID assign expression
    (47) operator -> . expression operatorcomparator expression
    (48) operator -> . unaryoperatorprefx ID
    (49) operator -> . ID unaryoperatorsufx
    (50) operator -> . expression operatorbittobit
    (102) call -> . ID LPAREN params RPAREN
    (103) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 55
    INT_NUMBER      shift and go to state 56
    STRING          shift and go to state 57
    ID              shift and go to state 58
    INCREMENT       shift and go to state 60
    DECREMENT       shift and go to state 61
    MINUS           shift and go to state 62
    PLUS            shift and go to state 63
    NOT             shift and go to state 64

    expression                     shift and go to state 124
    operator                       shift and go to state 53
    call                           shift and go to state 54
    unaryoperatorprefx             shift and go to state 59

state 98

    (46) operator -> ID assign . expression
    (39) expression -> . operator
    (40) expression -> . call
    (41) expression -> . FLOAT_NUMBER
    (42) expression -> . INT_NUMBER
    (43) expression -> . STRING
    (44) expression -> . ID
    (45) operator -> . expression arithmetic expression
    (46) operator -> . ID assign expression
    (47) operator -> . expression operatorcomparator expression
    (48) operator -> . unaryoperatorprefx ID
    (49) operator -> . ID unaryoperatorsufx
    (50) operator -> . expression operatorbittobit
    (102) call -> . ID LPAREN params RPAREN
    (103) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 55
    INT_NUMBER      shift and go to state 56
    STRING          shift and go to state 57
    ID              shift and go to state 58
    INCREMENT       shift and go to state 60
    DECREMENT       shift and go to state 61
    MINUS           shift and go to state 62
    PLUS            shift and go to state 63
    NOT             shift and go to state 64

    expression                     shift and go to state 125
    operator                       shift and go to state 53
    call                           shift and go to state 54
    unaryoperatorprefx             shift and go to state 59

state 99

    (49) operator -> ID unaryoperatorsufx .

    SEMICOLON       reduce using rule 49 (operator -> ID unaryoperatorsufx .)
    TIMES           reduce using rule 49 (operator -> ID unaryoperatorsufx .)
    DIVIDE          reduce using rule 49 (operator -> ID unaryoperatorsufx .)
    MODULE          reduce using rule 49 (operator -> ID unaryoperatorsufx .)
    PLUS            reduce using rule 49 (operator -> ID unaryoperatorsufx .)
    MINUS           reduce using rule 49 (operator -> ID unaryoperatorsufx .)
    LEQ             reduce using rule 49 (operator -> ID unaryoperatorsufx .)
    GEQ             reduce using rule 49 (operator -> ID unaryoperatorsufx .)
    LT              reduce using rule 49 (operator -> ID unaryoperatorsufx .)
    GT              reduce using rule 49 (operator -> ID unaryoperatorsufx .)
    NEQ             reduce using rule 49 (operator -> ID unaryoperatorsufx .)
    EQ              reduce using rule 49 (operator -> ID unaryoperatorsufx .)
    AND             reduce using rule 49 (operator -> ID unaryoperatorsufx .)
    OR              reduce using rule 49 (operator -> ID unaryoperatorsufx .)
    BITWISE_AND     reduce using rule 49 (operator -> ID unaryoperatorsufx .)
    BITWISE_OR      reduce using rule 49 (operator -> ID unaryoperatorsufx .)
    BITWISE_XOR     reduce using rule 49 (operator -> ID unaryoperatorsufx .)
    URSHIFT         reduce using rule 49 (operator -> ID unaryoperatorsufx .)
    LSHIFT          reduce using rule 49 (operator -> ID unaryoperatorsufx .)
    RSHIFT          reduce using rule 49 (operator -> ID unaryoperatorsufx .)
    RPAREN          reduce using rule 49 (operator -> ID unaryoperatorsufx .)
    COMMA           reduce using rule 49 (operator -> ID unaryoperatorsufx .)


state 100

    (102) call -> ID LPAREN . params RPAREN
    (103) call -> ID LPAREN . RPAREN
    (104) params -> . expression COMMA params
    (105) params -> . expression
    (39) expression -> . operator
    (40) expression -> . call
    (41) expression -> . FLOAT_NUMBER
    (42) expression -> . INT_NUMBER
    (43) expression -> . STRING
    (44) expression -> . ID
    (45) operator -> . expression arithmetic expression
    (46) operator -> . ID assign expression
    (47) operator -> . expression operatorcomparator expression
    (48) operator -> . unaryoperatorprefx ID
    (49) operator -> . ID unaryoperatorsufx
    (50) operator -> . expression operatorbittobit
    (102) call -> . ID LPAREN params RPAREN
    (103) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    RPAREN          shift and go to state 127
    FLOAT_NUMBER    shift and go to state 55
    INT_NUMBER      shift and go to state 56
    STRING          shift and go to state 57
    ID              shift and go to state 58
    INCREMENT       shift and go to state 60
    DECREMENT       shift and go to state 61
    MINUS           shift and go to state 62
    PLUS            shift and go to state 63
    NOT             shift and go to state 64

    params                         shift and go to state 126
    expression                     shift and go to state 128
    operator                       shift and go to state 53
    call                           shift and go to state 54
    unaryoperatorprefx             shift and go to state 59

state 101

    (69) assign -> EQUAL .

    FLOAT_NUMBER    reduce using rule 69 (assign -> EQUAL .)
    INT_NUMBER      reduce using rule 69 (assign -> EQUAL .)
    STRING          reduce using rule 69 (assign -> EQUAL .)
    ID              reduce using rule 69 (assign -> EQUAL .)
    INCREMENT       reduce using rule 69 (assign -> EQUAL .)
    DECREMENT       reduce using rule 69 (assign -> EQUAL .)
    MINUS           reduce using rule 69 (assign -> EQUAL .)
    PLUS            reduce using rule 69 (assign -> EQUAL .)
    NOT             reduce using rule 69 (assign -> EQUAL .)


state 102

    (70) assign -> MINUS_EQ .

    FLOAT_NUMBER    reduce using rule 70 (assign -> MINUS_EQ .)
    INT_NUMBER      reduce using rule 70 (assign -> MINUS_EQ .)
    STRING          reduce using rule 70 (assign -> MINUS_EQ .)
    ID              reduce using rule 70 (assign -> MINUS_EQ .)
    INCREMENT       reduce using rule 70 (assign -> MINUS_EQ .)
    DECREMENT       reduce using rule 70 (assign -> MINUS_EQ .)
    MINUS           reduce using rule 70 (assign -> MINUS_EQ .)
    PLUS            reduce using rule 70 (assign -> MINUS_EQ .)
    NOT             reduce using rule 70 (assign -> MINUS_EQ .)


state 103

    (71) assign -> TIMES_EQ .

    FLOAT_NUMBER    reduce using rule 71 (assign -> TIMES_EQ .)
    INT_NUMBER      reduce using rule 71 (assign -> TIMES_EQ .)
    STRING          reduce using rule 71 (assign -> TIMES_EQ .)
    ID              reduce using rule 71 (assign -> TIMES_EQ .)
    INCREMENT       reduce using rule 71 (assign -> TIMES_EQ .)
    DECREMENT       reduce using rule 71 (assign -> TIMES_EQ .)
    MINUS           reduce using rule 71 (assign -> TIMES_EQ .)
    PLUS            reduce using rule 71 (assign -> TIMES_EQ .)
    NOT             reduce using rule 71 (assign -> TIMES_EQ .)


state 104

    (72) assign -> PLUS_EQ .

    FLOAT_NUMBER    reduce using rule 72 (assign -> PLUS_EQ .)
    INT_NUMBER      reduce using rule 72 (assign -> PLUS_EQ .)
    STRING          reduce using rule 72 (assign -> PLUS_EQ .)
    ID              reduce using rule 72 (assign -> PLUS_EQ .)
    INCREMENT       reduce using rule 72 (assign -> PLUS_EQ .)
    DECREMENT       reduce using rule 72 (assign -> PLUS_EQ .)
    MINUS           reduce using rule 72 (assign -> PLUS_EQ .)
    PLUS            reduce using rule 72 (assign -> PLUS_EQ .)
    NOT             reduce using rule 72 (assign -> PLUS_EQ .)


state 105

    (73) assign -> DIVIDE_EQ .

    FLOAT_NUMBER    reduce using rule 73 (assign -> DIVIDE_EQ .)
    INT_NUMBER      reduce using rule 73 (assign -> DIVIDE_EQ .)
    STRING          reduce using rule 73 (assign -> DIVIDE_EQ .)
    ID              reduce using rule 73 (assign -> DIVIDE_EQ .)
    INCREMENT       reduce using rule 73 (assign -> DIVIDE_EQ .)
    DECREMENT       reduce using rule 73 (assign -> DIVIDE_EQ .)
    MINUS           reduce using rule 73 (assign -> DIVIDE_EQ .)
    PLUS            reduce using rule 73 (assign -> DIVIDE_EQ .)
    NOT             reduce using rule 73 (assign -> DIVIDE_EQ .)


state 106

    (74) assign -> MOD_EQ .

    FLOAT_NUMBER    reduce using rule 74 (assign -> MOD_EQ .)
    INT_NUMBER      reduce using rule 74 (assign -> MOD_EQ .)
    STRING          reduce using rule 74 (assign -> MOD_EQ .)
    ID              reduce using rule 74 (assign -> MOD_EQ .)
    INCREMENT       reduce using rule 74 (assign -> MOD_EQ .)
    DECREMENT       reduce using rule 74 (assign -> MOD_EQ .)
    MINUS           reduce using rule 74 (assign -> MOD_EQ .)
    PLUS            reduce using rule 74 (assign -> MOD_EQ .)
    NOT             reduce using rule 74 (assign -> MOD_EQ .)


state 107

    (75) assign -> BITWISE_AND_EQ .

    FLOAT_NUMBER    reduce using rule 75 (assign -> BITWISE_AND_EQ .)
    INT_NUMBER      reduce using rule 75 (assign -> BITWISE_AND_EQ .)
    STRING          reduce using rule 75 (assign -> BITWISE_AND_EQ .)
    ID              reduce using rule 75 (assign -> BITWISE_AND_EQ .)
    INCREMENT       reduce using rule 75 (assign -> BITWISE_AND_EQ .)
    DECREMENT       reduce using rule 75 (assign -> BITWISE_AND_EQ .)
    MINUS           reduce using rule 75 (assign -> BITWISE_AND_EQ .)
    PLUS            reduce using rule 75 (assign -> BITWISE_AND_EQ .)
    NOT             reduce using rule 75 (assign -> BITWISE_AND_EQ .)


state 108

    (76) assign -> BITWISE_OR_EQ .

    FLOAT_NUMBER    reduce using rule 76 (assign -> BITWISE_OR_EQ .)
    INT_NUMBER      reduce using rule 76 (assign -> BITWISE_OR_EQ .)
    STRING          reduce using rule 76 (assign -> BITWISE_OR_EQ .)
    ID              reduce using rule 76 (assign -> BITWISE_OR_EQ .)
    INCREMENT       reduce using rule 76 (assign -> BITWISE_OR_EQ .)
    DECREMENT       reduce using rule 76 (assign -> BITWISE_OR_EQ .)
    MINUS           reduce using rule 76 (assign -> BITWISE_OR_EQ .)
    PLUS            reduce using rule 76 (assign -> BITWISE_OR_EQ .)
    NOT             reduce using rule 76 (assign -> BITWISE_OR_EQ .)


state 109

    (77) assign -> BITWISE_XOR_EQ .

    FLOAT_NUMBER    reduce using rule 77 (assign -> BITWISE_XOR_EQ .)
    INT_NUMBER      reduce using rule 77 (assign -> BITWISE_XOR_EQ .)
    STRING          reduce using rule 77 (assign -> BITWISE_XOR_EQ .)
    ID              reduce using rule 77 (assign -> BITWISE_XOR_EQ .)
    INCREMENT       reduce using rule 77 (assign -> BITWISE_XOR_EQ .)
    DECREMENT       reduce using rule 77 (assign -> BITWISE_XOR_EQ .)
    MINUS           reduce using rule 77 (assign -> BITWISE_XOR_EQ .)
    PLUS            reduce using rule 77 (assign -> BITWISE_XOR_EQ .)
    NOT             reduce using rule 77 (assign -> BITWISE_XOR_EQ .)


state 110

    (78) assign -> URSHIFT_EQ .

    FLOAT_NUMBER    reduce using rule 78 (assign -> URSHIFT_EQ .)
    INT_NUMBER      reduce using rule 78 (assign -> URSHIFT_EQ .)
    STRING          reduce using rule 78 (assign -> URSHIFT_EQ .)
    ID              reduce using rule 78 (assign -> URSHIFT_EQ .)
    INCREMENT       reduce using rule 78 (assign -> URSHIFT_EQ .)
    DECREMENT       reduce using rule 78 (assign -> URSHIFT_EQ .)
    MINUS           reduce using rule 78 (assign -> URSHIFT_EQ .)
    PLUS            reduce using rule 78 (assign -> URSHIFT_EQ .)
    NOT             reduce using rule 78 (assign -> URSHIFT_EQ .)


state 111

    (79) assign -> LSHIFT_EQ .

    FLOAT_NUMBER    reduce using rule 79 (assign -> LSHIFT_EQ .)
    INT_NUMBER      reduce using rule 79 (assign -> LSHIFT_EQ .)
    STRING          reduce using rule 79 (assign -> LSHIFT_EQ .)
    ID              reduce using rule 79 (assign -> LSHIFT_EQ .)
    INCREMENT       reduce using rule 79 (assign -> LSHIFT_EQ .)
    DECREMENT       reduce using rule 79 (assign -> LSHIFT_EQ .)
    MINUS           reduce using rule 79 (assign -> LSHIFT_EQ .)
    PLUS            reduce using rule 79 (assign -> LSHIFT_EQ .)
    NOT             reduce using rule 79 (assign -> LSHIFT_EQ .)


state 112

    (80) assign -> RSHIFT_EQ .

    FLOAT_NUMBER    reduce using rule 80 (assign -> RSHIFT_EQ .)
    INT_NUMBER      reduce using rule 80 (assign -> RSHIFT_EQ .)
    STRING          reduce using rule 80 (assign -> RSHIFT_EQ .)
    ID              reduce using rule 80 (assign -> RSHIFT_EQ .)
    INCREMENT       reduce using rule 80 (assign -> RSHIFT_EQ .)
    DECREMENT       reduce using rule 80 (assign -> RSHIFT_EQ .)
    MINUS           reduce using rule 80 (assign -> RSHIFT_EQ .)
    PLUS            reduce using rule 80 (assign -> RSHIFT_EQ .)
    NOT             reduce using rule 80 (assign -> RSHIFT_EQ .)


state 113

    (97) unaryoperatorsufx -> INCREMENT .

    SEMICOLON       reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    TIMES           reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    DIVIDE          reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    MODULE          reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    PLUS            reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    MINUS           reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    LEQ             reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    GEQ             reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    LT              reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    GT              reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    NEQ             reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    EQ              reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    AND             reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    OR              reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    BITWISE_AND     reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    BITWISE_OR      reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    BITWISE_XOR     reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    URSHIFT         reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    LSHIFT          reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    RSHIFT          reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    RPAREN          reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    COMMA           reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)


state 114

    (98) unaryoperatorsufx -> DECREMENT .

    SEMICOLON       reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    TIMES           reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    DIVIDE          reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    MODULE          reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    PLUS            reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    MINUS           reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    LEQ             reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    GEQ             reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    LT              reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    GT              reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    NEQ             reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    EQ              reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    AND             reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    OR              reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    BITWISE_AND     reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    BITWISE_OR      reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    BITWISE_XOR     reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    URSHIFT         reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    LSHIFT          reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    RSHIFT          reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    RPAREN          reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    COMMA           reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)


state 115

    (48) operator -> unaryoperatorprefx ID .

    SEMICOLON       reduce using rule 48 (operator -> unaryoperatorprefx ID .)
    TIMES           reduce using rule 48 (operator -> unaryoperatorprefx ID .)
    DIVIDE          reduce using rule 48 (operator -> unaryoperatorprefx ID .)
    MODULE          reduce using rule 48 (operator -> unaryoperatorprefx ID .)
    PLUS            reduce using rule 48 (operator -> unaryoperatorprefx ID .)
    MINUS           reduce using rule 48 (operator -> unaryoperatorprefx ID .)
    LEQ             reduce using rule 48 (operator -> unaryoperatorprefx ID .)
    GEQ             reduce using rule 48 (operator -> unaryoperatorprefx ID .)
    LT              reduce using rule 48 (operator -> unaryoperatorprefx ID .)
    GT              reduce using rule 48 (operator -> unaryoperatorprefx ID .)
    NEQ             reduce using rule 48 (operator -> unaryoperatorprefx ID .)
    EQ              reduce using rule 48 (operator -> unaryoperatorprefx ID .)
    AND             reduce using rule 48 (operator -> unaryoperatorprefx ID .)
    OR              reduce using rule 48 (operator -> unaryoperatorprefx ID .)
    BITWISE_AND     reduce using rule 48 (operator -> unaryoperatorprefx ID .)
    BITWISE_OR      reduce using rule 48 (operator -> unaryoperatorprefx ID .)
    BITWISE_XOR     reduce using rule 48 (operator -> unaryoperatorprefx ID .)
    URSHIFT         reduce using rule 48 (operator -> unaryoperatorprefx ID .)
    LSHIFT          reduce using rule 48 (operator -> unaryoperatorprefx ID .)
    RSHIFT          reduce using rule 48 (operator -> unaryoperatorprefx ID .)
    RPAREN          reduce using rule 48 (operator -> unaryoperatorprefx ID .)
    COMMA           reduce using rule 48 (operator -> unaryoperatorprefx ID .)


state 116

    (17) atribute -> visibility atributemodifier type ID SEMICOLON .

    PUBLIC          reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    PRIVATE         reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    PROTECTED       reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    STATIC          reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    FINAL           reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_INT        reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_FLOAT      reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_BYTE       reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_CHAR       reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_STRING     reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_LONG       reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_VOID       reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    RCHAV           reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)


state 117

    (18) atribute -> visibility atributemodifier type ID EQUAL . ID SEMICOLON
    (19) atribute -> visibility atributemodifier type ID EQUAL . expression SEMICOLON
    (39) expression -> . operator
    (40) expression -> . call
    (41) expression -> . FLOAT_NUMBER
    (42) expression -> . INT_NUMBER
    (43) expression -> . STRING
    (44) expression -> . ID
    (45) operator -> . expression arithmetic expression
    (46) operator -> . ID assign expression
    (47) operator -> . expression operatorcomparator expression
    (48) operator -> . unaryoperatorprefx ID
    (49) operator -> . ID unaryoperatorsufx
    (50) operator -> . expression operatorbittobit
    (102) call -> . ID LPAREN params RPAREN
    (103) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    ID              shift and go to state 129
    FLOAT_NUMBER    shift and go to state 55
    INT_NUMBER      shift and go to state 56
    STRING          shift and go to state 57
    INCREMENT       shift and go to state 60
    DECREMENT       shift and go to state 61
    MINUS           shift and go to state 62
    PLUS            shift and go to state 63
    NOT             shift and go to state 64

    expression                     shift and go to state 130
    operator                       shift and go to state 53
    call                           shift and go to state 54
    unaryoperatorprefx             shift and go to state 59

state 118

    (24) signature -> visibility atributemodifier type ID LPAREN . sigparams RPAREN
    (25) sigparams -> . ID brackets_expression
    (26) sigparams -> . ID brackets_expression COMMA sigparams

    ID              shift and go to state 131

    sigparams                      shift and go to state 132

state 119

    (45) operator -> expression arithmetic expression .
    (45) operator -> expression . arithmetic expression
    (47) operator -> expression . operatorcomparator expression
    (50) operator -> expression . operatorbittobit
    (64) arithmetic -> . TIMES
    (65) arithmetic -> . DIVIDE
    (66) arithmetic -> . MODULE
    (67) arithmetic -> . PLUS
    (68) arithmetic -> . MINUS
    (81) operatorcomparator -> . LEQ
    (82) operatorcomparator -> . GEQ
    (83) operatorcomparator -> . LT
    (84) operatorcomparator -> . GT
    (85) operatorcomparator -> . NEQ
    (86) operatorcomparator -> . EQ
    (87) operatorcomparator -> . AND
    (88) operatorcomparator -> . OR
    (89) operatorcomparator -> . BITWISE_AND
    (90) operatorcomparator -> . BITWISE_OR
    (91) operatorcomparator -> . BITWISE_XOR
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for BITWISE_AND resolved as shift
  ! shift/reduce conflict for BITWISE_OR resolved as shift
  ! shift/reduce conflict for BITWISE_XOR resolved as shift
  ! shift/reduce conflict for URSHIFT resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
    SEMICOLON       reduce using rule 45 (operator -> expression arithmetic expression .)
    RPAREN          reduce using rule 45 (operator -> expression arithmetic expression .)
    COMMA           reduce using rule 45 (operator -> expression arithmetic expression .)
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75
    MODULE          shift and go to state 76
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78
    LEQ             shift and go to state 79
    GEQ             shift and go to state 80
    LT              shift and go to state 81
    GT              shift and go to state 82
    NEQ             shift and go to state 83
    EQ              shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86
    BITWISE_AND     shift and go to state 87
    BITWISE_OR      shift and go to state 88
    BITWISE_XOR     shift and go to state 89
    URSHIFT         shift and go to state 90
    LSHIFT          shift and go to state 91
    RSHIFT          shift and go to state 92

  ! TIMES           [ reduce using rule 45 (operator -> expression arithmetic expression .) ]
  ! DIVIDE          [ reduce using rule 45 (operator -> expression arithmetic expression .) ]
  ! MODULE          [ reduce using rule 45 (operator -> expression arithmetic expression .) ]
  ! PLUS            [ reduce using rule 45 (operator -> expression arithmetic expression .) ]
  ! MINUS           [ reduce using rule 45 (operator -> expression arithmetic expression .) ]
  ! LEQ             [ reduce using rule 45 (operator -> expression arithmetic expression .) ]
  ! GEQ             [ reduce using rule 45 (operator -> expression arithmetic expression .) ]
  ! LT              [ reduce using rule 45 (operator -> expression arithmetic expression .) ]
  ! GT              [ reduce using rule 45 (operator -> expression arithmetic expression .) ]
  ! NEQ             [ reduce using rule 45 (operator -> expression arithmetic expression .) ]
  ! EQ              [ reduce using rule 45 (operator -> expression arithmetic expression .) ]
  ! AND             [ reduce using rule 45 (operator -> expression arithmetic expression .) ]
  ! OR              [ reduce using rule 45 (operator -> expression arithmetic expression .) ]
  ! BITWISE_AND     [ reduce using rule 45 (operator -> expression arithmetic expression .) ]
  ! BITWISE_OR      [ reduce using rule 45 (operator -> expression arithmetic expression .) ]
  ! BITWISE_XOR     [ reduce using rule 45 (operator -> expression arithmetic expression .) ]
  ! URSHIFT         [ reduce using rule 45 (operator -> expression arithmetic expression .) ]
  ! LSHIFT          [ reduce using rule 45 (operator -> expression arithmetic expression .) ]
  ! RSHIFT          [ reduce using rule 45 (operator -> expression arithmetic expression .) ]

    arithmetic                     shift and go to state 71
    operatorcomparator             shift and go to state 72
    operatorbittobit               shift and go to state 73

state 120

    (47) operator -> expression operatorcomparator expression .
    (45) operator -> expression . arithmetic expression
    (47) operator -> expression . operatorcomparator expression
    (50) operator -> expression . operatorbittobit
    (64) arithmetic -> . TIMES
    (65) arithmetic -> . DIVIDE
    (66) arithmetic -> . MODULE
    (67) arithmetic -> . PLUS
    (68) arithmetic -> . MINUS
    (81) operatorcomparator -> . LEQ
    (82) operatorcomparator -> . GEQ
    (83) operatorcomparator -> . LT
    (84) operatorcomparator -> . GT
    (85) operatorcomparator -> . NEQ
    (86) operatorcomparator -> . EQ
    (87) operatorcomparator -> . AND
    (88) operatorcomparator -> . OR
    (89) operatorcomparator -> . BITWISE_AND
    (90) operatorcomparator -> . BITWISE_OR
    (91) operatorcomparator -> . BITWISE_XOR
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for BITWISE_AND resolved as shift
  ! shift/reduce conflict for BITWISE_OR resolved as shift
  ! shift/reduce conflict for BITWISE_XOR resolved as shift
  ! shift/reduce conflict for URSHIFT resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
    SEMICOLON       reduce using rule 47 (operator -> expression operatorcomparator expression .)
    RPAREN          reduce using rule 47 (operator -> expression operatorcomparator expression .)
    COMMA           reduce using rule 47 (operator -> expression operatorcomparator expression .)
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75
    MODULE          shift and go to state 76
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78
    LEQ             shift and go to state 79
    GEQ             shift and go to state 80
    LT              shift and go to state 81
    GT              shift and go to state 82
    NEQ             shift and go to state 83
    EQ              shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86
    BITWISE_AND     shift and go to state 87
    BITWISE_OR      shift and go to state 88
    BITWISE_XOR     shift and go to state 89
    URSHIFT         shift and go to state 90
    LSHIFT          shift and go to state 91
    RSHIFT          shift and go to state 92

  ! TIMES           [ reduce using rule 47 (operator -> expression operatorcomparator expression .) ]
  ! DIVIDE          [ reduce using rule 47 (operator -> expression operatorcomparator expression .) ]
  ! MODULE          [ reduce using rule 47 (operator -> expression operatorcomparator expression .) ]
  ! PLUS            [ reduce using rule 47 (operator -> expression operatorcomparator expression .) ]
  ! MINUS           [ reduce using rule 47 (operator -> expression operatorcomparator expression .) ]
  ! LEQ             [ reduce using rule 47 (operator -> expression operatorcomparator expression .) ]
  ! GEQ             [ reduce using rule 47 (operator -> expression operatorcomparator expression .) ]
  ! LT              [ reduce using rule 47 (operator -> expression operatorcomparator expression .) ]
  ! GT              [ reduce using rule 47 (operator -> expression operatorcomparator expression .) ]
  ! NEQ             [ reduce using rule 47 (operator -> expression operatorcomparator expression .) ]
  ! EQ              [ reduce using rule 47 (operator -> expression operatorcomparator expression .) ]
  ! AND             [ reduce using rule 47 (operator -> expression operatorcomparator expression .) ]
  ! OR              [ reduce using rule 47 (operator -> expression operatorcomparator expression .) ]
  ! BITWISE_AND     [ reduce using rule 47 (operator -> expression operatorcomparator expression .) ]
  ! BITWISE_OR      [ reduce using rule 47 (operator -> expression operatorcomparator expression .) ]
  ! BITWISE_XOR     [ reduce using rule 47 (operator -> expression operatorcomparator expression .) ]
  ! URSHIFT         [ reduce using rule 47 (operator -> expression operatorcomparator expression .) ]
  ! LSHIFT          [ reduce using rule 47 (operator -> expression operatorcomparator expression .) ]
  ! RSHIFT          [ reduce using rule 47 (operator -> expression operatorcomparator expression .) ]

    operatorcomparator             shift and go to state 72
    arithmetic                     shift and go to state 71
    operatorbittobit               shift and go to state 73

state 121

    (31) stm -> WHILE LPAREN expression . RPAREN bodyorstm
    (45) operator -> expression . arithmetic expression
    (47) operator -> expression . operatorcomparator expression
    (50) operator -> expression . operatorbittobit
    (64) arithmetic -> . TIMES
    (65) arithmetic -> . DIVIDE
    (66) arithmetic -> . MODULE
    (67) arithmetic -> . PLUS
    (68) arithmetic -> . MINUS
    (81) operatorcomparator -> . LEQ
    (82) operatorcomparator -> . GEQ
    (83) operatorcomparator -> . LT
    (84) operatorcomparator -> . GT
    (85) operatorcomparator -> . NEQ
    (86) operatorcomparator -> . EQ
    (87) operatorcomparator -> . AND
    (88) operatorcomparator -> . OR
    (89) operatorcomparator -> . BITWISE_AND
    (90) operatorcomparator -> . BITWISE_OR
    (91) operatorcomparator -> . BITWISE_XOR
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    RPAREN          shift and go to state 133
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75
    MODULE          shift and go to state 76
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78
    LEQ             shift and go to state 79
    GEQ             shift and go to state 80
    LT              shift and go to state 81
    GT              shift and go to state 82
    NEQ             shift and go to state 83
    EQ              shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86
    BITWISE_AND     shift and go to state 87
    BITWISE_OR      shift and go to state 88
    BITWISE_XOR     shift and go to state 89
    URSHIFT         shift and go to state 90
    LSHIFT          shift and go to state 91
    RSHIFT          shift and go to state 92

    arithmetic                     shift and go to state 71
    operatorcomparator             shift and go to state 72
    operatorbittobit               shift and go to state 73

state 122

    (32) stm -> DO bodyorstm WHILE . LPAREN expression RPAREN SEMICOLON

    LPAREN          shift and go to state 134


state 123

    (33) stm -> FOR LPAREN expression . SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm
    (45) operator -> expression . arithmetic expression
    (47) operator -> expression . operatorcomparator expression
    (50) operator -> expression . operatorbittobit
    (64) arithmetic -> . TIMES
    (65) arithmetic -> . DIVIDE
    (66) arithmetic -> . MODULE
    (67) arithmetic -> . PLUS
    (68) arithmetic -> . MINUS
    (81) operatorcomparator -> . LEQ
    (82) operatorcomparator -> . GEQ
    (83) operatorcomparator -> . LT
    (84) operatorcomparator -> . GT
    (85) operatorcomparator -> . NEQ
    (86) operatorcomparator -> . EQ
    (87) operatorcomparator -> . AND
    (88) operatorcomparator -> . OR
    (89) operatorcomparator -> . BITWISE_AND
    (90) operatorcomparator -> . BITWISE_OR
    (91) operatorcomparator -> . BITWISE_XOR
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       shift and go to state 135
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75
    MODULE          shift and go to state 76
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78
    LEQ             shift and go to state 79
    GEQ             shift and go to state 80
    LT              shift and go to state 81
    GT              shift and go to state 82
    NEQ             shift and go to state 83
    EQ              shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86
    BITWISE_AND     shift and go to state 87
    BITWISE_OR      shift and go to state 88
    BITWISE_XOR     shift and go to state 89
    URSHIFT         shift and go to state 90
    LSHIFT          shift and go to state 91
    RSHIFT          shift and go to state 92

    arithmetic                     shift and go to state 71
    operatorcomparator             shift and go to state 72
    operatorbittobit               shift and go to state 73

state 124

    (34) stm -> IF LPAREN expression . RPAREN bodyorstm
    (35) stm -> IF LPAREN expression . RPAREN bodyorstm ELSE bodyorstm
    (36) stm -> IF LPAREN expression . RPAREN bodyorstm ELSE IF bodyorstm
    (45) operator -> expression . arithmetic expression
    (47) operator -> expression . operatorcomparator expression
    (50) operator -> expression . operatorbittobit
    (64) arithmetic -> . TIMES
    (65) arithmetic -> . DIVIDE
    (66) arithmetic -> . MODULE
    (67) arithmetic -> . PLUS
    (68) arithmetic -> . MINUS
    (81) operatorcomparator -> . LEQ
    (82) operatorcomparator -> . GEQ
    (83) operatorcomparator -> . LT
    (84) operatorcomparator -> . GT
    (85) operatorcomparator -> . NEQ
    (86) operatorcomparator -> . EQ
    (87) operatorcomparator -> . AND
    (88) operatorcomparator -> . OR
    (89) operatorcomparator -> . BITWISE_AND
    (90) operatorcomparator -> . BITWISE_OR
    (91) operatorcomparator -> . BITWISE_XOR
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    RPAREN          shift and go to state 136
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75
    MODULE          shift and go to state 76
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78
    LEQ             shift and go to state 79
    GEQ             shift and go to state 80
    LT              shift and go to state 81
    GT              shift and go to state 82
    NEQ             shift and go to state 83
    EQ              shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86
    BITWISE_AND     shift and go to state 87
    BITWISE_OR      shift and go to state 88
    BITWISE_XOR     shift and go to state 89
    URSHIFT         shift and go to state 90
    LSHIFT          shift and go to state 91
    RSHIFT          shift and go to state 92

    arithmetic                     shift and go to state 71
    operatorcomparator             shift and go to state 72
    operatorbittobit               shift and go to state 73

state 125

    (46) operator -> ID assign expression .
    (45) operator -> expression . arithmetic expression
    (47) operator -> expression . operatorcomparator expression
    (50) operator -> expression . operatorbittobit
    (64) arithmetic -> . TIMES
    (65) arithmetic -> . DIVIDE
    (66) arithmetic -> . MODULE
    (67) arithmetic -> . PLUS
    (68) arithmetic -> . MINUS
    (81) operatorcomparator -> . LEQ
    (82) operatorcomparator -> . GEQ
    (83) operatorcomparator -> . LT
    (84) operatorcomparator -> . GT
    (85) operatorcomparator -> . NEQ
    (86) operatorcomparator -> . EQ
    (87) operatorcomparator -> . AND
    (88) operatorcomparator -> . OR
    (89) operatorcomparator -> . BITWISE_AND
    (90) operatorcomparator -> . BITWISE_OR
    (91) operatorcomparator -> . BITWISE_XOR
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for BITWISE_AND resolved as shift
  ! shift/reduce conflict for BITWISE_OR resolved as shift
  ! shift/reduce conflict for BITWISE_XOR resolved as shift
  ! shift/reduce conflict for URSHIFT resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
    SEMICOLON       reduce using rule 46 (operator -> ID assign expression .)
    RPAREN          reduce using rule 46 (operator -> ID assign expression .)
    COMMA           reduce using rule 46 (operator -> ID assign expression .)
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75
    MODULE          shift and go to state 76
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78
    LEQ             shift and go to state 79
    GEQ             shift and go to state 80
    LT              shift and go to state 81
    GT              shift and go to state 82
    NEQ             shift and go to state 83
    EQ              shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86
    BITWISE_AND     shift and go to state 87
    BITWISE_OR      shift and go to state 88
    BITWISE_XOR     shift and go to state 89
    URSHIFT         shift and go to state 90
    LSHIFT          shift and go to state 91
    RSHIFT          shift and go to state 92

  ! TIMES           [ reduce using rule 46 (operator -> ID assign expression .) ]
  ! DIVIDE          [ reduce using rule 46 (operator -> ID assign expression .) ]
  ! MODULE          [ reduce using rule 46 (operator -> ID assign expression .) ]
  ! PLUS            [ reduce using rule 46 (operator -> ID assign expression .) ]
  ! MINUS           [ reduce using rule 46 (operator -> ID assign expression .) ]
  ! LEQ             [ reduce using rule 46 (operator -> ID assign expression .) ]
  ! GEQ             [ reduce using rule 46 (operator -> ID assign expression .) ]
  ! LT              [ reduce using rule 46 (operator -> ID assign expression .) ]
  ! GT              [ reduce using rule 46 (operator -> ID assign expression .) ]
  ! NEQ             [ reduce using rule 46 (operator -> ID assign expression .) ]
  ! EQ              [ reduce using rule 46 (operator -> ID assign expression .) ]
  ! AND             [ reduce using rule 46 (operator -> ID assign expression .) ]
  ! OR              [ reduce using rule 46 (operator -> ID assign expression .) ]
  ! BITWISE_AND     [ reduce using rule 46 (operator -> ID assign expression .) ]
  ! BITWISE_OR      [ reduce using rule 46 (operator -> ID assign expression .) ]
  ! BITWISE_XOR     [ reduce using rule 46 (operator -> ID assign expression .) ]
  ! URSHIFT         [ reduce using rule 46 (operator -> ID assign expression .) ]
  ! LSHIFT          [ reduce using rule 46 (operator -> ID assign expression .) ]
  ! RSHIFT          [ reduce using rule 46 (operator -> ID assign expression .) ]

    arithmetic                     shift and go to state 71
    operatorcomparator             shift and go to state 72
    operatorbittobit               shift and go to state 73

state 126

    (102) call -> ID LPAREN params . RPAREN

    RPAREN          shift and go to state 137


state 127

    (103) call -> ID LPAREN RPAREN .

    SEMICOLON       reduce using rule 103 (call -> ID LPAREN RPAREN .)
    TIMES           reduce using rule 103 (call -> ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 103 (call -> ID LPAREN RPAREN .)
    MODULE          reduce using rule 103 (call -> ID LPAREN RPAREN .)
    PLUS            reduce using rule 103 (call -> ID LPAREN RPAREN .)
    MINUS           reduce using rule 103 (call -> ID LPAREN RPAREN .)
    LEQ             reduce using rule 103 (call -> ID LPAREN RPAREN .)
    GEQ             reduce using rule 103 (call -> ID LPAREN RPAREN .)
    LT              reduce using rule 103 (call -> ID LPAREN RPAREN .)
    GT              reduce using rule 103 (call -> ID LPAREN RPAREN .)
    NEQ             reduce using rule 103 (call -> ID LPAREN RPAREN .)
    EQ              reduce using rule 103 (call -> ID LPAREN RPAREN .)
    AND             reduce using rule 103 (call -> ID LPAREN RPAREN .)
    OR              reduce using rule 103 (call -> ID LPAREN RPAREN .)
    BITWISE_AND     reduce using rule 103 (call -> ID LPAREN RPAREN .)
    BITWISE_OR      reduce using rule 103 (call -> ID LPAREN RPAREN .)
    BITWISE_XOR     reduce using rule 103 (call -> ID LPAREN RPAREN .)
    URSHIFT         reduce using rule 103 (call -> ID LPAREN RPAREN .)
    LSHIFT          reduce using rule 103 (call -> ID LPAREN RPAREN .)
    RSHIFT          reduce using rule 103 (call -> ID LPAREN RPAREN .)
    RPAREN          reduce using rule 103 (call -> ID LPAREN RPAREN .)
    COMMA           reduce using rule 103 (call -> ID LPAREN RPAREN .)


state 128

    (104) params -> expression . COMMA params
    (105) params -> expression .
    (45) operator -> expression . arithmetic expression
    (47) operator -> expression . operatorcomparator expression
    (50) operator -> expression . operatorbittobit
    (64) arithmetic -> . TIMES
    (65) arithmetic -> . DIVIDE
    (66) arithmetic -> . MODULE
    (67) arithmetic -> . PLUS
    (68) arithmetic -> . MINUS
    (81) operatorcomparator -> . LEQ
    (82) operatorcomparator -> . GEQ
    (83) operatorcomparator -> . LT
    (84) operatorcomparator -> . GT
    (85) operatorcomparator -> . NEQ
    (86) operatorcomparator -> . EQ
    (87) operatorcomparator -> . AND
    (88) operatorcomparator -> . OR
    (89) operatorcomparator -> . BITWISE_AND
    (90) operatorcomparator -> . BITWISE_OR
    (91) operatorcomparator -> . BITWISE_XOR
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    COMMA           shift and go to state 138
    RPAREN          reduce using rule 105 (params -> expression .)
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75
    MODULE          shift and go to state 76
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78
    LEQ             shift and go to state 79
    GEQ             shift and go to state 80
    LT              shift and go to state 81
    GT              shift and go to state 82
    NEQ             shift and go to state 83
    EQ              shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86
    BITWISE_AND     shift and go to state 87
    BITWISE_OR      shift and go to state 88
    BITWISE_XOR     shift and go to state 89
    URSHIFT         shift and go to state 90
    LSHIFT          shift and go to state 91
    RSHIFT          shift and go to state 92

    arithmetic                     shift and go to state 71
    operatorcomparator             shift and go to state 72
    operatorbittobit               shift and go to state 73

state 129

    (18) atribute -> visibility atributemodifier type ID EQUAL ID . SEMICOLON
    (44) expression -> ID .
    (46) operator -> ID . assign expression
    (49) operator -> ID . unaryoperatorsufx
    (102) call -> ID . LPAREN params RPAREN
    (103) call -> ID . LPAREN RPAREN
    (69) assign -> . EQUAL
    (70) assign -> . MINUS_EQ
    (71) assign -> . TIMES_EQ
    (72) assign -> . PLUS_EQ
    (73) assign -> . DIVIDE_EQ
    (74) assign -> . MOD_EQ
    (75) assign -> . BITWISE_AND_EQ
    (76) assign -> . BITWISE_OR_EQ
    (77) assign -> . BITWISE_XOR_EQ
    (78) assign -> . URSHIFT_EQ
    (79) assign -> . LSHIFT_EQ
    (80) assign -> . RSHIFT_EQ
    (97) unaryoperatorsufx -> . INCREMENT
    (98) unaryoperatorsufx -> . DECREMENT

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 139
    TIMES           reduce using rule 44 (expression -> ID .)
    DIVIDE          reduce using rule 44 (expression -> ID .)
    MODULE          reduce using rule 44 (expression -> ID .)
    PLUS            reduce using rule 44 (expression -> ID .)
    MINUS           reduce using rule 44 (expression -> ID .)
    LEQ             reduce using rule 44 (expression -> ID .)
    GEQ             reduce using rule 44 (expression -> ID .)
    LT              reduce using rule 44 (expression -> ID .)
    GT              reduce using rule 44 (expression -> ID .)
    NEQ             reduce using rule 44 (expression -> ID .)
    EQ              reduce using rule 44 (expression -> ID .)
    AND             reduce using rule 44 (expression -> ID .)
    OR              reduce using rule 44 (expression -> ID .)
    BITWISE_AND     reduce using rule 44 (expression -> ID .)
    BITWISE_OR      reduce using rule 44 (expression -> ID .)
    BITWISE_XOR     reduce using rule 44 (expression -> ID .)
    URSHIFT         reduce using rule 44 (expression -> ID .)
    LSHIFT          reduce using rule 44 (expression -> ID .)
    RSHIFT          reduce using rule 44 (expression -> ID .)
    LPAREN          shift and go to state 100
    EQUAL           shift and go to state 101
    MINUS_EQ        shift and go to state 102
    TIMES_EQ        shift and go to state 103
    PLUS_EQ         shift and go to state 104
    DIVIDE_EQ       shift and go to state 105
    MOD_EQ          shift and go to state 106
    BITWISE_AND_EQ  shift and go to state 107
    BITWISE_OR_EQ   shift and go to state 108
    BITWISE_XOR_EQ  shift and go to state 109
    URSHIFT_EQ      shift and go to state 110
    LSHIFT_EQ       shift and go to state 111
    RSHIFT_EQ       shift and go to state 112
    INCREMENT       shift and go to state 113
    DECREMENT       shift and go to state 114

  ! SEMICOLON       [ reduce using rule 44 (expression -> ID .) ]

    assign                         shift and go to state 98
    unaryoperatorsufx              shift and go to state 99

state 130

    (19) atribute -> visibility atributemodifier type ID EQUAL expression . SEMICOLON
    (45) operator -> expression . arithmetic expression
    (47) operator -> expression . operatorcomparator expression
    (50) operator -> expression . operatorbittobit
    (64) arithmetic -> . TIMES
    (65) arithmetic -> . DIVIDE
    (66) arithmetic -> . MODULE
    (67) arithmetic -> . PLUS
    (68) arithmetic -> . MINUS
    (81) operatorcomparator -> . LEQ
    (82) operatorcomparator -> . GEQ
    (83) operatorcomparator -> . LT
    (84) operatorcomparator -> . GT
    (85) operatorcomparator -> . NEQ
    (86) operatorcomparator -> . EQ
    (87) operatorcomparator -> . AND
    (88) operatorcomparator -> . OR
    (89) operatorcomparator -> . BITWISE_AND
    (90) operatorcomparator -> . BITWISE_OR
    (91) operatorcomparator -> . BITWISE_XOR
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       shift and go to state 140
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75
    MODULE          shift and go to state 76
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78
    LEQ             shift and go to state 79
    GEQ             shift and go to state 80
    LT              shift and go to state 81
    GT              shift and go to state 82
    NEQ             shift and go to state 83
    EQ              shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86
    BITWISE_AND     shift and go to state 87
    BITWISE_OR      shift and go to state 88
    BITWISE_XOR     shift and go to state 89
    URSHIFT         shift and go to state 90
    LSHIFT          shift and go to state 91
    RSHIFT          shift and go to state 92

    arithmetic                     shift and go to state 71
    operatorcomparator             shift and go to state 72
    operatorbittobit               shift and go to state 73

state 131

    (25) sigparams -> ID . brackets_expression
    (26) sigparams -> ID . brackets_expression COMMA sigparams
    (51) brackets_expression -> . LBRACKET RBRACKET
    (52) brackets_expression -> . LBRACKET INT_NUMBER RBRACKET
    (53) brackets_expression -> . LBRACKET ID RBRACKET

    LBRACKET        shift and go to state 142

    brackets_expression            shift and go to state 141

state 132

    (24) signature -> visibility atributemodifier type ID LPAREN sigparams . RPAREN

    RPAREN          shift and go to state 143


state 133

    (31) stm -> WHILE LPAREN expression RPAREN . bodyorstm
    (38) bodyorstm -> . body
    (27) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 31

    bodyorstm                      shift and go to state 144
    body                           shift and go to state 95

state 134

    (32) stm -> DO bodyorstm WHILE LPAREN . expression RPAREN SEMICOLON
    (39) expression -> . operator
    (40) expression -> . call
    (41) expression -> . FLOAT_NUMBER
    (42) expression -> . INT_NUMBER
    (43) expression -> . STRING
    (44) expression -> . ID
    (45) operator -> . expression arithmetic expression
    (46) operator -> . ID assign expression
    (47) operator -> . expression operatorcomparator expression
    (48) operator -> . unaryoperatorprefx ID
    (49) operator -> . ID unaryoperatorsufx
    (50) operator -> . expression operatorbittobit
    (102) call -> . ID LPAREN params RPAREN
    (103) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 55
    INT_NUMBER      shift and go to state 56
    STRING          shift and go to state 57
    ID              shift and go to state 58
    INCREMENT       shift and go to state 60
    DECREMENT       shift and go to state 61
    MINUS           shift and go to state 62
    PLUS            shift and go to state 63
    NOT             shift and go to state 64

    expression                     shift and go to state 145
    operator                       shift and go to state 53
    call                           shift and go to state 54
    unaryoperatorprefx             shift and go to state 59

state 135

    (33) stm -> FOR LPAREN expression SEMICOLON . expression SEMICOLON expression SEMICOLON RPAREN bodyorstm
    (39) expression -> . operator
    (40) expression -> . call
    (41) expression -> . FLOAT_NUMBER
    (42) expression -> . INT_NUMBER
    (43) expression -> . STRING
    (44) expression -> . ID
    (45) operator -> . expression arithmetic expression
    (46) operator -> . ID assign expression
    (47) operator -> . expression operatorcomparator expression
    (48) operator -> . unaryoperatorprefx ID
    (49) operator -> . ID unaryoperatorsufx
    (50) operator -> . expression operatorbittobit
    (102) call -> . ID LPAREN params RPAREN
    (103) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 55
    INT_NUMBER      shift and go to state 56
    STRING          shift and go to state 57
    ID              shift and go to state 58
    INCREMENT       shift and go to state 60
    DECREMENT       shift and go to state 61
    MINUS           shift and go to state 62
    PLUS            shift and go to state 63
    NOT             shift and go to state 64

    expression                     shift and go to state 146
    operator                       shift and go to state 53
    call                           shift and go to state 54
    unaryoperatorprefx             shift and go to state 59

state 136

    (34) stm -> IF LPAREN expression RPAREN . bodyorstm
    (35) stm -> IF LPAREN expression RPAREN . bodyorstm ELSE bodyorstm
    (36) stm -> IF LPAREN expression RPAREN . bodyorstm ELSE IF bodyorstm
    (38) bodyorstm -> . body
    (27) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 31

    bodyorstm                      shift and go to state 147
    body                           shift and go to state 95

state 137

    (102) call -> ID LPAREN params RPAREN .

    SEMICOLON       reduce using rule 102 (call -> ID LPAREN params RPAREN .)
    TIMES           reduce using rule 102 (call -> ID LPAREN params RPAREN .)
    DIVIDE          reduce using rule 102 (call -> ID LPAREN params RPAREN .)
    MODULE          reduce using rule 102 (call -> ID LPAREN params RPAREN .)
    PLUS            reduce using rule 102 (call -> ID LPAREN params RPAREN .)
    MINUS           reduce using rule 102 (call -> ID LPAREN params RPAREN .)
    LEQ             reduce using rule 102 (call -> ID LPAREN params RPAREN .)
    GEQ             reduce using rule 102 (call -> ID LPAREN params RPAREN .)
    LT              reduce using rule 102 (call -> ID LPAREN params RPAREN .)
    GT              reduce using rule 102 (call -> ID LPAREN params RPAREN .)
    NEQ             reduce using rule 102 (call -> ID LPAREN params RPAREN .)
    EQ              reduce using rule 102 (call -> ID LPAREN params RPAREN .)
    AND             reduce using rule 102 (call -> ID LPAREN params RPAREN .)
    OR              reduce using rule 102 (call -> ID LPAREN params RPAREN .)
    BITWISE_AND     reduce using rule 102 (call -> ID LPAREN params RPAREN .)
    BITWISE_OR      reduce using rule 102 (call -> ID LPAREN params RPAREN .)
    BITWISE_XOR     reduce using rule 102 (call -> ID LPAREN params RPAREN .)
    URSHIFT         reduce using rule 102 (call -> ID LPAREN params RPAREN .)
    LSHIFT          reduce using rule 102 (call -> ID LPAREN params RPAREN .)
    RSHIFT          reduce using rule 102 (call -> ID LPAREN params RPAREN .)
    RPAREN          reduce using rule 102 (call -> ID LPAREN params RPAREN .)
    COMMA           reduce using rule 102 (call -> ID LPAREN params RPAREN .)


state 138

    (104) params -> expression COMMA . params
    (104) params -> . expression COMMA params
    (105) params -> . expression
    (39) expression -> . operator
    (40) expression -> . call
    (41) expression -> . FLOAT_NUMBER
    (42) expression -> . INT_NUMBER
    (43) expression -> . STRING
    (44) expression -> . ID
    (45) operator -> . expression arithmetic expression
    (46) operator -> . ID assign expression
    (47) operator -> . expression operatorcomparator expression
    (48) operator -> . unaryoperatorprefx ID
    (49) operator -> . ID unaryoperatorsufx
    (50) operator -> . expression operatorbittobit
    (102) call -> . ID LPAREN params RPAREN
    (103) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 55
    INT_NUMBER      shift and go to state 56
    STRING          shift and go to state 57
    ID              shift and go to state 58
    INCREMENT       shift and go to state 60
    DECREMENT       shift and go to state 61
    MINUS           shift and go to state 62
    PLUS            shift and go to state 63
    NOT             shift and go to state 64

    expression                     shift and go to state 128
    params                         shift and go to state 148
    operator                       shift and go to state 53
    call                           shift and go to state 54
    unaryoperatorprefx             shift and go to state 59

state 139

    (18) atribute -> visibility atributemodifier type ID EQUAL ID SEMICOLON .

    PUBLIC          reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL ID SEMICOLON .)
    PRIVATE         reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL ID SEMICOLON .)
    PROTECTED       reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL ID SEMICOLON .)
    STATIC          reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL ID SEMICOLON .)
    FINAL           reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL ID SEMICOLON .)
    TYPE_INT        reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL ID SEMICOLON .)
    TYPE_FLOAT      reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL ID SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL ID SEMICOLON .)
    TYPE_BYTE       reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL ID SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL ID SEMICOLON .)
    TYPE_CHAR       reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL ID SEMICOLON .)
    TYPE_STRING     reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL ID SEMICOLON .)
    TYPE_LONG       reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL ID SEMICOLON .)
    TYPE_VOID       reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL ID SEMICOLON .)
    RCHAV           reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL ID SEMICOLON .)


state 140

    (19) atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .

    PUBLIC          reduce using rule 19 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    PRIVATE         reduce using rule 19 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    PROTECTED       reduce using rule 19 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    STATIC          reduce using rule 19 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    FINAL           reduce using rule 19 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_INT        reduce using rule 19 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_FLOAT      reduce using rule 19 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 19 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_BYTE       reduce using rule 19 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 19 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 19 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_STRING     reduce using rule 19 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_LONG       reduce using rule 19 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_VOID       reduce using rule 19 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    RCHAV           reduce using rule 19 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)


state 141

    (25) sigparams -> ID brackets_expression .
    (26) sigparams -> ID brackets_expression . COMMA sigparams

    RPAREN          reduce using rule 25 (sigparams -> ID brackets_expression .)
    COMMA           shift and go to state 149


state 142

    (51) brackets_expression -> LBRACKET . RBRACKET
    (52) brackets_expression -> LBRACKET . INT_NUMBER RBRACKET
    (53) brackets_expression -> LBRACKET . ID RBRACKET

    RBRACKET        shift and go to state 150
    INT_NUMBER      shift and go to state 151
    ID              shift and go to state 152


state 143

    (24) signature -> visibility atributemodifier type ID LPAREN sigparams RPAREN .

    LCHAV           reduce using rule 24 (signature -> visibility atributemodifier type ID LPAREN sigparams RPAREN .)


state 144

    (31) stm -> WHILE LPAREN expression RPAREN bodyorstm .

    WHILE           reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    DO              reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    FOR             reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    IF              reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    SEMICOLON       reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    FLOAT_NUMBER    reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    INT_NUMBER      reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    STRING          reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    ID              reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    INCREMENT       reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    DECREMENT       reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    MINUS           reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    PLUS            reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    NOT             reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    RCHAV           reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)


state 145

    (32) stm -> DO bodyorstm WHILE LPAREN expression . RPAREN SEMICOLON
    (45) operator -> expression . arithmetic expression
    (47) operator -> expression . operatorcomparator expression
    (50) operator -> expression . operatorbittobit
    (64) arithmetic -> . TIMES
    (65) arithmetic -> . DIVIDE
    (66) arithmetic -> . MODULE
    (67) arithmetic -> . PLUS
    (68) arithmetic -> . MINUS
    (81) operatorcomparator -> . LEQ
    (82) operatorcomparator -> . GEQ
    (83) operatorcomparator -> . LT
    (84) operatorcomparator -> . GT
    (85) operatorcomparator -> . NEQ
    (86) operatorcomparator -> . EQ
    (87) operatorcomparator -> . AND
    (88) operatorcomparator -> . OR
    (89) operatorcomparator -> . BITWISE_AND
    (90) operatorcomparator -> . BITWISE_OR
    (91) operatorcomparator -> . BITWISE_XOR
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    RPAREN          shift and go to state 153
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75
    MODULE          shift and go to state 76
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78
    LEQ             shift and go to state 79
    GEQ             shift and go to state 80
    LT              shift and go to state 81
    GT              shift and go to state 82
    NEQ             shift and go to state 83
    EQ              shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86
    BITWISE_AND     shift and go to state 87
    BITWISE_OR      shift and go to state 88
    BITWISE_XOR     shift and go to state 89
    URSHIFT         shift and go to state 90
    LSHIFT          shift and go to state 91
    RSHIFT          shift and go to state 92

    arithmetic                     shift and go to state 71
    operatorcomparator             shift and go to state 72
    operatorbittobit               shift and go to state 73

state 146

    (33) stm -> FOR LPAREN expression SEMICOLON expression . SEMICOLON expression SEMICOLON RPAREN bodyorstm
    (45) operator -> expression . arithmetic expression
    (47) operator -> expression . operatorcomparator expression
    (50) operator -> expression . operatorbittobit
    (64) arithmetic -> . TIMES
    (65) arithmetic -> . DIVIDE
    (66) arithmetic -> . MODULE
    (67) arithmetic -> . PLUS
    (68) arithmetic -> . MINUS
    (81) operatorcomparator -> . LEQ
    (82) operatorcomparator -> . GEQ
    (83) operatorcomparator -> . LT
    (84) operatorcomparator -> . GT
    (85) operatorcomparator -> . NEQ
    (86) operatorcomparator -> . EQ
    (87) operatorcomparator -> . AND
    (88) operatorcomparator -> . OR
    (89) operatorcomparator -> . BITWISE_AND
    (90) operatorcomparator -> . BITWISE_OR
    (91) operatorcomparator -> . BITWISE_XOR
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       shift and go to state 154
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75
    MODULE          shift and go to state 76
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78
    LEQ             shift and go to state 79
    GEQ             shift and go to state 80
    LT              shift and go to state 81
    GT              shift and go to state 82
    NEQ             shift and go to state 83
    EQ              shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86
    BITWISE_AND     shift and go to state 87
    BITWISE_OR      shift and go to state 88
    BITWISE_XOR     shift and go to state 89
    URSHIFT         shift and go to state 90
    LSHIFT          shift and go to state 91
    RSHIFT          shift and go to state 92

    arithmetic                     shift and go to state 71
    operatorcomparator             shift and go to state 72
    operatorbittobit               shift and go to state 73

state 147

    (34) stm -> IF LPAREN expression RPAREN bodyorstm .
    (35) stm -> IF LPAREN expression RPAREN bodyorstm . ELSE bodyorstm
    (36) stm -> IF LPAREN expression RPAREN bodyorstm . ELSE IF bodyorstm

    WHILE           reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    DO              reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    FOR             reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    IF              reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    SEMICOLON       reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    FLOAT_NUMBER    reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    INT_NUMBER      reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    STRING          reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    ID              reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    INCREMENT       reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    DECREMENT       reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    MINUS           reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    PLUS            reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    NOT             reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    RCHAV           reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    ELSE            shift and go to state 155


state 148

    (104) params -> expression COMMA params .

    RPAREN          reduce using rule 104 (params -> expression COMMA params .)


state 149

    (26) sigparams -> ID brackets_expression COMMA . sigparams
    (25) sigparams -> . ID brackets_expression
    (26) sigparams -> . ID brackets_expression COMMA sigparams

    ID              shift and go to state 131

    sigparams                      shift and go to state 156

state 150

    (51) brackets_expression -> LBRACKET RBRACKET .

    COMMA           reduce using rule 51 (brackets_expression -> LBRACKET RBRACKET .)
    RPAREN          reduce using rule 51 (brackets_expression -> LBRACKET RBRACKET .)


state 151

    (52) brackets_expression -> LBRACKET INT_NUMBER . RBRACKET

    RBRACKET        shift and go to state 157


state 152

    (53) brackets_expression -> LBRACKET ID . RBRACKET

    RBRACKET        shift and go to state 158


state 153

    (32) stm -> DO bodyorstm WHILE LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 159


state 154

    (33) stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON . expression SEMICOLON RPAREN bodyorstm
    (39) expression -> . operator
    (40) expression -> . call
    (41) expression -> . FLOAT_NUMBER
    (42) expression -> . INT_NUMBER
    (43) expression -> . STRING
    (44) expression -> . ID
    (45) operator -> . expression arithmetic expression
    (46) operator -> . ID assign expression
    (47) operator -> . expression operatorcomparator expression
    (48) operator -> . unaryoperatorprefx ID
    (49) operator -> . ID unaryoperatorsufx
    (50) operator -> . expression operatorbittobit
    (102) call -> . ID LPAREN params RPAREN
    (103) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 55
    INT_NUMBER      shift and go to state 56
    STRING          shift and go to state 57
    ID              shift and go to state 58
    INCREMENT       shift and go to state 60
    DECREMENT       shift and go to state 61
    MINUS           shift and go to state 62
    PLUS            shift and go to state 63
    NOT             shift and go to state 64

    expression                     shift and go to state 160
    operator                       shift and go to state 53
    call                           shift and go to state 54
    unaryoperatorprefx             shift and go to state 59

state 155

    (35) stm -> IF LPAREN expression RPAREN bodyorstm ELSE . bodyorstm
    (36) stm -> IF LPAREN expression RPAREN bodyorstm ELSE . IF bodyorstm
    (38) bodyorstm -> . body
    (27) body -> . LCHAV stms RCHAV

    IF              shift and go to state 161
    LCHAV           shift and go to state 31

    bodyorstm                      shift and go to state 162
    body                           shift and go to state 95

state 156

    (26) sigparams -> ID brackets_expression COMMA sigparams .

    RPAREN          reduce using rule 26 (sigparams -> ID brackets_expression COMMA sigparams .)


state 157

    (52) brackets_expression -> LBRACKET INT_NUMBER RBRACKET .

    COMMA           reduce using rule 52 (brackets_expression -> LBRACKET INT_NUMBER RBRACKET .)
    RPAREN          reduce using rule 52 (brackets_expression -> LBRACKET INT_NUMBER RBRACKET .)


state 158

    (53) brackets_expression -> LBRACKET ID RBRACKET .

    COMMA           reduce using rule 53 (brackets_expression -> LBRACKET ID RBRACKET .)
    RPAREN          reduce using rule 53 (brackets_expression -> LBRACKET ID RBRACKET .)


state 159

    (32) stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .

    WHILE           reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    DO              reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    FOR             reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    IF              reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    INT_NUMBER      reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    STRING          reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    ID              reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    DECREMENT       reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    MINUS           reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    PLUS            reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    NOT             reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    RCHAV           reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)


state 160

    (33) stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression . SEMICOLON RPAREN bodyorstm
    (45) operator -> expression . arithmetic expression
    (47) operator -> expression . operatorcomparator expression
    (50) operator -> expression . operatorbittobit
    (64) arithmetic -> . TIMES
    (65) arithmetic -> . DIVIDE
    (66) arithmetic -> . MODULE
    (67) arithmetic -> . PLUS
    (68) arithmetic -> . MINUS
    (81) operatorcomparator -> . LEQ
    (82) operatorcomparator -> . GEQ
    (83) operatorcomparator -> . LT
    (84) operatorcomparator -> . GT
    (85) operatorcomparator -> . NEQ
    (86) operatorcomparator -> . EQ
    (87) operatorcomparator -> . AND
    (88) operatorcomparator -> . OR
    (89) operatorcomparator -> . BITWISE_AND
    (90) operatorcomparator -> . BITWISE_OR
    (91) operatorcomparator -> . BITWISE_XOR
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       shift and go to state 163
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75
    MODULE          shift and go to state 76
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78
    LEQ             shift and go to state 79
    GEQ             shift and go to state 80
    LT              shift and go to state 81
    GT              shift and go to state 82
    NEQ             shift and go to state 83
    EQ              shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86
    BITWISE_AND     shift and go to state 87
    BITWISE_OR      shift and go to state 88
    BITWISE_XOR     shift and go to state 89
    URSHIFT         shift and go to state 90
    LSHIFT          shift and go to state 91
    RSHIFT          shift and go to state 92

    arithmetic                     shift and go to state 71
    operatorcomparator             shift and go to state 72
    operatorbittobit               shift and go to state 73

state 161

    (36) stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF . bodyorstm
    (38) bodyorstm -> . body
    (27) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 31

    bodyorstm                      shift and go to state 164
    body                           shift and go to state 95

state 162

    (35) stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .

    WHILE           reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    DO              reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    FOR             reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    IF              reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    SEMICOLON       reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    FLOAT_NUMBER    reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    INT_NUMBER      reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    STRING          reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    ID              reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    INCREMENT       reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    DECREMENT       reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    MINUS           reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    PLUS            reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    NOT             reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    RCHAV           reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)


state 163

    (33) stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON . RPAREN bodyorstm

    RPAREN          shift and go to state 165


state 164

    (36) stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .

    WHILE           reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    DO              reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    FOR             reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    IF              reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    SEMICOLON       reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    FLOAT_NUMBER    reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    INT_NUMBER      reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    STRING          reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    ID              reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    INCREMENT       reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    DECREMENT       reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    MINUS           reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    PLUS            reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    NOT             reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    RCHAV           reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)


state 165

    (33) stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN . bodyorstm
    (38) bodyorstm -> . body
    (27) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 31

    bodyorstm                      shift and go to state 166
    body                           shift and go to state 95

state 166

    (33) stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .

    WHILE           reduce using rule 33 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)
    DO              reduce using rule 33 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)
    FOR             reduce using rule 33 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)
    IF              reduce using rule 33 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)
    SEMICOLON       reduce using rule 33 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)
    FLOAT_NUMBER    reduce using rule 33 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)
    INT_NUMBER      reduce using rule 33 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)
    STRING          reduce using rule 33 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)
    ID              reduce using rule 33 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)
    INCREMENT       reduce using rule 33 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)
    DECREMENT       reduce using rule 33 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)
    MINUS           reduce using rule 33 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)
    PLUS            reduce using rule 33 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)
    NOT             reduce using rule 33 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)
    RCHAV           reduce using rule 33 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for TIMES in state 119 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 119 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 119 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 119 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 119 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 119 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 119 resolved as shift
WARNING: shift/reduce conflict for LT in state 119 resolved as shift
WARNING: shift/reduce conflict for GT in state 119 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 119 resolved as shift
WARNING: shift/reduce conflict for EQ in state 119 resolved as shift
WARNING: shift/reduce conflict for AND in state 119 resolved as shift
WARNING: shift/reduce conflict for OR in state 119 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 119 resolved as shift
WARNING: shift/reduce conflict for BITWISE_OR in state 119 resolved as shift
WARNING: shift/reduce conflict for BITWISE_XOR in state 119 resolved as shift
WARNING: shift/reduce conflict for URSHIFT in state 119 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 119 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 119 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 120 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 120 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 120 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 120 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 120 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 120 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 120 resolved as shift
WARNING: shift/reduce conflict for LT in state 120 resolved as shift
WARNING: shift/reduce conflict for GT in state 120 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 120 resolved as shift
WARNING: shift/reduce conflict for EQ in state 120 resolved as shift
WARNING: shift/reduce conflict for AND in state 120 resolved as shift
WARNING: shift/reduce conflict for OR in state 120 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 120 resolved as shift
WARNING: shift/reduce conflict for BITWISE_OR in state 120 resolved as shift
WARNING: shift/reduce conflict for BITWISE_XOR in state 120 resolved as shift
WARNING: shift/reduce conflict for URSHIFT in state 120 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 120 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 120 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 125 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 125 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 125 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 125 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 125 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 125 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 125 resolved as shift
WARNING: shift/reduce conflict for LT in state 125 resolved as shift
WARNING: shift/reduce conflict for GT in state 125 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 125 resolved as shift
WARNING: shift/reduce conflict for EQ in state 125 resolved as shift
WARNING: shift/reduce conflict for AND in state 125 resolved as shift
WARNING: shift/reduce conflict for OR in state 125 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 125 resolved as shift
WARNING: shift/reduce conflict for BITWISE_OR in state 125 resolved as shift
WARNING: shift/reduce conflict for BITWISE_XOR in state 125 resolved as shift
WARNING: shift/reduce conflict for URSHIFT in state 125 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 125 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 125 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 129 resolved as shift
