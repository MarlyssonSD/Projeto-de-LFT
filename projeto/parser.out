Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ASSERT
    BIN_NUMBER
    BITWISE_NOT
    BREAK
    BYTE_NUMBER
    CASE
    CATCH
    CHAR
    CONST
    CONTINUE
    DEFAULT
    DOT
    ENUM
    FINALLY
    GOTO
    HEXA_NUMBER
    IMPORT
    INSTANCEOF
    INTERFACE
    LONG_NUMBER
    NATIVE
    OCTAL_NUMBER
    POT
    SHORT
    STRICTFP
    SUPER
    SWITCH
    SYNCHRONIZED
    TERNARY
    THIS
    THROW
    THROWS
    TRANSIENT
    TRY
    VOLATILE

Grammar

Rule 0     S' -> program
Rule 1     program -> class
Rule 2     class -> visibility classmodifier CLASS ID EXTENDS ID LCHAV membros RCHAV
Rule 3     class -> visibility classmodifier CLASS ID LCHAV membros RCHAV
Rule 4     class -> visibility classmodifier CLASS ID IMPLEMENTS LCHAV membros RCHAV
Rule 5     visibility -> PUBLIC
Rule 6     visibility -> PRIVATE
Rule 7     visibility -> PROTECTED
Rule 8     visibility -> <empty>
Rule 9     classmodifier -> <empty>
Rule 10    classmodifier -> ABSTRACT
Rule 11    classmodifier -> FINAL
Rule 12    classmodifier -> PACKAGE
Rule 13    membros -> membro
Rule 14    membros -> membro membros
Rule 15    membro -> atribute
Rule 16    membro -> function
Rule 17    atribute -> visibility atributemodifier type ID SEMICOLON
Rule 18    atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON
Rule 19    atributemodifier -> <empty>
Rule 20    atributemodifier -> STATIC
Rule 21    atributemodifier -> FINAL
Rule 22    function -> signature body
Rule 23    signature -> visibility atributemodifier type ID LPAREN sigparams RPAREN
Rule 24    signature -> visibility atributemodifier type brackets_expression ID LPAREN sigparams RPAREN
Rule 25    sigparams -> type ID
Rule 26    sigparams -> type ID COMMA sigparams
Rule 27    body -> LCHAV stms RCHAV
Rule 28    stms -> stm
Rule 29    stms -> stm stms
Rule 30    stm -> expression SEMICOLON
Rule 31    stm -> WHILE LPAREN expression RPAREN bodyorstm
Rule 32    stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON
Rule 33    stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm
Rule 34    stm -> IF LPAREN expression RPAREN bodyorstm
Rule 35    stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm
Rule 36    stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm
Rule 37    stm -> SEMICOLON
Rule 38    stm -> atributemodifier type ID SEMICOLON
Rule 39    stm -> atributemodifier type ID EQUAL expression SEMICOLON
Rule 40    stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON
Rule 41    stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON
Rule 42    stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON
Rule 43    stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON
Rule 44    stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON
Rule 45    stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON
Rule 46    stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON
Rule 47    stm -> RETURN expression SEMICOLON
Rule 48    stm -> RETURN SEMICOLON
Rule 49    bodyorstm -> body
Rule 50    expression_for -> type ID EQUAL expression
Rule 51    expression_for -> ID EQUAL expression
Rule 52    expression -> operator
Rule 53    expression -> call
Rule 54    expression -> FLOAT_NUMBER
Rule 55    expression -> DOUBLE_NUMBER
Rule 56    expression -> INT_NUMBER
Rule 57    expression -> STRING
Rule 58    expression -> ID
Rule 59    expression -> NEW type LPAREN params_call RPAREN
Rule 60    expression -> NEW type LBRACKET expression RBRACKET
Rule 61    operator -> expression TIMES expression
Rule 62    operator -> expression DIVIDE expression
Rule 63    operator -> expression MODULE expression
Rule 64    operator -> expression PLUS expression
Rule 65    operator -> expression MINUS expression
Rule 66    operator -> ID EQUAL expression
Rule 67    operator -> ID MINUS_EQ expression
Rule 68    operator -> ID TIMES_EQ expression
Rule 69    operator -> ID PLUS_EQ expression
Rule 70    operator -> ID DIVIDE_EQ expression
Rule 71    operator -> ID MOD_EQ expression
Rule 72    operator -> ID BITWISE_AND_EQ expression
Rule 73    operator -> ID BITWISE_OR_EQ expression
Rule 74    operator -> ID BITWISE_XOR_EQ expression
Rule 75    operator -> ID URSHIFT_EQ expression
Rule 76    operator -> ID LSHIFT_EQ expression
Rule 77    operator -> ID RSHIFT_EQ expression
Rule 78    operator -> expression LEQ expression
Rule 79    operator -> expression GEQ expression
Rule 80    operator -> expression LT expression
Rule 81    operator -> expression GT expression
Rule 82    operator -> expression NEQ expression
Rule 83    operator -> expression EQ expression
Rule 84    operator -> expression AND expression
Rule 85    operator -> expression OR expression
Rule 86    operator -> expression BITWISE_AND expression
Rule 87    operator -> expression BITWISE_OR expression
Rule 88    operator -> expression BITWISE_XOR expression
Rule 89    operator -> unaryoperatorprefx ID
Rule 90    operator -> ID unaryoperatorsufx
Rule 91    operator -> expression operatorbittobit
Rule 92    unaryoperatorprefx -> INCREMENT
Rule 93    unaryoperatorprefx -> DECREMENT
Rule 94    unaryoperatorprefx -> MINUS
Rule 95    unaryoperatorprefx -> PLUS
Rule 96    unaryoperatorprefx -> NOT
Rule 97    unaryoperatorsufx -> INCREMENT
Rule 98    unaryoperatorsufx -> DECREMENT
Rule 99    operatorbittobit -> URSHIFT
Rule 100   operatorbittobit -> LSHIFT
Rule 101   operatorbittobit -> RSHIFT
Rule 102   brackets_expression -> LBRACKET RBRACKET
Rule 103   brackets_expression -> LBRACKET INT_NUMBER RBRACKET
Rule 104   brackets_expression -> LBRACKET ID RBRACKET
Rule 105   type -> primitivetypes
Rule 106   primitivetypes -> TYPE_INT
Rule 107   primitivetypes -> TYPE_FLOAT
Rule 108   primitivetypes -> TYPE_DOUBLE
Rule 109   primitivetypes -> TYPE_BYTE
Rule 110   primitivetypes -> TYPE_BOOLEAN
Rule 111   primitivetypes -> TYPE_CHAR
Rule 112   primitivetypes -> TYPE_STRING
Rule 113   primitivetypes -> TYPE_LONG
Rule 114   primitivetypes -> TYPE_VOID
Rule 115   call -> ID LPAREN params_call RPAREN
Rule 116   call -> ID LPAREN RPAREN
Rule 117   params_call -> expression COMMA params_call
Rule 118   params_call -> expression
Rule 119   chav_exp -> LCHAV RCHAV
Rule 120   chav_exp -> LCHAV expression_chav
Rule 121   expression_chav -> expression COMMA expression_chav
Rule 122   expression_chav -> expression RCHAV
Rule 123   expression_chav -> expression COMMA RCHAV

Terminals, with rules where they appear

ABSTRACT             : 10
AND                  : 84
ASSERT               : 
BIN_NUMBER           : 
BITWISE_AND          : 86
BITWISE_AND_EQ       : 72
BITWISE_NOT          : 
BITWISE_OR           : 87
BITWISE_OR_EQ        : 73
BITWISE_XOR          : 88
BITWISE_XOR_EQ       : 74
BREAK                : 
BYTE_NUMBER          : 
CASE                 : 
CATCH                : 
CHAR                 : 
CLASS                : 2 3 4
COMMA                : 26 117 121 123
CONST                : 
CONTINUE             : 
DECREMENT            : 93 98
DEFAULT              : 
DIVIDE               : 62
DIVIDE_EQ            : 70
DO                   : 32
DOT                  : 
DOUBLE_NUMBER        : 55
ELSE                 : 35 36
ENUM                 : 
EQ                   : 83
EQUAL                : 18 39 42 43 44 46 50 51 66
EXTENDS              : 2
FINAL                : 11 21
FINALLY              : 
FLOAT_NUMBER         : 54
FOR                  : 33
GEQ                  : 79
GOTO                 : 
GT                   : 81
HEXA_NUMBER          : 
ID                   : 2 2 3 4 17 18 23 24 25 26 38 39 40 41 42 43 44 45 46 50 51 58 66 67 68 69 70 71 72 73 74 75 76 77 89 90 104 115 116
IF                   : 34 35 36 36
IMPLEMENTS           : 4
IMPORT               : 
INCREMENT            : 92 97
INSTANCEOF           : 
INTERFACE            : 
INT_NUMBER           : 56 103
LBRACKET             : 40 41 42 43 44 45 45 46 46 60 102 103 104
LCHAV                : 2 3 4 27 119 120
LEQ                  : 78
LONG_NUMBER          : 
LPAREN               : 23 24 31 32 33 34 35 36 59 115 116
LSHIFT               : 100
LSHIFT_EQ            : 76
LT                   : 80
MINUS                : 65 94
MINUS_EQ             : 67
MODULE               : 63
MOD_EQ               : 71
NATIVE               : 
NEQ                  : 82
NEW                  : 59 60
NOT                  : 96
OCTAL_NUMBER         : 
OR                   : 85
PACKAGE              : 12
PLUS                 : 64 95
PLUS_EQ              : 69
POT                  : 
PRIVATE              : 6
PROTECTED            : 7
PUBLIC               : 5
RBRACKET             : 40 41 42 43 44 45 45 46 46 60 102 103 104
RCHAV                : 2 3 4 27 119 122 123
RETURN               : 47 48
RPAREN               : 23 24 31 32 33 34 35 36 59 115 116
RSHIFT               : 101
RSHIFT_EQ            : 77
SEMICOLON            : 17 18 30 32 33 33 37 38 39 40 41 42 43 44 45 46 47 48
SHORT                : 
STATIC               : 20
STRICTFP             : 
STRING               : 57
SUPER                : 
SWITCH               : 
SYNCHRONIZED         : 
TERNARY              : 
THIS                 : 
THROW                : 
THROWS               : 
TIMES                : 61
TIMES_EQ             : 68
TRANSIENT            : 
TRY                  : 
TYPE_BOOLEAN         : 110
TYPE_BYTE            : 109
TYPE_CHAR            : 111
TYPE_DOUBLE          : 108
TYPE_FLOAT           : 107
TYPE_INT             : 106
TYPE_LONG            : 113
TYPE_STRING          : 112
TYPE_VOID            : 114
URSHIFT              : 99
URSHIFT_EQ           : 75
VOLATILE             : 
WHILE                : 31 32
error                : 

Nonterminals, with rules where they appear

atribute             : 15
atributemodifier     : 17 18 23 24 38 39 40 41 42 43 44 45 46
body                 : 22 49
bodyorstm            : 31 32 33 34 35 35 36 36
brackets_expression  : 24
call                 : 53
chav_exp             : 42 44 46
class                : 1
classmodifier        : 2 3 4
expression           : 18 30 31 32 33 33 34 35 36 39 43 47 50 51 60 61 61 62 62 63 63 64 64 65 65 66 67 68 69 70 71 72 73 74 75 76 77 78 78 79 79 80 80 81 81 82 82 83 83 84 84 85 85 86 86 87 87 88 88 91 117 118 121 122 123
expression_chav      : 120 121
expression_for       : 33
function             : 16
membro               : 13 14
membros              : 2 3 4 14
operator             : 52
operatorbittobit     : 91
params_call          : 59 115 117
primitivetypes       : 105
program              : 0
signature            : 22
sigparams            : 23 24 26
stm                  : 28 29
stms                 : 27 29
type                 : 17 18 23 24 25 26 38 39 40 41 42 43 44 45 46 50 59 60
unaryoperatorprefx   : 89
unaryoperatorsufx    : 90
visibility           : 2 3 4 17 18 23 24

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . class
    (2) class -> . visibility classmodifier CLASS ID EXTENDS ID LCHAV membros RCHAV
    (3) class -> . visibility classmodifier CLASS ID LCHAV membros RCHAV
    (4) class -> . visibility classmodifier CLASS ID IMPLEMENTS LCHAV membros RCHAV
    (5) visibility -> . PUBLIC
    (6) visibility -> . PRIVATE
    (7) visibility -> . PROTECTED
    (8) visibility -> .

    PUBLIC          shift and go to state 4
    PRIVATE         shift and go to state 5
    PROTECTED       shift and go to state 6
    ABSTRACT        reduce using rule 8 (visibility -> .)
    FINAL           reduce using rule 8 (visibility -> .)
    PACKAGE         reduce using rule 8 (visibility -> .)
    CLASS           reduce using rule 8 (visibility -> .)

    program                        shift and go to state 1
    class                          shift and go to state 2
    visibility                     shift and go to state 3

state 1

    (0) S' -> program .



state 2

    (1) program -> class .

    $end            reduce using rule 1 (program -> class .)


state 3

    (2) class -> visibility . classmodifier CLASS ID EXTENDS ID LCHAV membros RCHAV
    (3) class -> visibility . classmodifier CLASS ID LCHAV membros RCHAV
    (4) class -> visibility . classmodifier CLASS ID IMPLEMENTS LCHAV membros RCHAV
    (9) classmodifier -> .
    (10) classmodifier -> . ABSTRACT
    (11) classmodifier -> . FINAL
    (12) classmodifier -> . PACKAGE

    CLASS           reduce using rule 9 (classmodifier -> .)
    ABSTRACT        shift and go to state 8
    FINAL           shift and go to state 9
    PACKAGE         shift and go to state 10

    classmodifier                  shift and go to state 7

state 4

    (5) visibility -> PUBLIC .

    ABSTRACT        reduce using rule 5 (visibility -> PUBLIC .)
    FINAL           reduce using rule 5 (visibility -> PUBLIC .)
    PACKAGE         reduce using rule 5 (visibility -> PUBLIC .)
    CLASS           reduce using rule 5 (visibility -> PUBLIC .)
    STATIC          reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_INT        reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_FLOAT      reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_DOUBLE     reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_BYTE       reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_BOOLEAN    reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_CHAR       reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_STRING     reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_LONG       reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_VOID       reduce using rule 5 (visibility -> PUBLIC .)


state 5

    (6) visibility -> PRIVATE .

    ABSTRACT        reduce using rule 6 (visibility -> PRIVATE .)
    FINAL           reduce using rule 6 (visibility -> PRIVATE .)
    PACKAGE         reduce using rule 6 (visibility -> PRIVATE .)
    CLASS           reduce using rule 6 (visibility -> PRIVATE .)
    STATIC          reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_INT        reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_FLOAT      reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_DOUBLE     reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_BYTE       reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_BOOLEAN    reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_CHAR       reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_STRING     reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_LONG       reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_VOID       reduce using rule 6 (visibility -> PRIVATE .)


state 6

    (7) visibility -> PROTECTED .

    ABSTRACT        reduce using rule 7 (visibility -> PROTECTED .)
    FINAL           reduce using rule 7 (visibility -> PROTECTED .)
    PACKAGE         reduce using rule 7 (visibility -> PROTECTED .)
    CLASS           reduce using rule 7 (visibility -> PROTECTED .)
    STATIC          reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_INT        reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_FLOAT      reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_DOUBLE     reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_BYTE       reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_BOOLEAN    reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_CHAR       reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_STRING     reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_LONG       reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_VOID       reduce using rule 7 (visibility -> PROTECTED .)


state 7

    (2) class -> visibility classmodifier . CLASS ID EXTENDS ID LCHAV membros RCHAV
    (3) class -> visibility classmodifier . CLASS ID LCHAV membros RCHAV
    (4) class -> visibility classmodifier . CLASS ID IMPLEMENTS LCHAV membros RCHAV

    CLASS           shift and go to state 11


state 8

    (10) classmodifier -> ABSTRACT .

    CLASS           reduce using rule 10 (classmodifier -> ABSTRACT .)


state 9

    (11) classmodifier -> FINAL .

    CLASS           reduce using rule 11 (classmodifier -> FINAL .)


state 10

    (12) classmodifier -> PACKAGE .

    CLASS           reduce using rule 12 (classmodifier -> PACKAGE .)


state 11

    (2) class -> visibility classmodifier CLASS . ID EXTENDS ID LCHAV membros RCHAV
    (3) class -> visibility classmodifier CLASS . ID LCHAV membros RCHAV
    (4) class -> visibility classmodifier CLASS . ID IMPLEMENTS LCHAV membros RCHAV

    ID              shift and go to state 12


state 12

    (2) class -> visibility classmodifier CLASS ID . EXTENDS ID LCHAV membros RCHAV
    (3) class -> visibility classmodifier CLASS ID . LCHAV membros RCHAV
    (4) class -> visibility classmodifier CLASS ID . IMPLEMENTS LCHAV membros RCHAV

    EXTENDS         shift and go to state 13
    LCHAV           shift and go to state 14
    IMPLEMENTS      shift and go to state 15


state 13

    (2) class -> visibility classmodifier CLASS ID EXTENDS . ID LCHAV membros RCHAV

    ID              shift and go to state 16


state 14

    (3) class -> visibility classmodifier CLASS ID LCHAV . membros RCHAV
    (13) membros -> . membro
    (14) membros -> . membro membros
    (15) membro -> . atribute
    (16) membro -> . function
    (17) atribute -> . visibility atributemodifier type ID SEMICOLON
    (18) atribute -> . visibility atributemodifier type ID EQUAL expression SEMICOLON
    (22) function -> . signature body
    (5) visibility -> . PUBLIC
    (6) visibility -> . PRIVATE
    (7) visibility -> . PROTECTED
    (8) visibility -> .
    (23) signature -> . visibility atributemodifier type ID LPAREN sigparams RPAREN
    (24) signature -> . visibility atributemodifier type brackets_expression ID LPAREN sigparams RPAREN

    PUBLIC          shift and go to state 4
    PRIVATE         shift and go to state 5
    PROTECTED       shift and go to state 6
    STATIC          reduce using rule 8 (visibility -> .)
    FINAL           reduce using rule 8 (visibility -> .)
    TYPE_INT        reduce using rule 8 (visibility -> .)
    TYPE_FLOAT      reduce using rule 8 (visibility -> .)
    TYPE_DOUBLE     reduce using rule 8 (visibility -> .)
    TYPE_BYTE       reduce using rule 8 (visibility -> .)
    TYPE_BOOLEAN    reduce using rule 8 (visibility -> .)
    TYPE_CHAR       reduce using rule 8 (visibility -> .)
    TYPE_STRING     reduce using rule 8 (visibility -> .)
    TYPE_LONG       reduce using rule 8 (visibility -> .)
    TYPE_VOID       reduce using rule 8 (visibility -> .)

    visibility                     shift and go to state 17
    membros                        shift and go to state 18
    membro                         shift and go to state 19
    atribute                       shift and go to state 20
    function                       shift and go to state 21
    signature                      shift and go to state 22

state 15

    (4) class -> visibility classmodifier CLASS ID IMPLEMENTS . LCHAV membros RCHAV

    LCHAV           shift and go to state 23


state 16

    (2) class -> visibility classmodifier CLASS ID EXTENDS ID . LCHAV membros RCHAV

    LCHAV           shift and go to state 24


state 17

    (17) atribute -> visibility . atributemodifier type ID SEMICOLON
    (18) atribute -> visibility . atributemodifier type ID EQUAL expression SEMICOLON
    (23) signature -> visibility . atributemodifier type ID LPAREN sigparams RPAREN
    (24) signature -> visibility . atributemodifier type brackets_expression ID LPAREN sigparams RPAREN
    (19) atributemodifier -> .
    (20) atributemodifier -> . STATIC
    (21) atributemodifier -> . FINAL

    TYPE_INT        reduce using rule 19 (atributemodifier -> .)
    TYPE_FLOAT      reduce using rule 19 (atributemodifier -> .)
    TYPE_DOUBLE     reduce using rule 19 (atributemodifier -> .)
    TYPE_BYTE       reduce using rule 19 (atributemodifier -> .)
    TYPE_BOOLEAN    reduce using rule 19 (atributemodifier -> .)
    TYPE_CHAR       reduce using rule 19 (atributemodifier -> .)
    TYPE_STRING     reduce using rule 19 (atributemodifier -> .)
    TYPE_LONG       reduce using rule 19 (atributemodifier -> .)
    TYPE_VOID       reduce using rule 19 (atributemodifier -> .)
    STATIC          shift and go to state 26
    FINAL           shift and go to state 27

    atributemodifier               shift and go to state 25

state 18

    (3) class -> visibility classmodifier CLASS ID LCHAV membros . RCHAV

    RCHAV           shift and go to state 28


state 19

    (13) membros -> membro .
    (14) membros -> membro . membros
    (13) membros -> . membro
    (14) membros -> . membro membros
    (15) membro -> . atribute
    (16) membro -> . function
    (17) atribute -> . visibility atributemodifier type ID SEMICOLON
    (18) atribute -> . visibility atributemodifier type ID EQUAL expression SEMICOLON
    (22) function -> . signature body
    (5) visibility -> . PUBLIC
    (6) visibility -> . PRIVATE
    (7) visibility -> . PROTECTED
    (8) visibility -> .
    (23) signature -> . visibility atributemodifier type ID LPAREN sigparams RPAREN
    (24) signature -> . visibility atributemodifier type brackets_expression ID LPAREN sigparams RPAREN

    RCHAV           reduce using rule 13 (membros -> membro .)
    PUBLIC          shift and go to state 4
    PRIVATE         shift and go to state 5
    PROTECTED       shift and go to state 6
    STATIC          reduce using rule 8 (visibility -> .)
    FINAL           reduce using rule 8 (visibility -> .)
    TYPE_INT        reduce using rule 8 (visibility -> .)
    TYPE_FLOAT      reduce using rule 8 (visibility -> .)
    TYPE_DOUBLE     reduce using rule 8 (visibility -> .)
    TYPE_BYTE       reduce using rule 8 (visibility -> .)
    TYPE_BOOLEAN    reduce using rule 8 (visibility -> .)
    TYPE_CHAR       reduce using rule 8 (visibility -> .)
    TYPE_STRING     reduce using rule 8 (visibility -> .)
    TYPE_LONG       reduce using rule 8 (visibility -> .)
    TYPE_VOID       reduce using rule 8 (visibility -> .)

    membro                         shift and go to state 19
    membros                        shift and go to state 29
    atribute                       shift and go to state 20
    function                       shift and go to state 21
    visibility                     shift and go to state 17
    signature                      shift and go to state 22

state 20

    (15) membro -> atribute .

    PUBLIC          reduce using rule 15 (membro -> atribute .)
    PRIVATE         reduce using rule 15 (membro -> atribute .)
    PROTECTED       reduce using rule 15 (membro -> atribute .)
    STATIC          reduce using rule 15 (membro -> atribute .)
    FINAL           reduce using rule 15 (membro -> atribute .)
    TYPE_INT        reduce using rule 15 (membro -> atribute .)
    TYPE_FLOAT      reduce using rule 15 (membro -> atribute .)
    TYPE_DOUBLE     reduce using rule 15 (membro -> atribute .)
    TYPE_BYTE       reduce using rule 15 (membro -> atribute .)
    TYPE_BOOLEAN    reduce using rule 15 (membro -> atribute .)
    TYPE_CHAR       reduce using rule 15 (membro -> atribute .)
    TYPE_STRING     reduce using rule 15 (membro -> atribute .)
    TYPE_LONG       reduce using rule 15 (membro -> atribute .)
    TYPE_VOID       reduce using rule 15 (membro -> atribute .)
    RCHAV           reduce using rule 15 (membro -> atribute .)


state 21

    (16) membro -> function .

    PUBLIC          reduce using rule 16 (membro -> function .)
    PRIVATE         reduce using rule 16 (membro -> function .)
    PROTECTED       reduce using rule 16 (membro -> function .)
    STATIC          reduce using rule 16 (membro -> function .)
    FINAL           reduce using rule 16 (membro -> function .)
    TYPE_INT        reduce using rule 16 (membro -> function .)
    TYPE_FLOAT      reduce using rule 16 (membro -> function .)
    TYPE_DOUBLE     reduce using rule 16 (membro -> function .)
    TYPE_BYTE       reduce using rule 16 (membro -> function .)
    TYPE_BOOLEAN    reduce using rule 16 (membro -> function .)
    TYPE_CHAR       reduce using rule 16 (membro -> function .)
    TYPE_STRING     reduce using rule 16 (membro -> function .)
    TYPE_LONG       reduce using rule 16 (membro -> function .)
    TYPE_VOID       reduce using rule 16 (membro -> function .)
    RCHAV           reduce using rule 16 (membro -> function .)


state 22

    (22) function -> signature . body
    (27) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 31

    body                           shift and go to state 30

state 23

    (4) class -> visibility classmodifier CLASS ID IMPLEMENTS LCHAV . membros RCHAV
    (13) membros -> . membro
    (14) membros -> . membro membros
    (15) membro -> . atribute
    (16) membro -> . function
    (17) atribute -> . visibility atributemodifier type ID SEMICOLON
    (18) atribute -> . visibility atributemodifier type ID EQUAL expression SEMICOLON
    (22) function -> . signature body
    (5) visibility -> . PUBLIC
    (6) visibility -> . PRIVATE
    (7) visibility -> . PROTECTED
    (8) visibility -> .
    (23) signature -> . visibility atributemodifier type ID LPAREN sigparams RPAREN
    (24) signature -> . visibility atributemodifier type brackets_expression ID LPAREN sigparams RPAREN

    PUBLIC          shift and go to state 4
    PRIVATE         shift and go to state 5
    PROTECTED       shift and go to state 6
    STATIC          reduce using rule 8 (visibility -> .)
    FINAL           reduce using rule 8 (visibility -> .)
    TYPE_INT        reduce using rule 8 (visibility -> .)
    TYPE_FLOAT      reduce using rule 8 (visibility -> .)
    TYPE_DOUBLE     reduce using rule 8 (visibility -> .)
    TYPE_BYTE       reduce using rule 8 (visibility -> .)
    TYPE_BOOLEAN    reduce using rule 8 (visibility -> .)
    TYPE_CHAR       reduce using rule 8 (visibility -> .)
    TYPE_STRING     reduce using rule 8 (visibility -> .)
    TYPE_LONG       reduce using rule 8 (visibility -> .)
    TYPE_VOID       reduce using rule 8 (visibility -> .)

    visibility                     shift and go to state 17
    membros                        shift and go to state 32
    membro                         shift and go to state 19
    atribute                       shift and go to state 20
    function                       shift and go to state 21
    signature                      shift and go to state 22

state 24

    (2) class -> visibility classmodifier CLASS ID EXTENDS ID LCHAV . membros RCHAV
    (13) membros -> . membro
    (14) membros -> . membro membros
    (15) membro -> . atribute
    (16) membro -> . function
    (17) atribute -> . visibility atributemodifier type ID SEMICOLON
    (18) atribute -> . visibility atributemodifier type ID EQUAL expression SEMICOLON
    (22) function -> . signature body
    (5) visibility -> . PUBLIC
    (6) visibility -> . PRIVATE
    (7) visibility -> . PROTECTED
    (8) visibility -> .
    (23) signature -> . visibility atributemodifier type ID LPAREN sigparams RPAREN
    (24) signature -> . visibility atributemodifier type brackets_expression ID LPAREN sigparams RPAREN

    PUBLIC          shift and go to state 4
    PRIVATE         shift and go to state 5
    PROTECTED       shift and go to state 6
    STATIC          reduce using rule 8 (visibility -> .)
    FINAL           reduce using rule 8 (visibility -> .)
    TYPE_INT        reduce using rule 8 (visibility -> .)
    TYPE_FLOAT      reduce using rule 8 (visibility -> .)
    TYPE_DOUBLE     reduce using rule 8 (visibility -> .)
    TYPE_BYTE       reduce using rule 8 (visibility -> .)
    TYPE_BOOLEAN    reduce using rule 8 (visibility -> .)
    TYPE_CHAR       reduce using rule 8 (visibility -> .)
    TYPE_STRING     reduce using rule 8 (visibility -> .)
    TYPE_LONG       reduce using rule 8 (visibility -> .)
    TYPE_VOID       reduce using rule 8 (visibility -> .)

    visibility                     shift and go to state 17
    membros                        shift and go to state 33
    membro                         shift and go to state 19
    atribute                       shift and go to state 20
    function                       shift and go to state 21
    signature                      shift and go to state 22

state 25

    (17) atribute -> visibility atributemodifier . type ID SEMICOLON
    (18) atribute -> visibility atributemodifier . type ID EQUAL expression SEMICOLON
    (23) signature -> visibility atributemodifier . type ID LPAREN sigparams RPAREN
    (24) signature -> visibility atributemodifier . type brackets_expression ID LPAREN sigparams RPAREN
    (105) type -> . primitivetypes
    (106) primitivetypes -> . TYPE_INT
    (107) primitivetypes -> . TYPE_FLOAT
    (108) primitivetypes -> . TYPE_DOUBLE
    (109) primitivetypes -> . TYPE_BYTE
    (110) primitivetypes -> . TYPE_BOOLEAN
    (111) primitivetypes -> . TYPE_CHAR
    (112) primitivetypes -> . TYPE_STRING
    (113) primitivetypes -> . TYPE_LONG
    (114) primitivetypes -> . TYPE_VOID

    TYPE_INT        shift and go to state 36
    TYPE_FLOAT      shift and go to state 37
    TYPE_DOUBLE     shift and go to state 38
    TYPE_BYTE       shift and go to state 39
    TYPE_BOOLEAN    shift and go to state 40
    TYPE_CHAR       shift and go to state 41
    TYPE_STRING     shift and go to state 42
    TYPE_LONG       shift and go to state 43
    TYPE_VOID       shift and go to state 44

    type                           shift and go to state 34
    primitivetypes                 shift and go to state 35

state 26

    (20) atributemodifier -> STATIC .

    TYPE_INT        reduce using rule 20 (atributemodifier -> STATIC .)
    TYPE_FLOAT      reduce using rule 20 (atributemodifier -> STATIC .)
    TYPE_DOUBLE     reduce using rule 20 (atributemodifier -> STATIC .)
    TYPE_BYTE       reduce using rule 20 (atributemodifier -> STATIC .)
    TYPE_BOOLEAN    reduce using rule 20 (atributemodifier -> STATIC .)
    TYPE_CHAR       reduce using rule 20 (atributemodifier -> STATIC .)
    TYPE_STRING     reduce using rule 20 (atributemodifier -> STATIC .)
    TYPE_LONG       reduce using rule 20 (atributemodifier -> STATIC .)
    TYPE_VOID       reduce using rule 20 (atributemodifier -> STATIC .)


state 27

    (21) atributemodifier -> FINAL .

    TYPE_INT        reduce using rule 21 (atributemodifier -> FINAL .)
    TYPE_FLOAT      reduce using rule 21 (atributemodifier -> FINAL .)
    TYPE_DOUBLE     reduce using rule 21 (atributemodifier -> FINAL .)
    TYPE_BYTE       reduce using rule 21 (atributemodifier -> FINAL .)
    TYPE_BOOLEAN    reduce using rule 21 (atributemodifier -> FINAL .)
    TYPE_CHAR       reduce using rule 21 (atributemodifier -> FINAL .)
    TYPE_STRING     reduce using rule 21 (atributemodifier -> FINAL .)
    TYPE_LONG       reduce using rule 21 (atributemodifier -> FINAL .)
    TYPE_VOID       reduce using rule 21 (atributemodifier -> FINAL .)


state 28

    (3) class -> visibility classmodifier CLASS ID LCHAV membros RCHAV .

    $end            reduce using rule 3 (class -> visibility classmodifier CLASS ID LCHAV membros RCHAV .)


state 29

    (14) membros -> membro membros .

    RCHAV           reduce using rule 14 (membros -> membro membros .)


state 30

    (22) function -> signature body .

    PUBLIC          reduce using rule 22 (function -> signature body .)
    PRIVATE         reduce using rule 22 (function -> signature body .)
    PROTECTED       reduce using rule 22 (function -> signature body .)
    STATIC          reduce using rule 22 (function -> signature body .)
    FINAL           reduce using rule 22 (function -> signature body .)
    TYPE_INT        reduce using rule 22 (function -> signature body .)
    TYPE_FLOAT      reduce using rule 22 (function -> signature body .)
    TYPE_DOUBLE     reduce using rule 22 (function -> signature body .)
    TYPE_BYTE       reduce using rule 22 (function -> signature body .)
    TYPE_BOOLEAN    reduce using rule 22 (function -> signature body .)
    TYPE_CHAR       reduce using rule 22 (function -> signature body .)
    TYPE_STRING     reduce using rule 22 (function -> signature body .)
    TYPE_LONG       reduce using rule 22 (function -> signature body .)
    TYPE_VOID       reduce using rule 22 (function -> signature body .)
    RCHAV           reduce using rule 22 (function -> signature body .)


state 31

    (27) body -> LCHAV . stms RCHAV
    (28) stms -> . stm
    (29) stms -> . stm stms
    (30) stm -> . expression SEMICOLON
    (31) stm -> . WHILE LPAREN expression RPAREN bodyorstm
    (32) stm -> . DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON
    (33) stm -> . FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm
    (34) stm -> . IF LPAREN expression RPAREN bodyorstm
    (35) stm -> . IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm
    (36) stm -> . IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm
    (37) stm -> . SEMICOLON
    (38) stm -> . atributemodifier type ID SEMICOLON
    (39) stm -> . atributemodifier type ID EQUAL expression SEMICOLON
    (40) stm -> . atributemodifier type ID LBRACKET RBRACKET SEMICOLON
    (41) stm -> . atributemodifier type LBRACKET RBRACKET ID SEMICOLON
    (42) stm -> . atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON
    (43) stm -> . atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON
    (44) stm -> . atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON
    (45) stm -> . atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON
    (46) stm -> . atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON
    (47) stm -> . RETURN expression SEMICOLON
    (48) stm -> . RETURN SEMICOLON
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (19) atributemodifier -> .
    (20) atributemodifier -> . STATIC
    (21) atributemodifier -> . FINAL
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    WHILE           shift and go to state 49
    DO              shift and go to state 50
    FOR             shift and go to state 51
    IF              shift and go to state 52
    SEMICOLON       shift and go to state 48
    RETURN          shift and go to state 55
    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    TYPE_INT        reduce using rule 19 (atributemodifier -> .)
    TYPE_FLOAT      reduce using rule 19 (atributemodifier -> .)
    TYPE_DOUBLE     reduce using rule 19 (atributemodifier -> .)
    TYPE_BYTE       reduce using rule 19 (atributemodifier -> .)
    TYPE_BOOLEAN    reduce using rule 19 (atributemodifier -> .)
    TYPE_CHAR       reduce using rule 19 (atributemodifier -> .)
    TYPE_STRING     reduce using rule 19 (atributemodifier -> .)
    TYPE_LONG       reduce using rule 19 (atributemodifier -> .)
    TYPE_VOID       reduce using rule 19 (atributemodifier -> .)
    STATIC          shift and go to state 26
    FINAL           shift and go to state 27
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    stms                           shift and go to state 45
    stm                            shift and go to state 46
    expression                     shift and go to state 47
    atributemodifier               shift and go to state 53
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 32

    (4) class -> visibility classmodifier CLASS ID IMPLEMENTS LCHAV membros . RCHAV

    RCHAV           shift and go to state 69


state 33

    (2) class -> visibility classmodifier CLASS ID EXTENDS ID LCHAV membros . RCHAV

    RCHAV           shift and go to state 70


state 34

    (17) atribute -> visibility atributemodifier type . ID SEMICOLON
    (18) atribute -> visibility atributemodifier type . ID EQUAL expression SEMICOLON
    (23) signature -> visibility atributemodifier type . ID LPAREN sigparams RPAREN
    (24) signature -> visibility atributemodifier type . brackets_expression ID LPAREN sigparams RPAREN
    (102) brackets_expression -> . LBRACKET RBRACKET
    (103) brackets_expression -> . LBRACKET INT_NUMBER RBRACKET
    (104) brackets_expression -> . LBRACKET ID RBRACKET

    ID              shift and go to state 71
    LBRACKET        shift and go to state 73

    brackets_expression            shift and go to state 72

state 35

    (105) type -> primitivetypes .

    ID              reduce using rule 105 (type -> primitivetypes .)
    LBRACKET        reduce using rule 105 (type -> primitivetypes .)
    LPAREN          reduce using rule 105 (type -> primitivetypes .)


state 36

    (106) primitivetypes -> TYPE_INT .

    ID              reduce using rule 106 (primitivetypes -> TYPE_INT .)
    LBRACKET        reduce using rule 106 (primitivetypes -> TYPE_INT .)
    LPAREN          reduce using rule 106 (primitivetypes -> TYPE_INT .)


state 37

    (107) primitivetypes -> TYPE_FLOAT .

    ID              reduce using rule 107 (primitivetypes -> TYPE_FLOAT .)
    LBRACKET        reduce using rule 107 (primitivetypes -> TYPE_FLOAT .)
    LPAREN          reduce using rule 107 (primitivetypes -> TYPE_FLOAT .)


state 38

    (108) primitivetypes -> TYPE_DOUBLE .

    ID              reduce using rule 108 (primitivetypes -> TYPE_DOUBLE .)
    LBRACKET        reduce using rule 108 (primitivetypes -> TYPE_DOUBLE .)
    LPAREN          reduce using rule 108 (primitivetypes -> TYPE_DOUBLE .)


state 39

    (109) primitivetypes -> TYPE_BYTE .

    ID              reduce using rule 109 (primitivetypes -> TYPE_BYTE .)
    LBRACKET        reduce using rule 109 (primitivetypes -> TYPE_BYTE .)
    LPAREN          reduce using rule 109 (primitivetypes -> TYPE_BYTE .)


state 40

    (110) primitivetypes -> TYPE_BOOLEAN .

    ID              reduce using rule 110 (primitivetypes -> TYPE_BOOLEAN .)
    LBRACKET        reduce using rule 110 (primitivetypes -> TYPE_BOOLEAN .)
    LPAREN          reduce using rule 110 (primitivetypes -> TYPE_BOOLEAN .)


state 41

    (111) primitivetypes -> TYPE_CHAR .

    ID              reduce using rule 111 (primitivetypes -> TYPE_CHAR .)
    LBRACKET        reduce using rule 111 (primitivetypes -> TYPE_CHAR .)
    LPAREN          reduce using rule 111 (primitivetypes -> TYPE_CHAR .)


state 42

    (112) primitivetypes -> TYPE_STRING .

    ID              reduce using rule 112 (primitivetypes -> TYPE_STRING .)
    LBRACKET        reduce using rule 112 (primitivetypes -> TYPE_STRING .)
    LPAREN          reduce using rule 112 (primitivetypes -> TYPE_STRING .)


state 43

    (113) primitivetypes -> TYPE_LONG .

    ID              reduce using rule 113 (primitivetypes -> TYPE_LONG .)
    LBRACKET        reduce using rule 113 (primitivetypes -> TYPE_LONG .)
    LPAREN          reduce using rule 113 (primitivetypes -> TYPE_LONG .)


state 44

    (114) primitivetypes -> TYPE_VOID .

    ID              reduce using rule 114 (primitivetypes -> TYPE_VOID .)
    LBRACKET        reduce using rule 114 (primitivetypes -> TYPE_VOID .)
    LPAREN          reduce using rule 114 (primitivetypes -> TYPE_VOID .)


state 45

    (27) body -> LCHAV stms . RCHAV

    RCHAV           shift and go to state 74


state 46

    (28) stms -> stm .
    (29) stms -> stm . stms
    (28) stms -> . stm
    (29) stms -> . stm stms
    (30) stm -> . expression SEMICOLON
    (31) stm -> . WHILE LPAREN expression RPAREN bodyorstm
    (32) stm -> . DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON
    (33) stm -> . FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm
    (34) stm -> . IF LPAREN expression RPAREN bodyorstm
    (35) stm -> . IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm
    (36) stm -> . IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm
    (37) stm -> . SEMICOLON
    (38) stm -> . atributemodifier type ID SEMICOLON
    (39) stm -> . atributemodifier type ID EQUAL expression SEMICOLON
    (40) stm -> . atributemodifier type ID LBRACKET RBRACKET SEMICOLON
    (41) stm -> . atributemodifier type LBRACKET RBRACKET ID SEMICOLON
    (42) stm -> . atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON
    (43) stm -> . atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON
    (44) stm -> . atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON
    (45) stm -> . atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON
    (46) stm -> . atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON
    (47) stm -> . RETURN expression SEMICOLON
    (48) stm -> . RETURN SEMICOLON
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (19) atributemodifier -> .
    (20) atributemodifier -> . STATIC
    (21) atributemodifier -> . FINAL
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    RCHAV           reduce using rule 28 (stms -> stm .)
    WHILE           shift and go to state 49
    DO              shift and go to state 50
    FOR             shift and go to state 51
    IF              shift and go to state 52
    SEMICOLON       shift and go to state 48
    RETURN          shift and go to state 55
    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    TYPE_INT        reduce using rule 19 (atributemodifier -> .)
    TYPE_FLOAT      reduce using rule 19 (atributemodifier -> .)
    TYPE_DOUBLE     reduce using rule 19 (atributemodifier -> .)
    TYPE_BYTE       reduce using rule 19 (atributemodifier -> .)
    TYPE_BOOLEAN    reduce using rule 19 (atributemodifier -> .)
    TYPE_CHAR       reduce using rule 19 (atributemodifier -> .)
    TYPE_STRING     reduce using rule 19 (atributemodifier -> .)
    TYPE_LONG       reduce using rule 19 (atributemodifier -> .)
    TYPE_VOID       reduce using rule 19 (atributemodifier -> .)
    STATIC          shift and go to state 26
    FINAL           shift and go to state 27
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    stm                            shift and go to state 46
    stms                           shift and go to state 75
    expression                     shift and go to state 47
    atributemodifier               shift and go to state 53
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 47

    (30) stm -> expression . SEMICOLON
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       shift and go to state 76
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

    operatorbittobit               shift and go to state 93

state 48

    (37) stm -> SEMICOLON .

    WHILE           reduce using rule 37 (stm -> SEMICOLON .)
    DO              reduce using rule 37 (stm -> SEMICOLON .)
    FOR             reduce using rule 37 (stm -> SEMICOLON .)
    IF              reduce using rule 37 (stm -> SEMICOLON .)
    SEMICOLON       reduce using rule 37 (stm -> SEMICOLON .)
    RETURN          reduce using rule 37 (stm -> SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 37 (stm -> SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 37 (stm -> SEMICOLON .)
    INT_NUMBER      reduce using rule 37 (stm -> SEMICOLON .)
    STRING          reduce using rule 37 (stm -> SEMICOLON .)
    ID              reduce using rule 37 (stm -> SEMICOLON .)
    NEW             reduce using rule 37 (stm -> SEMICOLON .)
    STATIC          reduce using rule 37 (stm -> SEMICOLON .)
    FINAL           reduce using rule 37 (stm -> SEMICOLON .)
    INCREMENT       reduce using rule 37 (stm -> SEMICOLON .)
    DECREMENT       reduce using rule 37 (stm -> SEMICOLON .)
    MINUS           reduce using rule 37 (stm -> SEMICOLON .)
    PLUS            reduce using rule 37 (stm -> SEMICOLON .)
    NOT             reduce using rule 37 (stm -> SEMICOLON .)
    TYPE_INT        reduce using rule 37 (stm -> SEMICOLON .)
    TYPE_FLOAT      reduce using rule 37 (stm -> SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 37 (stm -> SEMICOLON .)
    TYPE_BYTE       reduce using rule 37 (stm -> SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 37 (stm -> SEMICOLON .)
    TYPE_CHAR       reduce using rule 37 (stm -> SEMICOLON .)
    TYPE_STRING     reduce using rule 37 (stm -> SEMICOLON .)
    TYPE_LONG       reduce using rule 37 (stm -> SEMICOLON .)
    TYPE_VOID       reduce using rule 37 (stm -> SEMICOLON .)
    RCHAV           reduce using rule 37 (stm -> SEMICOLON .)


state 49

    (31) stm -> WHILE . LPAREN expression RPAREN bodyorstm

    LPAREN          shift and go to state 97


state 50

    (32) stm -> DO . bodyorstm WHILE LPAREN expression RPAREN SEMICOLON
    (49) bodyorstm -> . body
    (27) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 31

    bodyorstm                      shift and go to state 98
    body                           shift and go to state 99

state 51

    (33) stm -> FOR . LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm

    LPAREN          shift and go to state 100


state 52

    (34) stm -> IF . LPAREN expression RPAREN bodyorstm
    (35) stm -> IF . LPAREN expression RPAREN bodyorstm ELSE bodyorstm
    (36) stm -> IF . LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm

    LPAREN          shift and go to state 101


state 53

    (38) stm -> atributemodifier . type ID SEMICOLON
    (39) stm -> atributemodifier . type ID EQUAL expression SEMICOLON
    (40) stm -> atributemodifier . type ID LBRACKET RBRACKET SEMICOLON
    (41) stm -> atributemodifier . type LBRACKET RBRACKET ID SEMICOLON
    (42) stm -> atributemodifier . type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON
    (43) stm -> atributemodifier . type ID LBRACKET RBRACKET EQUAL expression SEMICOLON
    (44) stm -> atributemodifier . type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON
    (45) stm -> atributemodifier . type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON
    (46) stm -> atributemodifier . type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON
    (105) type -> . primitivetypes
    (106) primitivetypes -> . TYPE_INT
    (107) primitivetypes -> . TYPE_FLOAT
    (108) primitivetypes -> . TYPE_DOUBLE
    (109) primitivetypes -> . TYPE_BYTE
    (110) primitivetypes -> . TYPE_BOOLEAN
    (111) primitivetypes -> . TYPE_CHAR
    (112) primitivetypes -> . TYPE_STRING
    (113) primitivetypes -> . TYPE_LONG
    (114) primitivetypes -> . TYPE_VOID

    TYPE_INT        shift and go to state 36
    TYPE_FLOAT      shift and go to state 37
    TYPE_DOUBLE     shift and go to state 38
    TYPE_BYTE       shift and go to state 39
    TYPE_BOOLEAN    shift and go to state 40
    TYPE_CHAR       shift and go to state 41
    TYPE_STRING     shift and go to state 42
    TYPE_LONG       shift and go to state 43
    TYPE_VOID       shift and go to state 44

    type                           shift and go to state 102
    primitivetypes                 shift and go to state 35

state 54

    (58) expression -> ID .
    (66) operator -> ID . EQUAL expression
    (67) operator -> ID . MINUS_EQ expression
    (68) operator -> ID . TIMES_EQ expression
    (69) operator -> ID . PLUS_EQ expression
    (70) operator -> ID . DIVIDE_EQ expression
    (71) operator -> ID . MOD_EQ expression
    (72) operator -> ID . BITWISE_AND_EQ expression
    (73) operator -> ID . BITWISE_OR_EQ expression
    (74) operator -> ID . BITWISE_XOR_EQ expression
    (75) operator -> ID . URSHIFT_EQ expression
    (76) operator -> ID . LSHIFT_EQ expression
    (77) operator -> ID . RSHIFT_EQ expression
    (90) operator -> ID . unaryoperatorsufx
    (115) call -> ID . LPAREN params_call RPAREN
    (116) call -> ID . LPAREN RPAREN
    (97) unaryoperatorsufx -> . INCREMENT
    (98) unaryoperatorsufx -> . DECREMENT

    SEMICOLON       reduce using rule 58 (expression -> ID .)
    TIMES           reduce using rule 58 (expression -> ID .)
    DIVIDE          reduce using rule 58 (expression -> ID .)
    MODULE          reduce using rule 58 (expression -> ID .)
    PLUS            reduce using rule 58 (expression -> ID .)
    MINUS           reduce using rule 58 (expression -> ID .)
    LEQ             reduce using rule 58 (expression -> ID .)
    GEQ             reduce using rule 58 (expression -> ID .)
    LT              reduce using rule 58 (expression -> ID .)
    GT              reduce using rule 58 (expression -> ID .)
    NEQ             reduce using rule 58 (expression -> ID .)
    EQ              reduce using rule 58 (expression -> ID .)
    AND             reduce using rule 58 (expression -> ID .)
    OR              reduce using rule 58 (expression -> ID .)
    BITWISE_AND     reduce using rule 58 (expression -> ID .)
    BITWISE_OR      reduce using rule 58 (expression -> ID .)
    BITWISE_XOR     reduce using rule 58 (expression -> ID .)
    URSHIFT         reduce using rule 58 (expression -> ID .)
    LSHIFT          reduce using rule 58 (expression -> ID .)
    RSHIFT          reduce using rule 58 (expression -> ID .)
    RPAREN          reduce using rule 58 (expression -> ID .)
    COMMA           reduce using rule 58 (expression -> ID .)
    RBRACKET        reduce using rule 58 (expression -> ID .)
    RCHAV           reduce using rule 58 (expression -> ID .)
    EQUAL           shift and go to state 103
    MINUS_EQ        shift and go to state 104
    TIMES_EQ        shift and go to state 105
    PLUS_EQ         shift and go to state 106
    DIVIDE_EQ       shift and go to state 107
    MOD_EQ          shift and go to state 108
    BITWISE_AND_EQ  shift and go to state 109
    BITWISE_OR_EQ   shift and go to state 110
    BITWISE_XOR_EQ  shift and go to state 111
    URSHIFT_EQ      shift and go to state 112
    LSHIFT_EQ       shift and go to state 113
    RSHIFT_EQ       shift and go to state 114
    LPAREN          shift and go to state 116
    INCREMENT       shift and go to state 117
    DECREMENT       shift and go to state 118

    unaryoperatorsufx              shift and go to state 115

state 55

    (47) stm -> RETURN . expression SEMICOLON
    (48) stm -> RETURN . SEMICOLON
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    SEMICOLON       shift and go to state 120
    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 119
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 56

    (52) expression -> operator .

    SEMICOLON       reduce using rule 52 (expression -> operator .)
    TIMES           reduce using rule 52 (expression -> operator .)
    DIVIDE          reduce using rule 52 (expression -> operator .)
    MODULE          reduce using rule 52 (expression -> operator .)
    PLUS            reduce using rule 52 (expression -> operator .)
    MINUS           reduce using rule 52 (expression -> operator .)
    LEQ             reduce using rule 52 (expression -> operator .)
    GEQ             reduce using rule 52 (expression -> operator .)
    LT              reduce using rule 52 (expression -> operator .)
    GT              reduce using rule 52 (expression -> operator .)
    NEQ             reduce using rule 52 (expression -> operator .)
    EQ              reduce using rule 52 (expression -> operator .)
    AND             reduce using rule 52 (expression -> operator .)
    OR              reduce using rule 52 (expression -> operator .)
    BITWISE_AND     reduce using rule 52 (expression -> operator .)
    BITWISE_OR      reduce using rule 52 (expression -> operator .)
    BITWISE_XOR     reduce using rule 52 (expression -> operator .)
    URSHIFT         reduce using rule 52 (expression -> operator .)
    LSHIFT          reduce using rule 52 (expression -> operator .)
    RSHIFT          reduce using rule 52 (expression -> operator .)
    RPAREN          reduce using rule 52 (expression -> operator .)
    COMMA           reduce using rule 52 (expression -> operator .)
    RBRACKET        reduce using rule 52 (expression -> operator .)
    RCHAV           reduce using rule 52 (expression -> operator .)


state 57

    (53) expression -> call .

    SEMICOLON       reduce using rule 53 (expression -> call .)
    TIMES           reduce using rule 53 (expression -> call .)
    DIVIDE          reduce using rule 53 (expression -> call .)
    MODULE          reduce using rule 53 (expression -> call .)
    PLUS            reduce using rule 53 (expression -> call .)
    MINUS           reduce using rule 53 (expression -> call .)
    LEQ             reduce using rule 53 (expression -> call .)
    GEQ             reduce using rule 53 (expression -> call .)
    LT              reduce using rule 53 (expression -> call .)
    GT              reduce using rule 53 (expression -> call .)
    NEQ             reduce using rule 53 (expression -> call .)
    EQ              reduce using rule 53 (expression -> call .)
    AND             reduce using rule 53 (expression -> call .)
    OR              reduce using rule 53 (expression -> call .)
    BITWISE_AND     reduce using rule 53 (expression -> call .)
    BITWISE_OR      reduce using rule 53 (expression -> call .)
    BITWISE_XOR     reduce using rule 53 (expression -> call .)
    URSHIFT         reduce using rule 53 (expression -> call .)
    LSHIFT          reduce using rule 53 (expression -> call .)
    RSHIFT          reduce using rule 53 (expression -> call .)
    RPAREN          reduce using rule 53 (expression -> call .)
    COMMA           reduce using rule 53 (expression -> call .)
    RBRACKET        reduce using rule 53 (expression -> call .)
    RCHAV           reduce using rule 53 (expression -> call .)


state 58

    (54) expression -> FLOAT_NUMBER .

    SEMICOLON       reduce using rule 54 (expression -> FLOAT_NUMBER .)
    TIMES           reduce using rule 54 (expression -> FLOAT_NUMBER .)
    DIVIDE          reduce using rule 54 (expression -> FLOAT_NUMBER .)
    MODULE          reduce using rule 54 (expression -> FLOAT_NUMBER .)
    PLUS            reduce using rule 54 (expression -> FLOAT_NUMBER .)
    MINUS           reduce using rule 54 (expression -> FLOAT_NUMBER .)
    LEQ             reduce using rule 54 (expression -> FLOAT_NUMBER .)
    GEQ             reduce using rule 54 (expression -> FLOAT_NUMBER .)
    LT              reduce using rule 54 (expression -> FLOAT_NUMBER .)
    GT              reduce using rule 54 (expression -> FLOAT_NUMBER .)
    NEQ             reduce using rule 54 (expression -> FLOAT_NUMBER .)
    EQ              reduce using rule 54 (expression -> FLOAT_NUMBER .)
    AND             reduce using rule 54 (expression -> FLOAT_NUMBER .)
    OR              reduce using rule 54 (expression -> FLOAT_NUMBER .)
    BITWISE_AND     reduce using rule 54 (expression -> FLOAT_NUMBER .)
    BITWISE_OR      reduce using rule 54 (expression -> FLOAT_NUMBER .)
    BITWISE_XOR     reduce using rule 54 (expression -> FLOAT_NUMBER .)
    URSHIFT         reduce using rule 54 (expression -> FLOAT_NUMBER .)
    LSHIFT          reduce using rule 54 (expression -> FLOAT_NUMBER .)
    RSHIFT          reduce using rule 54 (expression -> FLOAT_NUMBER .)
    RPAREN          reduce using rule 54 (expression -> FLOAT_NUMBER .)
    COMMA           reduce using rule 54 (expression -> FLOAT_NUMBER .)
    RBRACKET        reduce using rule 54 (expression -> FLOAT_NUMBER .)
    RCHAV           reduce using rule 54 (expression -> FLOAT_NUMBER .)


state 59

    (55) expression -> DOUBLE_NUMBER .

    SEMICOLON       reduce using rule 55 (expression -> DOUBLE_NUMBER .)
    TIMES           reduce using rule 55 (expression -> DOUBLE_NUMBER .)
    DIVIDE          reduce using rule 55 (expression -> DOUBLE_NUMBER .)
    MODULE          reduce using rule 55 (expression -> DOUBLE_NUMBER .)
    PLUS            reduce using rule 55 (expression -> DOUBLE_NUMBER .)
    MINUS           reduce using rule 55 (expression -> DOUBLE_NUMBER .)
    LEQ             reduce using rule 55 (expression -> DOUBLE_NUMBER .)
    GEQ             reduce using rule 55 (expression -> DOUBLE_NUMBER .)
    LT              reduce using rule 55 (expression -> DOUBLE_NUMBER .)
    GT              reduce using rule 55 (expression -> DOUBLE_NUMBER .)
    NEQ             reduce using rule 55 (expression -> DOUBLE_NUMBER .)
    EQ              reduce using rule 55 (expression -> DOUBLE_NUMBER .)
    AND             reduce using rule 55 (expression -> DOUBLE_NUMBER .)
    OR              reduce using rule 55 (expression -> DOUBLE_NUMBER .)
    BITWISE_AND     reduce using rule 55 (expression -> DOUBLE_NUMBER .)
    BITWISE_OR      reduce using rule 55 (expression -> DOUBLE_NUMBER .)
    BITWISE_XOR     reduce using rule 55 (expression -> DOUBLE_NUMBER .)
    URSHIFT         reduce using rule 55 (expression -> DOUBLE_NUMBER .)
    LSHIFT          reduce using rule 55 (expression -> DOUBLE_NUMBER .)
    RSHIFT          reduce using rule 55 (expression -> DOUBLE_NUMBER .)
    RPAREN          reduce using rule 55 (expression -> DOUBLE_NUMBER .)
    COMMA           reduce using rule 55 (expression -> DOUBLE_NUMBER .)
    RBRACKET        reduce using rule 55 (expression -> DOUBLE_NUMBER .)
    RCHAV           reduce using rule 55 (expression -> DOUBLE_NUMBER .)


state 60

    (56) expression -> INT_NUMBER .

    SEMICOLON       reduce using rule 56 (expression -> INT_NUMBER .)
    TIMES           reduce using rule 56 (expression -> INT_NUMBER .)
    DIVIDE          reduce using rule 56 (expression -> INT_NUMBER .)
    MODULE          reduce using rule 56 (expression -> INT_NUMBER .)
    PLUS            reduce using rule 56 (expression -> INT_NUMBER .)
    MINUS           reduce using rule 56 (expression -> INT_NUMBER .)
    LEQ             reduce using rule 56 (expression -> INT_NUMBER .)
    GEQ             reduce using rule 56 (expression -> INT_NUMBER .)
    LT              reduce using rule 56 (expression -> INT_NUMBER .)
    GT              reduce using rule 56 (expression -> INT_NUMBER .)
    NEQ             reduce using rule 56 (expression -> INT_NUMBER .)
    EQ              reduce using rule 56 (expression -> INT_NUMBER .)
    AND             reduce using rule 56 (expression -> INT_NUMBER .)
    OR              reduce using rule 56 (expression -> INT_NUMBER .)
    BITWISE_AND     reduce using rule 56 (expression -> INT_NUMBER .)
    BITWISE_OR      reduce using rule 56 (expression -> INT_NUMBER .)
    BITWISE_XOR     reduce using rule 56 (expression -> INT_NUMBER .)
    URSHIFT         reduce using rule 56 (expression -> INT_NUMBER .)
    LSHIFT          reduce using rule 56 (expression -> INT_NUMBER .)
    RSHIFT          reduce using rule 56 (expression -> INT_NUMBER .)
    RPAREN          reduce using rule 56 (expression -> INT_NUMBER .)
    COMMA           reduce using rule 56 (expression -> INT_NUMBER .)
    RBRACKET        reduce using rule 56 (expression -> INT_NUMBER .)
    RCHAV           reduce using rule 56 (expression -> INT_NUMBER .)


state 61

    (57) expression -> STRING .

    SEMICOLON       reduce using rule 57 (expression -> STRING .)
    TIMES           reduce using rule 57 (expression -> STRING .)
    DIVIDE          reduce using rule 57 (expression -> STRING .)
    MODULE          reduce using rule 57 (expression -> STRING .)
    PLUS            reduce using rule 57 (expression -> STRING .)
    MINUS           reduce using rule 57 (expression -> STRING .)
    LEQ             reduce using rule 57 (expression -> STRING .)
    GEQ             reduce using rule 57 (expression -> STRING .)
    LT              reduce using rule 57 (expression -> STRING .)
    GT              reduce using rule 57 (expression -> STRING .)
    NEQ             reduce using rule 57 (expression -> STRING .)
    EQ              reduce using rule 57 (expression -> STRING .)
    AND             reduce using rule 57 (expression -> STRING .)
    OR              reduce using rule 57 (expression -> STRING .)
    BITWISE_AND     reduce using rule 57 (expression -> STRING .)
    BITWISE_OR      reduce using rule 57 (expression -> STRING .)
    BITWISE_XOR     reduce using rule 57 (expression -> STRING .)
    URSHIFT         reduce using rule 57 (expression -> STRING .)
    LSHIFT          reduce using rule 57 (expression -> STRING .)
    RSHIFT          reduce using rule 57 (expression -> STRING .)
    RPAREN          reduce using rule 57 (expression -> STRING .)
    COMMA           reduce using rule 57 (expression -> STRING .)
    RBRACKET        reduce using rule 57 (expression -> STRING .)
    RCHAV           reduce using rule 57 (expression -> STRING .)


state 62

    (59) expression -> NEW . type LPAREN params_call RPAREN
    (60) expression -> NEW . type LBRACKET expression RBRACKET
    (105) type -> . primitivetypes
    (106) primitivetypes -> . TYPE_INT
    (107) primitivetypes -> . TYPE_FLOAT
    (108) primitivetypes -> . TYPE_DOUBLE
    (109) primitivetypes -> . TYPE_BYTE
    (110) primitivetypes -> . TYPE_BOOLEAN
    (111) primitivetypes -> . TYPE_CHAR
    (112) primitivetypes -> . TYPE_STRING
    (113) primitivetypes -> . TYPE_LONG
    (114) primitivetypes -> . TYPE_VOID

    TYPE_INT        shift and go to state 36
    TYPE_FLOAT      shift and go to state 37
    TYPE_DOUBLE     shift and go to state 38
    TYPE_BYTE       shift and go to state 39
    TYPE_BOOLEAN    shift and go to state 40
    TYPE_CHAR       shift and go to state 41
    TYPE_STRING     shift and go to state 42
    TYPE_LONG       shift and go to state 43
    TYPE_VOID       shift and go to state 44

    type                           shift and go to state 121
    primitivetypes                 shift and go to state 35

state 63

    (95) unaryoperatorprefx -> PLUS .

    ID              reduce using rule 95 (unaryoperatorprefx -> PLUS .)


state 64

    (94) unaryoperatorprefx -> MINUS .

    ID              reduce using rule 94 (unaryoperatorprefx -> MINUS .)


state 65

    (89) operator -> unaryoperatorprefx . ID

    ID              shift and go to state 122


state 66

    (92) unaryoperatorprefx -> INCREMENT .

    ID              reduce using rule 92 (unaryoperatorprefx -> INCREMENT .)


state 67

    (93) unaryoperatorprefx -> DECREMENT .

    ID              reduce using rule 93 (unaryoperatorprefx -> DECREMENT .)


state 68

    (96) unaryoperatorprefx -> NOT .

    ID              reduce using rule 96 (unaryoperatorprefx -> NOT .)


state 69

    (4) class -> visibility classmodifier CLASS ID IMPLEMENTS LCHAV membros RCHAV .

    $end            reduce using rule 4 (class -> visibility classmodifier CLASS ID IMPLEMENTS LCHAV membros RCHAV .)


state 70

    (2) class -> visibility classmodifier CLASS ID EXTENDS ID LCHAV membros RCHAV .

    $end            reduce using rule 2 (class -> visibility classmodifier CLASS ID EXTENDS ID LCHAV membros RCHAV .)


state 71

    (17) atribute -> visibility atributemodifier type ID . SEMICOLON
    (18) atribute -> visibility atributemodifier type ID . EQUAL expression SEMICOLON
    (23) signature -> visibility atributemodifier type ID . LPAREN sigparams RPAREN

    SEMICOLON       shift and go to state 123
    EQUAL           shift and go to state 124
    LPAREN          shift and go to state 125


state 72

    (24) signature -> visibility atributemodifier type brackets_expression . ID LPAREN sigparams RPAREN

    ID              shift and go to state 126


state 73

    (102) brackets_expression -> LBRACKET . RBRACKET
    (103) brackets_expression -> LBRACKET . INT_NUMBER RBRACKET
    (104) brackets_expression -> LBRACKET . ID RBRACKET

    RBRACKET        shift and go to state 127
    INT_NUMBER      shift and go to state 128
    ID              shift and go to state 129


state 74

    (27) body -> LCHAV stms RCHAV .

    PUBLIC          reduce using rule 27 (body -> LCHAV stms RCHAV .)
    PRIVATE         reduce using rule 27 (body -> LCHAV stms RCHAV .)
    PROTECTED       reduce using rule 27 (body -> LCHAV stms RCHAV .)
    STATIC          reduce using rule 27 (body -> LCHAV stms RCHAV .)
    FINAL           reduce using rule 27 (body -> LCHAV stms RCHAV .)
    TYPE_INT        reduce using rule 27 (body -> LCHAV stms RCHAV .)
    TYPE_FLOAT      reduce using rule 27 (body -> LCHAV stms RCHAV .)
    TYPE_DOUBLE     reduce using rule 27 (body -> LCHAV stms RCHAV .)
    TYPE_BYTE       reduce using rule 27 (body -> LCHAV stms RCHAV .)
    TYPE_BOOLEAN    reduce using rule 27 (body -> LCHAV stms RCHAV .)
    TYPE_CHAR       reduce using rule 27 (body -> LCHAV stms RCHAV .)
    TYPE_STRING     reduce using rule 27 (body -> LCHAV stms RCHAV .)
    TYPE_LONG       reduce using rule 27 (body -> LCHAV stms RCHAV .)
    TYPE_VOID       reduce using rule 27 (body -> LCHAV stms RCHAV .)
    RCHAV           reduce using rule 27 (body -> LCHAV stms RCHAV .)
    WHILE           reduce using rule 27 (body -> LCHAV stms RCHAV .)
    DO              reduce using rule 27 (body -> LCHAV stms RCHAV .)
    FOR             reduce using rule 27 (body -> LCHAV stms RCHAV .)
    IF              reduce using rule 27 (body -> LCHAV stms RCHAV .)
    SEMICOLON       reduce using rule 27 (body -> LCHAV stms RCHAV .)
    RETURN          reduce using rule 27 (body -> LCHAV stms RCHAV .)
    FLOAT_NUMBER    reduce using rule 27 (body -> LCHAV stms RCHAV .)
    DOUBLE_NUMBER   reduce using rule 27 (body -> LCHAV stms RCHAV .)
    INT_NUMBER      reduce using rule 27 (body -> LCHAV stms RCHAV .)
    STRING          reduce using rule 27 (body -> LCHAV stms RCHAV .)
    ID              reduce using rule 27 (body -> LCHAV stms RCHAV .)
    NEW             reduce using rule 27 (body -> LCHAV stms RCHAV .)
    INCREMENT       reduce using rule 27 (body -> LCHAV stms RCHAV .)
    DECREMENT       reduce using rule 27 (body -> LCHAV stms RCHAV .)
    MINUS           reduce using rule 27 (body -> LCHAV stms RCHAV .)
    PLUS            reduce using rule 27 (body -> LCHAV stms RCHAV .)
    NOT             reduce using rule 27 (body -> LCHAV stms RCHAV .)
    ELSE            reduce using rule 27 (body -> LCHAV stms RCHAV .)


state 75

    (29) stms -> stm stms .

    RCHAV           reduce using rule 29 (stms -> stm stms .)


state 76

    (30) stm -> expression SEMICOLON .

    WHILE           reduce using rule 30 (stm -> expression SEMICOLON .)
    DO              reduce using rule 30 (stm -> expression SEMICOLON .)
    FOR             reduce using rule 30 (stm -> expression SEMICOLON .)
    IF              reduce using rule 30 (stm -> expression SEMICOLON .)
    SEMICOLON       reduce using rule 30 (stm -> expression SEMICOLON .)
    RETURN          reduce using rule 30 (stm -> expression SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 30 (stm -> expression SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 30 (stm -> expression SEMICOLON .)
    INT_NUMBER      reduce using rule 30 (stm -> expression SEMICOLON .)
    STRING          reduce using rule 30 (stm -> expression SEMICOLON .)
    ID              reduce using rule 30 (stm -> expression SEMICOLON .)
    NEW             reduce using rule 30 (stm -> expression SEMICOLON .)
    STATIC          reduce using rule 30 (stm -> expression SEMICOLON .)
    FINAL           reduce using rule 30 (stm -> expression SEMICOLON .)
    INCREMENT       reduce using rule 30 (stm -> expression SEMICOLON .)
    DECREMENT       reduce using rule 30 (stm -> expression SEMICOLON .)
    MINUS           reduce using rule 30 (stm -> expression SEMICOLON .)
    PLUS            reduce using rule 30 (stm -> expression SEMICOLON .)
    NOT             reduce using rule 30 (stm -> expression SEMICOLON .)
    TYPE_INT        reduce using rule 30 (stm -> expression SEMICOLON .)
    TYPE_FLOAT      reduce using rule 30 (stm -> expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 30 (stm -> expression SEMICOLON .)
    TYPE_BYTE       reduce using rule 30 (stm -> expression SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 30 (stm -> expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 30 (stm -> expression SEMICOLON .)
    TYPE_STRING     reduce using rule 30 (stm -> expression SEMICOLON .)
    TYPE_LONG       reduce using rule 30 (stm -> expression SEMICOLON .)
    TYPE_VOID       reduce using rule 30 (stm -> expression SEMICOLON .)
    RCHAV           reduce using rule 30 (stm -> expression SEMICOLON .)


state 77

    (61) operator -> expression TIMES . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 130
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 78

    (62) operator -> expression DIVIDE . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 131
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 79

    (63) operator -> expression MODULE . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 132
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 80

    (64) operator -> expression PLUS . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 133
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 81

    (65) operator -> expression MINUS . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 134
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 82

    (78) operator -> expression LEQ . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 135
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 83

    (79) operator -> expression GEQ . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 136
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 84

    (80) operator -> expression LT . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 137
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 85

    (81) operator -> expression GT . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 138
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 86

    (82) operator -> expression NEQ . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 139
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 87

    (83) operator -> expression EQ . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 140
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 88

    (84) operator -> expression AND . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 141
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 89

    (85) operator -> expression OR . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 142
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 90

    (86) operator -> expression BITWISE_AND . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 143
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 91

    (87) operator -> expression BITWISE_OR . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 144
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 92

    (88) operator -> expression BITWISE_XOR . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 145
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 93

    (91) operator -> expression operatorbittobit .

    SEMICOLON       reduce using rule 91 (operator -> expression operatorbittobit .)
    TIMES           reduce using rule 91 (operator -> expression operatorbittobit .)
    DIVIDE          reduce using rule 91 (operator -> expression operatorbittobit .)
    MODULE          reduce using rule 91 (operator -> expression operatorbittobit .)
    PLUS            reduce using rule 91 (operator -> expression operatorbittobit .)
    MINUS           reduce using rule 91 (operator -> expression operatorbittobit .)
    LEQ             reduce using rule 91 (operator -> expression operatorbittobit .)
    GEQ             reduce using rule 91 (operator -> expression operatorbittobit .)
    LT              reduce using rule 91 (operator -> expression operatorbittobit .)
    GT              reduce using rule 91 (operator -> expression operatorbittobit .)
    NEQ             reduce using rule 91 (operator -> expression operatorbittobit .)
    EQ              reduce using rule 91 (operator -> expression operatorbittobit .)
    AND             reduce using rule 91 (operator -> expression operatorbittobit .)
    OR              reduce using rule 91 (operator -> expression operatorbittobit .)
    BITWISE_AND     reduce using rule 91 (operator -> expression operatorbittobit .)
    BITWISE_OR      reduce using rule 91 (operator -> expression operatorbittobit .)
    BITWISE_XOR     reduce using rule 91 (operator -> expression operatorbittobit .)
    URSHIFT         reduce using rule 91 (operator -> expression operatorbittobit .)
    LSHIFT          reduce using rule 91 (operator -> expression operatorbittobit .)
    RSHIFT          reduce using rule 91 (operator -> expression operatorbittobit .)
    RPAREN          reduce using rule 91 (operator -> expression operatorbittobit .)
    COMMA           reduce using rule 91 (operator -> expression operatorbittobit .)
    RBRACKET        reduce using rule 91 (operator -> expression operatorbittobit .)
    RCHAV           reduce using rule 91 (operator -> expression operatorbittobit .)


state 94

    (99) operatorbittobit -> URSHIFT .

    SEMICOLON       reduce using rule 99 (operatorbittobit -> URSHIFT .)
    TIMES           reduce using rule 99 (operatorbittobit -> URSHIFT .)
    DIVIDE          reduce using rule 99 (operatorbittobit -> URSHIFT .)
    MODULE          reduce using rule 99 (operatorbittobit -> URSHIFT .)
    PLUS            reduce using rule 99 (operatorbittobit -> URSHIFT .)
    MINUS           reduce using rule 99 (operatorbittobit -> URSHIFT .)
    LEQ             reduce using rule 99 (operatorbittobit -> URSHIFT .)
    GEQ             reduce using rule 99 (operatorbittobit -> URSHIFT .)
    LT              reduce using rule 99 (operatorbittobit -> URSHIFT .)
    GT              reduce using rule 99 (operatorbittobit -> URSHIFT .)
    NEQ             reduce using rule 99 (operatorbittobit -> URSHIFT .)
    EQ              reduce using rule 99 (operatorbittobit -> URSHIFT .)
    AND             reduce using rule 99 (operatorbittobit -> URSHIFT .)
    OR              reduce using rule 99 (operatorbittobit -> URSHIFT .)
    BITWISE_AND     reduce using rule 99 (operatorbittobit -> URSHIFT .)
    BITWISE_OR      reduce using rule 99 (operatorbittobit -> URSHIFT .)
    BITWISE_XOR     reduce using rule 99 (operatorbittobit -> URSHIFT .)
    URSHIFT         reduce using rule 99 (operatorbittobit -> URSHIFT .)
    LSHIFT          reduce using rule 99 (operatorbittobit -> URSHIFT .)
    RSHIFT          reduce using rule 99 (operatorbittobit -> URSHIFT .)
    RPAREN          reduce using rule 99 (operatorbittobit -> URSHIFT .)
    COMMA           reduce using rule 99 (operatorbittobit -> URSHIFT .)
    RBRACKET        reduce using rule 99 (operatorbittobit -> URSHIFT .)
    RCHAV           reduce using rule 99 (operatorbittobit -> URSHIFT .)


state 95

    (100) operatorbittobit -> LSHIFT .

    SEMICOLON       reduce using rule 100 (operatorbittobit -> LSHIFT .)
    TIMES           reduce using rule 100 (operatorbittobit -> LSHIFT .)
    DIVIDE          reduce using rule 100 (operatorbittobit -> LSHIFT .)
    MODULE          reduce using rule 100 (operatorbittobit -> LSHIFT .)
    PLUS            reduce using rule 100 (operatorbittobit -> LSHIFT .)
    MINUS           reduce using rule 100 (operatorbittobit -> LSHIFT .)
    LEQ             reduce using rule 100 (operatorbittobit -> LSHIFT .)
    GEQ             reduce using rule 100 (operatorbittobit -> LSHIFT .)
    LT              reduce using rule 100 (operatorbittobit -> LSHIFT .)
    GT              reduce using rule 100 (operatorbittobit -> LSHIFT .)
    NEQ             reduce using rule 100 (operatorbittobit -> LSHIFT .)
    EQ              reduce using rule 100 (operatorbittobit -> LSHIFT .)
    AND             reduce using rule 100 (operatorbittobit -> LSHIFT .)
    OR              reduce using rule 100 (operatorbittobit -> LSHIFT .)
    BITWISE_AND     reduce using rule 100 (operatorbittobit -> LSHIFT .)
    BITWISE_OR      reduce using rule 100 (operatorbittobit -> LSHIFT .)
    BITWISE_XOR     reduce using rule 100 (operatorbittobit -> LSHIFT .)
    URSHIFT         reduce using rule 100 (operatorbittobit -> LSHIFT .)
    LSHIFT          reduce using rule 100 (operatorbittobit -> LSHIFT .)
    RSHIFT          reduce using rule 100 (operatorbittobit -> LSHIFT .)
    RPAREN          reduce using rule 100 (operatorbittobit -> LSHIFT .)
    COMMA           reduce using rule 100 (operatorbittobit -> LSHIFT .)
    RBRACKET        reduce using rule 100 (operatorbittobit -> LSHIFT .)
    RCHAV           reduce using rule 100 (operatorbittobit -> LSHIFT .)


state 96

    (101) operatorbittobit -> RSHIFT .

    SEMICOLON       reduce using rule 101 (operatorbittobit -> RSHIFT .)
    TIMES           reduce using rule 101 (operatorbittobit -> RSHIFT .)
    DIVIDE          reduce using rule 101 (operatorbittobit -> RSHIFT .)
    MODULE          reduce using rule 101 (operatorbittobit -> RSHIFT .)
    PLUS            reduce using rule 101 (operatorbittobit -> RSHIFT .)
    MINUS           reduce using rule 101 (operatorbittobit -> RSHIFT .)
    LEQ             reduce using rule 101 (operatorbittobit -> RSHIFT .)
    GEQ             reduce using rule 101 (operatorbittobit -> RSHIFT .)
    LT              reduce using rule 101 (operatorbittobit -> RSHIFT .)
    GT              reduce using rule 101 (operatorbittobit -> RSHIFT .)
    NEQ             reduce using rule 101 (operatorbittobit -> RSHIFT .)
    EQ              reduce using rule 101 (operatorbittobit -> RSHIFT .)
    AND             reduce using rule 101 (operatorbittobit -> RSHIFT .)
    OR              reduce using rule 101 (operatorbittobit -> RSHIFT .)
    BITWISE_AND     reduce using rule 101 (operatorbittobit -> RSHIFT .)
    BITWISE_OR      reduce using rule 101 (operatorbittobit -> RSHIFT .)
    BITWISE_XOR     reduce using rule 101 (operatorbittobit -> RSHIFT .)
    URSHIFT         reduce using rule 101 (operatorbittobit -> RSHIFT .)
    LSHIFT          reduce using rule 101 (operatorbittobit -> RSHIFT .)
    RSHIFT          reduce using rule 101 (operatorbittobit -> RSHIFT .)
    RPAREN          reduce using rule 101 (operatorbittobit -> RSHIFT .)
    COMMA           reduce using rule 101 (operatorbittobit -> RSHIFT .)
    RBRACKET        reduce using rule 101 (operatorbittobit -> RSHIFT .)
    RCHAV           reduce using rule 101 (operatorbittobit -> RSHIFT .)


state 97

    (31) stm -> WHILE LPAREN . expression RPAREN bodyorstm
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 146
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 98

    (32) stm -> DO bodyorstm . WHILE LPAREN expression RPAREN SEMICOLON

    WHILE           shift and go to state 147


state 99

    (49) bodyorstm -> body .

    WHILE           reduce using rule 49 (bodyorstm -> body .)
    DO              reduce using rule 49 (bodyorstm -> body .)
    FOR             reduce using rule 49 (bodyorstm -> body .)
    IF              reduce using rule 49 (bodyorstm -> body .)
    SEMICOLON       reduce using rule 49 (bodyorstm -> body .)
    RETURN          reduce using rule 49 (bodyorstm -> body .)
    FLOAT_NUMBER    reduce using rule 49 (bodyorstm -> body .)
    DOUBLE_NUMBER   reduce using rule 49 (bodyorstm -> body .)
    INT_NUMBER      reduce using rule 49 (bodyorstm -> body .)
    STRING          reduce using rule 49 (bodyorstm -> body .)
    ID              reduce using rule 49 (bodyorstm -> body .)
    NEW             reduce using rule 49 (bodyorstm -> body .)
    STATIC          reduce using rule 49 (bodyorstm -> body .)
    FINAL           reduce using rule 49 (bodyorstm -> body .)
    INCREMENT       reduce using rule 49 (bodyorstm -> body .)
    DECREMENT       reduce using rule 49 (bodyorstm -> body .)
    MINUS           reduce using rule 49 (bodyorstm -> body .)
    PLUS            reduce using rule 49 (bodyorstm -> body .)
    NOT             reduce using rule 49 (bodyorstm -> body .)
    TYPE_INT        reduce using rule 49 (bodyorstm -> body .)
    TYPE_FLOAT      reduce using rule 49 (bodyorstm -> body .)
    TYPE_DOUBLE     reduce using rule 49 (bodyorstm -> body .)
    TYPE_BYTE       reduce using rule 49 (bodyorstm -> body .)
    TYPE_BOOLEAN    reduce using rule 49 (bodyorstm -> body .)
    TYPE_CHAR       reduce using rule 49 (bodyorstm -> body .)
    TYPE_STRING     reduce using rule 49 (bodyorstm -> body .)
    TYPE_LONG       reduce using rule 49 (bodyorstm -> body .)
    TYPE_VOID       reduce using rule 49 (bodyorstm -> body .)
    RCHAV           reduce using rule 49 (bodyorstm -> body .)
    ELSE            reduce using rule 49 (bodyorstm -> body .)


state 100

    (33) stm -> FOR LPAREN . expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm
    (50) expression_for -> . type ID EQUAL expression
    (51) expression_for -> . ID EQUAL expression
    (105) type -> . primitivetypes
    (106) primitivetypes -> . TYPE_INT
    (107) primitivetypes -> . TYPE_FLOAT
    (108) primitivetypes -> . TYPE_DOUBLE
    (109) primitivetypes -> . TYPE_BYTE
    (110) primitivetypes -> . TYPE_BOOLEAN
    (111) primitivetypes -> . TYPE_CHAR
    (112) primitivetypes -> . TYPE_STRING
    (113) primitivetypes -> . TYPE_LONG
    (114) primitivetypes -> . TYPE_VOID

    ID              shift and go to state 150
    TYPE_INT        shift and go to state 36
    TYPE_FLOAT      shift and go to state 37
    TYPE_DOUBLE     shift and go to state 38
    TYPE_BYTE       shift and go to state 39
    TYPE_BOOLEAN    shift and go to state 40
    TYPE_CHAR       shift and go to state 41
    TYPE_STRING     shift and go to state 42
    TYPE_LONG       shift and go to state 43
    TYPE_VOID       shift and go to state 44

    expression_for                 shift and go to state 148
    type                           shift and go to state 149
    primitivetypes                 shift and go to state 35

state 101

    (34) stm -> IF LPAREN . expression RPAREN bodyorstm
    (35) stm -> IF LPAREN . expression RPAREN bodyorstm ELSE bodyorstm
    (36) stm -> IF LPAREN . expression RPAREN bodyorstm ELSE IF bodyorstm
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 151
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 102

    (38) stm -> atributemodifier type . ID SEMICOLON
    (39) stm -> atributemodifier type . ID EQUAL expression SEMICOLON
    (40) stm -> atributemodifier type . ID LBRACKET RBRACKET SEMICOLON
    (41) stm -> atributemodifier type . LBRACKET RBRACKET ID SEMICOLON
    (42) stm -> atributemodifier type . LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON
    (43) stm -> atributemodifier type . ID LBRACKET RBRACKET EQUAL expression SEMICOLON
    (44) stm -> atributemodifier type . ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON
    (45) stm -> atributemodifier type . LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON
    (46) stm -> atributemodifier type . LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON

    ID              shift and go to state 152
    LBRACKET        shift and go to state 153


state 103

    (66) operator -> ID EQUAL . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 154
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 104

    (67) operator -> ID MINUS_EQ . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 155
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 105

    (68) operator -> ID TIMES_EQ . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 156
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 106

    (69) operator -> ID PLUS_EQ . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 157
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 107

    (70) operator -> ID DIVIDE_EQ . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 158
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 108

    (71) operator -> ID MOD_EQ . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 159
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 109

    (72) operator -> ID BITWISE_AND_EQ . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 160
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 110

    (73) operator -> ID BITWISE_OR_EQ . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 161
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 111

    (74) operator -> ID BITWISE_XOR_EQ . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 162
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 112

    (75) operator -> ID URSHIFT_EQ . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 163
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 113

    (76) operator -> ID LSHIFT_EQ . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 164
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 114

    (77) operator -> ID RSHIFT_EQ . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 165
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 115

    (90) operator -> ID unaryoperatorsufx .

    SEMICOLON       reduce using rule 90 (operator -> ID unaryoperatorsufx .)
    TIMES           reduce using rule 90 (operator -> ID unaryoperatorsufx .)
    DIVIDE          reduce using rule 90 (operator -> ID unaryoperatorsufx .)
    MODULE          reduce using rule 90 (operator -> ID unaryoperatorsufx .)
    PLUS            reduce using rule 90 (operator -> ID unaryoperatorsufx .)
    MINUS           reduce using rule 90 (operator -> ID unaryoperatorsufx .)
    LEQ             reduce using rule 90 (operator -> ID unaryoperatorsufx .)
    GEQ             reduce using rule 90 (operator -> ID unaryoperatorsufx .)
    LT              reduce using rule 90 (operator -> ID unaryoperatorsufx .)
    GT              reduce using rule 90 (operator -> ID unaryoperatorsufx .)
    NEQ             reduce using rule 90 (operator -> ID unaryoperatorsufx .)
    EQ              reduce using rule 90 (operator -> ID unaryoperatorsufx .)
    AND             reduce using rule 90 (operator -> ID unaryoperatorsufx .)
    OR              reduce using rule 90 (operator -> ID unaryoperatorsufx .)
    BITWISE_AND     reduce using rule 90 (operator -> ID unaryoperatorsufx .)
    BITWISE_OR      reduce using rule 90 (operator -> ID unaryoperatorsufx .)
    BITWISE_XOR     reduce using rule 90 (operator -> ID unaryoperatorsufx .)
    URSHIFT         reduce using rule 90 (operator -> ID unaryoperatorsufx .)
    LSHIFT          reduce using rule 90 (operator -> ID unaryoperatorsufx .)
    RSHIFT          reduce using rule 90 (operator -> ID unaryoperatorsufx .)
    RPAREN          reduce using rule 90 (operator -> ID unaryoperatorsufx .)
    COMMA           reduce using rule 90 (operator -> ID unaryoperatorsufx .)
    RBRACKET        reduce using rule 90 (operator -> ID unaryoperatorsufx .)
    RCHAV           reduce using rule 90 (operator -> ID unaryoperatorsufx .)


state 116

    (115) call -> ID LPAREN . params_call RPAREN
    (116) call -> ID LPAREN . RPAREN
    (117) params_call -> . expression COMMA params_call
    (118) params_call -> . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    RPAREN          shift and go to state 167
    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    params_call                    shift and go to state 166
    expression                     shift and go to state 168
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 117

    (97) unaryoperatorsufx -> INCREMENT .

    SEMICOLON       reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    TIMES           reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    DIVIDE          reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    MODULE          reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    PLUS            reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    MINUS           reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    LEQ             reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    GEQ             reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    LT              reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    GT              reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    NEQ             reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    EQ              reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    AND             reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    OR              reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    BITWISE_AND     reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    BITWISE_OR      reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    BITWISE_XOR     reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    URSHIFT         reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    LSHIFT          reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    RSHIFT          reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    RPAREN          reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    COMMA           reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    RBRACKET        reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)
    RCHAV           reduce using rule 97 (unaryoperatorsufx -> INCREMENT .)


state 118

    (98) unaryoperatorsufx -> DECREMENT .

    SEMICOLON       reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    TIMES           reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    DIVIDE          reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    MODULE          reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    PLUS            reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    MINUS           reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    LEQ             reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    GEQ             reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    LT              reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    GT              reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    NEQ             reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    EQ              reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    AND             reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    OR              reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    BITWISE_AND     reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    BITWISE_OR      reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    BITWISE_XOR     reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    URSHIFT         reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    LSHIFT          reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    RSHIFT          reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    RPAREN          reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    COMMA           reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    RBRACKET        reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)
    RCHAV           reduce using rule 98 (unaryoperatorsufx -> DECREMENT .)


state 119

    (47) stm -> RETURN expression . SEMICOLON
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       shift and go to state 169
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

    operatorbittobit               shift and go to state 93

state 120

    (48) stm -> RETURN SEMICOLON .

    WHILE           reduce using rule 48 (stm -> RETURN SEMICOLON .)
    DO              reduce using rule 48 (stm -> RETURN SEMICOLON .)
    FOR             reduce using rule 48 (stm -> RETURN SEMICOLON .)
    IF              reduce using rule 48 (stm -> RETURN SEMICOLON .)
    SEMICOLON       reduce using rule 48 (stm -> RETURN SEMICOLON .)
    RETURN          reduce using rule 48 (stm -> RETURN SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 48 (stm -> RETURN SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 48 (stm -> RETURN SEMICOLON .)
    INT_NUMBER      reduce using rule 48 (stm -> RETURN SEMICOLON .)
    STRING          reduce using rule 48 (stm -> RETURN SEMICOLON .)
    ID              reduce using rule 48 (stm -> RETURN SEMICOLON .)
    NEW             reduce using rule 48 (stm -> RETURN SEMICOLON .)
    STATIC          reduce using rule 48 (stm -> RETURN SEMICOLON .)
    FINAL           reduce using rule 48 (stm -> RETURN SEMICOLON .)
    INCREMENT       reduce using rule 48 (stm -> RETURN SEMICOLON .)
    DECREMENT       reduce using rule 48 (stm -> RETURN SEMICOLON .)
    MINUS           reduce using rule 48 (stm -> RETURN SEMICOLON .)
    PLUS            reduce using rule 48 (stm -> RETURN SEMICOLON .)
    NOT             reduce using rule 48 (stm -> RETURN SEMICOLON .)
    TYPE_INT        reduce using rule 48 (stm -> RETURN SEMICOLON .)
    TYPE_FLOAT      reduce using rule 48 (stm -> RETURN SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 48 (stm -> RETURN SEMICOLON .)
    TYPE_BYTE       reduce using rule 48 (stm -> RETURN SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 48 (stm -> RETURN SEMICOLON .)
    TYPE_CHAR       reduce using rule 48 (stm -> RETURN SEMICOLON .)
    TYPE_STRING     reduce using rule 48 (stm -> RETURN SEMICOLON .)
    TYPE_LONG       reduce using rule 48 (stm -> RETURN SEMICOLON .)
    TYPE_VOID       reduce using rule 48 (stm -> RETURN SEMICOLON .)
    RCHAV           reduce using rule 48 (stm -> RETURN SEMICOLON .)


state 121

    (59) expression -> NEW type . LPAREN params_call RPAREN
    (60) expression -> NEW type . LBRACKET expression RBRACKET

    LPAREN          shift and go to state 170
    LBRACKET        shift and go to state 171


state 122

    (89) operator -> unaryoperatorprefx ID .

    SEMICOLON       reduce using rule 89 (operator -> unaryoperatorprefx ID .)
    TIMES           reduce using rule 89 (operator -> unaryoperatorprefx ID .)
    DIVIDE          reduce using rule 89 (operator -> unaryoperatorprefx ID .)
    MODULE          reduce using rule 89 (operator -> unaryoperatorprefx ID .)
    PLUS            reduce using rule 89 (operator -> unaryoperatorprefx ID .)
    MINUS           reduce using rule 89 (operator -> unaryoperatorprefx ID .)
    LEQ             reduce using rule 89 (operator -> unaryoperatorprefx ID .)
    GEQ             reduce using rule 89 (operator -> unaryoperatorprefx ID .)
    LT              reduce using rule 89 (operator -> unaryoperatorprefx ID .)
    GT              reduce using rule 89 (operator -> unaryoperatorprefx ID .)
    NEQ             reduce using rule 89 (operator -> unaryoperatorprefx ID .)
    EQ              reduce using rule 89 (operator -> unaryoperatorprefx ID .)
    AND             reduce using rule 89 (operator -> unaryoperatorprefx ID .)
    OR              reduce using rule 89 (operator -> unaryoperatorprefx ID .)
    BITWISE_AND     reduce using rule 89 (operator -> unaryoperatorprefx ID .)
    BITWISE_OR      reduce using rule 89 (operator -> unaryoperatorprefx ID .)
    BITWISE_XOR     reduce using rule 89 (operator -> unaryoperatorprefx ID .)
    URSHIFT         reduce using rule 89 (operator -> unaryoperatorprefx ID .)
    LSHIFT          reduce using rule 89 (operator -> unaryoperatorprefx ID .)
    RSHIFT          reduce using rule 89 (operator -> unaryoperatorprefx ID .)
    RPAREN          reduce using rule 89 (operator -> unaryoperatorprefx ID .)
    COMMA           reduce using rule 89 (operator -> unaryoperatorprefx ID .)
    RBRACKET        reduce using rule 89 (operator -> unaryoperatorprefx ID .)
    RCHAV           reduce using rule 89 (operator -> unaryoperatorprefx ID .)


state 123

    (17) atribute -> visibility atributemodifier type ID SEMICOLON .

    PUBLIC          reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    PRIVATE         reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    PROTECTED       reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    STATIC          reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    FINAL           reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_INT        reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_FLOAT      reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_BYTE       reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_CHAR       reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_STRING     reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_LONG       reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_VOID       reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    RCHAV           reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)


state 124

    (18) atribute -> visibility atributemodifier type ID EQUAL . expression SEMICOLON
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 172
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 125

    (23) signature -> visibility atributemodifier type ID LPAREN . sigparams RPAREN
    (25) sigparams -> . type ID
    (26) sigparams -> . type ID COMMA sigparams
    (105) type -> . primitivetypes
    (106) primitivetypes -> . TYPE_INT
    (107) primitivetypes -> . TYPE_FLOAT
    (108) primitivetypes -> . TYPE_DOUBLE
    (109) primitivetypes -> . TYPE_BYTE
    (110) primitivetypes -> . TYPE_BOOLEAN
    (111) primitivetypes -> . TYPE_CHAR
    (112) primitivetypes -> . TYPE_STRING
    (113) primitivetypes -> . TYPE_LONG
    (114) primitivetypes -> . TYPE_VOID

    TYPE_INT        shift and go to state 36
    TYPE_FLOAT      shift and go to state 37
    TYPE_DOUBLE     shift and go to state 38
    TYPE_BYTE       shift and go to state 39
    TYPE_BOOLEAN    shift and go to state 40
    TYPE_CHAR       shift and go to state 41
    TYPE_STRING     shift and go to state 42
    TYPE_LONG       shift and go to state 43
    TYPE_VOID       shift and go to state 44

    type                           shift and go to state 173
    sigparams                      shift and go to state 174
    primitivetypes                 shift and go to state 35

state 126

    (24) signature -> visibility atributemodifier type brackets_expression ID . LPAREN sigparams RPAREN

    LPAREN          shift and go to state 175


state 127

    (102) brackets_expression -> LBRACKET RBRACKET .

    ID              reduce using rule 102 (brackets_expression -> LBRACKET RBRACKET .)


state 128

    (103) brackets_expression -> LBRACKET INT_NUMBER . RBRACKET

    RBRACKET        shift and go to state 176


state 129

    (104) brackets_expression -> LBRACKET ID . RBRACKET

    RBRACKET        shift and go to state 177


state 130

    (61) operator -> expression TIMES expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 61 (operator -> expression TIMES expression .)
    TIMES           reduce using rule 61 (operator -> expression TIMES expression .)
    DIVIDE          reduce using rule 61 (operator -> expression TIMES expression .)
    MODULE          reduce using rule 61 (operator -> expression TIMES expression .)
    PLUS            reduce using rule 61 (operator -> expression TIMES expression .)
    MINUS           reduce using rule 61 (operator -> expression TIMES expression .)
    LEQ             reduce using rule 61 (operator -> expression TIMES expression .)
    GEQ             reduce using rule 61 (operator -> expression TIMES expression .)
    LT              reduce using rule 61 (operator -> expression TIMES expression .)
    GT              reduce using rule 61 (operator -> expression TIMES expression .)
    NEQ             reduce using rule 61 (operator -> expression TIMES expression .)
    EQ              reduce using rule 61 (operator -> expression TIMES expression .)
    AND             reduce using rule 61 (operator -> expression TIMES expression .)
    OR              reduce using rule 61 (operator -> expression TIMES expression .)
    BITWISE_AND     reduce using rule 61 (operator -> expression TIMES expression .)
    BITWISE_OR      reduce using rule 61 (operator -> expression TIMES expression .)
    BITWISE_XOR     reduce using rule 61 (operator -> expression TIMES expression .)
    URSHIFT         reduce using rule 61 (operator -> expression TIMES expression .)
    LSHIFT          reduce using rule 61 (operator -> expression TIMES expression .)
    RSHIFT          reduce using rule 61 (operator -> expression TIMES expression .)
    RPAREN          reduce using rule 61 (operator -> expression TIMES expression .)
    COMMA           reduce using rule 61 (operator -> expression TIMES expression .)
    RBRACKET        reduce using rule 61 (operator -> expression TIMES expression .)
    RCHAV           reduce using rule 61 (operator -> expression TIMES expression .)

  ! TIMES           [ shift and go to state 77 ]
  ! DIVIDE          [ shift and go to state 78 ]
  ! MODULE          [ shift and go to state 79 ]
  ! PLUS            [ shift and go to state 80 ]
  ! MINUS           [ shift and go to state 81 ]
  ! LEQ             [ shift and go to state 82 ]
  ! GEQ             [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! GT              [ shift and go to state 85 ]
  ! NEQ             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 87 ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]
  ! BITWISE_XOR     [ shift and go to state 92 ]
  ! URSHIFT         [ shift and go to state 94 ]
  ! LSHIFT          [ shift and go to state 95 ]
  ! RSHIFT          [ shift and go to state 96 ]

    operatorbittobit               shift and go to state 93

state 131

    (62) operator -> expression DIVIDE expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 62 (operator -> expression DIVIDE expression .)
    TIMES           reduce using rule 62 (operator -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 62 (operator -> expression DIVIDE expression .)
    MODULE          reduce using rule 62 (operator -> expression DIVIDE expression .)
    PLUS            reduce using rule 62 (operator -> expression DIVIDE expression .)
    MINUS           reduce using rule 62 (operator -> expression DIVIDE expression .)
    LEQ             reduce using rule 62 (operator -> expression DIVIDE expression .)
    GEQ             reduce using rule 62 (operator -> expression DIVIDE expression .)
    LT              reduce using rule 62 (operator -> expression DIVIDE expression .)
    GT              reduce using rule 62 (operator -> expression DIVIDE expression .)
    NEQ             reduce using rule 62 (operator -> expression DIVIDE expression .)
    EQ              reduce using rule 62 (operator -> expression DIVIDE expression .)
    AND             reduce using rule 62 (operator -> expression DIVIDE expression .)
    OR              reduce using rule 62 (operator -> expression DIVIDE expression .)
    BITWISE_AND     reduce using rule 62 (operator -> expression DIVIDE expression .)
    BITWISE_OR      reduce using rule 62 (operator -> expression DIVIDE expression .)
    BITWISE_XOR     reduce using rule 62 (operator -> expression DIVIDE expression .)
    URSHIFT         reduce using rule 62 (operator -> expression DIVIDE expression .)
    LSHIFT          reduce using rule 62 (operator -> expression DIVIDE expression .)
    RSHIFT          reduce using rule 62 (operator -> expression DIVIDE expression .)
    RPAREN          reduce using rule 62 (operator -> expression DIVIDE expression .)
    COMMA           reduce using rule 62 (operator -> expression DIVIDE expression .)
    RBRACKET        reduce using rule 62 (operator -> expression DIVIDE expression .)
    RCHAV           reduce using rule 62 (operator -> expression DIVIDE expression .)

  ! TIMES           [ shift and go to state 77 ]
  ! DIVIDE          [ shift and go to state 78 ]
  ! MODULE          [ shift and go to state 79 ]
  ! PLUS            [ shift and go to state 80 ]
  ! MINUS           [ shift and go to state 81 ]
  ! LEQ             [ shift and go to state 82 ]
  ! GEQ             [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! GT              [ shift and go to state 85 ]
  ! NEQ             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 87 ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]
  ! BITWISE_XOR     [ shift and go to state 92 ]
  ! URSHIFT         [ shift and go to state 94 ]
  ! LSHIFT          [ shift and go to state 95 ]
  ! RSHIFT          [ shift and go to state 96 ]

    operatorbittobit               shift and go to state 93

state 132

    (63) operator -> expression MODULE expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 63 (operator -> expression MODULE expression .)
    TIMES           reduce using rule 63 (operator -> expression MODULE expression .)
    DIVIDE          reduce using rule 63 (operator -> expression MODULE expression .)
    MODULE          reduce using rule 63 (operator -> expression MODULE expression .)
    PLUS            reduce using rule 63 (operator -> expression MODULE expression .)
    MINUS           reduce using rule 63 (operator -> expression MODULE expression .)
    LEQ             reduce using rule 63 (operator -> expression MODULE expression .)
    GEQ             reduce using rule 63 (operator -> expression MODULE expression .)
    LT              reduce using rule 63 (operator -> expression MODULE expression .)
    GT              reduce using rule 63 (operator -> expression MODULE expression .)
    NEQ             reduce using rule 63 (operator -> expression MODULE expression .)
    EQ              reduce using rule 63 (operator -> expression MODULE expression .)
    AND             reduce using rule 63 (operator -> expression MODULE expression .)
    OR              reduce using rule 63 (operator -> expression MODULE expression .)
    BITWISE_AND     reduce using rule 63 (operator -> expression MODULE expression .)
    BITWISE_OR      reduce using rule 63 (operator -> expression MODULE expression .)
    BITWISE_XOR     reduce using rule 63 (operator -> expression MODULE expression .)
    URSHIFT         reduce using rule 63 (operator -> expression MODULE expression .)
    LSHIFT          reduce using rule 63 (operator -> expression MODULE expression .)
    RSHIFT          reduce using rule 63 (operator -> expression MODULE expression .)
    RPAREN          reduce using rule 63 (operator -> expression MODULE expression .)
    COMMA           reduce using rule 63 (operator -> expression MODULE expression .)
    RBRACKET        reduce using rule 63 (operator -> expression MODULE expression .)
    RCHAV           reduce using rule 63 (operator -> expression MODULE expression .)

  ! TIMES           [ shift and go to state 77 ]
  ! DIVIDE          [ shift and go to state 78 ]
  ! MODULE          [ shift and go to state 79 ]
  ! PLUS            [ shift and go to state 80 ]
  ! MINUS           [ shift and go to state 81 ]
  ! LEQ             [ shift and go to state 82 ]
  ! GEQ             [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! GT              [ shift and go to state 85 ]
  ! NEQ             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 87 ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]
  ! BITWISE_XOR     [ shift and go to state 92 ]
  ! URSHIFT         [ shift and go to state 94 ]
  ! LSHIFT          [ shift and go to state 95 ]
  ! RSHIFT          [ shift and go to state 96 ]

    operatorbittobit               shift and go to state 93

state 133

    (64) operator -> expression PLUS expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 64 (operator -> expression PLUS expression .)
    PLUS            reduce using rule 64 (operator -> expression PLUS expression .)
    MINUS           reduce using rule 64 (operator -> expression PLUS expression .)
    LEQ             reduce using rule 64 (operator -> expression PLUS expression .)
    GEQ             reduce using rule 64 (operator -> expression PLUS expression .)
    LT              reduce using rule 64 (operator -> expression PLUS expression .)
    GT              reduce using rule 64 (operator -> expression PLUS expression .)
    NEQ             reduce using rule 64 (operator -> expression PLUS expression .)
    EQ              reduce using rule 64 (operator -> expression PLUS expression .)
    AND             reduce using rule 64 (operator -> expression PLUS expression .)
    OR              reduce using rule 64 (operator -> expression PLUS expression .)
    BITWISE_AND     reduce using rule 64 (operator -> expression PLUS expression .)
    BITWISE_OR      reduce using rule 64 (operator -> expression PLUS expression .)
    BITWISE_XOR     reduce using rule 64 (operator -> expression PLUS expression .)
    URSHIFT         reduce using rule 64 (operator -> expression PLUS expression .)
    LSHIFT          reduce using rule 64 (operator -> expression PLUS expression .)
    RSHIFT          reduce using rule 64 (operator -> expression PLUS expression .)
    RPAREN          reduce using rule 64 (operator -> expression PLUS expression .)
    COMMA           reduce using rule 64 (operator -> expression PLUS expression .)
    RBRACKET        reduce using rule 64 (operator -> expression PLUS expression .)
    RCHAV           reduce using rule 64 (operator -> expression PLUS expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79

  ! TIMES           [ reduce using rule 64 (operator -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 64 (operator -> expression PLUS expression .) ]
  ! MODULE          [ reduce using rule 64 (operator -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 80 ]
  ! MINUS           [ shift and go to state 81 ]
  ! LEQ             [ shift and go to state 82 ]
  ! GEQ             [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! GT              [ shift and go to state 85 ]
  ! NEQ             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 87 ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]
  ! BITWISE_XOR     [ shift and go to state 92 ]
  ! URSHIFT         [ shift and go to state 94 ]
  ! LSHIFT          [ shift and go to state 95 ]
  ! RSHIFT          [ shift and go to state 96 ]

    operatorbittobit               shift and go to state 93

state 134

    (65) operator -> expression MINUS expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 65 (operator -> expression MINUS expression .)
    PLUS            reduce using rule 65 (operator -> expression MINUS expression .)
    MINUS           reduce using rule 65 (operator -> expression MINUS expression .)
    LEQ             reduce using rule 65 (operator -> expression MINUS expression .)
    GEQ             reduce using rule 65 (operator -> expression MINUS expression .)
    LT              reduce using rule 65 (operator -> expression MINUS expression .)
    GT              reduce using rule 65 (operator -> expression MINUS expression .)
    NEQ             reduce using rule 65 (operator -> expression MINUS expression .)
    EQ              reduce using rule 65 (operator -> expression MINUS expression .)
    AND             reduce using rule 65 (operator -> expression MINUS expression .)
    OR              reduce using rule 65 (operator -> expression MINUS expression .)
    BITWISE_AND     reduce using rule 65 (operator -> expression MINUS expression .)
    BITWISE_OR      reduce using rule 65 (operator -> expression MINUS expression .)
    BITWISE_XOR     reduce using rule 65 (operator -> expression MINUS expression .)
    URSHIFT         reduce using rule 65 (operator -> expression MINUS expression .)
    LSHIFT          reduce using rule 65 (operator -> expression MINUS expression .)
    RSHIFT          reduce using rule 65 (operator -> expression MINUS expression .)
    RPAREN          reduce using rule 65 (operator -> expression MINUS expression .)
    COMMA           reduce using rule 65 (operator -> expression MINUS expression .)
    RBRACKET        reduce using rule 65 (operator -> expression MINUS expression .)
    RCHAV           reduce using rule 65 (operator -> expression MINUS expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79

  ! TIMES           [ reduce using rule 65 (operator -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 65 (operator -> expression MINUS expression .) ]
  ! MODULE          [ reduce using rule 65 (operator -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 80 ]
  ! MINUS           [ shift and go to state 81 ]
  ! LEQ             [ shift and go to state 82 ]
  ! GEQ             [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! GT              [ shift and go to state 85 ]
  ! NEQ             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 87 ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]
  ! BITWISE_XOR     [ shift and go to state 92 ]
  ! URSHIFT         [ shift and go to state 94 ]
  ! LSHIFT          [ shift and go to state 95 ]
  ! RSHIFT          [ shift and go to state 96 ]

    operatorbittobit               shift and go to state 93

state 135

    (78) operator -> expression LEQ expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 78 (operator -> expression LEQ expression .)
    LEQ             reduce using rule 78 (operator -> expression LEQ expression .)
    GEQ             reduce using rule 78 (operator -> expression LEQ expression .)
    LT              reduce using rule 78 (operator -> expression LEQ expression .)
    GT              reduce using rule 78 (operator -> expression LEQ expression .)
    NEQ             reduce using rule 78 (operator -> expression LEQ expression .)
    EQ              reduce using rule 78 (operator -> expression LEQ expression .)
    AND             reduce using rule 78 (operator -> expression LEQ expression .)
    OR              reduce using rule 78 (operator -> expression LEQ expression .)
    BITWISE_AND     reduce using rule 78 (operator -> expression LEQ expression .)
    BITWISE_OR      reduce using rule 78 (operator -> expression LEQ expression .)
    BITWISE_XOR     reduce using rule 78 (operator -> expression LEQ expression .)
    RPAREN          reduce using rule 78 (operator -> expression LEQ expression .)
    COMMA           reduce using rule 78 (operator -> expression LEQ expression .)
    RBRACKET        reduce using rule 78 (operator -> expression LEQ expression .)
    RCHAV           reduce using rule 78 (operator -> expression LEQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 78 (operator -> expression LEQ expression .) ]
  ! DIVIDE          [ reduce using rule 78 (operator -> expression LEQ expression .) ]
  ! MODULE          [ reduce using rule 78 (operator -> expression LEQ expression .) ]
  ! PLUS            [ reduce using rule 78 (operator -> expression LEQ expression .) ]
  ! MINUS           [ reduce using rule 78 (operator -> expression LEQ expression .) ]
  ! URSHIFT         [ reduce using rule 78 (operator -> expression LEQ expression .) ]
  ! LSHIFT          [ reduce using rule 78 (operator -> expression LEQ expression .) ]
  ! RSHIFT          [ reduce using rule 78 (operator -> expression LEQ expression .) ]
  ! LEQ             [ shift and go to state 82 ]
  ! GEQ             [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! GT              [ shift and go to state 85 ]
  ! NEQ             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 87 ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]
  ! BITWISE_XOR     [ shift and go to state 92 ]

    operatorbittobit               shift and go to state 93

state 136

    (79) operator -> expression GEQ expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 79 (operator -> expression GEQ expression .)
    LEQ             reduce using rule 79 (operator -> expression GEQ expression .)
    GEQ             reduce using rule 79 (operator -> expression GEQ expression .)
    LT              reduce using rule 79 (operator -> expression GEQ expression .)
    GT              reduce using rule 79 (operator -> expression GEQ expression .)
    NEQ             reduce using rule 79 (operator -> expression GEQ expression .)
    EQ              reduce using rule 79 (operator -> expression GEQ expression .)
    AND             reduce using rule 79 (operator -> expression GEQ expression .)
    OR              reduce using rule 79 (operator -> expression GEQ expression .)
    BITWISE_AND     reduce using rule 79 (operator -> expression GEQ expression .)
    BITWISE_OR      reduce using rule 79 (operator -> expression GEQ expression .)
    BITWISE_XOR     reduce using rule 79 (operator -> expression GEQ expression .)
    RPAREN          reduce using rule 79 (operator -> expression GEQ expression .)
    COMMA           reduce using rule 79 (operator -> expression GEQ expression .)
    RBRACKET        reduce using rule 79 (operator -> expression GEQ expression .)
    RCHAV           reduce using rule 79 (operator -> expression GEQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 79 (operator -> expression GEQ expression .) ]
  ! DIVIDE          [ reduce using rule 79 (operator -> expression GEQ expression .) ]
  ! MODULE          [ reduce using rule 79 (operator -> expression GEQ expression .) ]
  ! PLUS            [ reduce using rule 79 (operator -> expression GEQ expression .) ]
  ! MINUS           [ reduce using rule 79 (operator -> expression GEQ expression .) ]
  ! URSHIFT         [ reduce using rule 79 (operator -> expression GEQ expression .) ]
  ! LSHIFT          [ reduce using rule 79 (operator -> expression GEQ expression .) ]
  ! RSHIFT          [ reduce using rule 79 (operator -> expression GEQ expression .) ]
  ! LEQ             [ shift and go to state 82 ]
  ! GEQ             [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! GT              [ shift and go to state 85 ]
  ! NEQ             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 87 ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]
  ! BITWISE_XOR     [ shift and go to state 92 ]

    operatorbittobit               shift and go to state 93

state 137

    (80) operator -> expression LT expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 80 (operator -> expression LT expression .)
    LEQ             reduce using rule 80 (operator -> expression LT expression .)
    GEQ             reduce using rule 80 (operator -> expression LT expression .)
    LT              reduce using rule 80 (operator -> expression LT expression .)
    GT              reduce using rule 80 (operator -> expression LT expression .)
    NEQ             reduce using rule 80 (operator -> expression LT expression .)
    EQ              reduce using rule 80 (operator -> expression LT expression .)
    AND             reduce using rule 80 (operator -> expression LT expression .)
    OR              reduce using rule 80 (operator -> expression LT expression .)
    BITWISE_AND     reduce using rule 80 (operator -> expression LT expression .)
    BITWISE_OR      reduce using rule 80 (operator -> expression LT expression .)
    BITWISE_XOR     reduce using rule 80 (operator -> expression LT expression .)
    RPAREN          reduce using rule 80 (operator -> expression LT expression .)
    COMMA           reduce using rule 80 (operator -> expression LT expression .)
    RBRACKET        reduce using rule 80 (operator -> expression LT expression .)
    RCHAV           reduce using rule 80 (operator -> expression LT expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 80 (operator -> expression LT expression .) ]
  ! DIVIDE          [ reduce using rule 80 (operator -> expression LT expression .) ]
  ! MODULE          [ reduce using rule 80 (operator -> expression LT expression .) ]
  ! PLUS            [ reduce using rule 80 (operator -> expression LT expression .) ]
  ! MINUS           [ reduce using rule 80 (operator -> expression LT expression .) ]
  ! URSHIFT         [ reduce using rule 80 (operator -> expression LT expression .) ]
  ! LSHIFT          [ reduce using rule 80 (operator -> expression LT expression .) ]
  ! RSHIFT          [ reduce using rule 80 (operator -> expression LT expression .) ]
  ! LEQ             [ shift and go to state 82 ]
  ! GEQ             [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! GT              [ shift and go to state 85 ]
  ! NEQ             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 87 ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]
  ! BITWISE_XOR     [ shift and go to state 92 ]

    operatorbittobit               shift and go to state 93

state 138

    (81) operator -> expression GT expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 81 (operator -> expression GT expression .)
    LEQ             reduce using rule 81 (operator -> expression GT expression .)
    GEQ             reduce using rule 81 (operator -> expression GT expression .)
    LT              reduce using rule 81 (operator -> expression GT expression .)
    GT              reduce using rule 81 (operator -> expression GT expression .)
    NEQ             reduce using rule 81 (operator -> expression GT expression .)
    EQ              reduce using rule 81 (operator -> expression GT expression .)
    AND             reduce using rule 81 (operator -> expression GT expression .)
    OR              reduce using rule 81 (operator -> expression GT expression .)
    BITWISE_AND     reduce using rule 81 (operator -> expression GT expression .)
    BITWISE_OR      reduce using rule 81 (operator -> expression GT expression .)
    BITWISE_XOR     reduce using rule 81 (operator -> expression GT expression .)
    RPAREN          reduce using rule 81 (operator -> expression GT expression .)
    COMMA           reduce using rule 81 (operator -> expression GT expression .)
    RBRACKET        reduce using rule 81 (operator -> expression GT expression .)
    RCHAV           reduce using rule 81 (operator -> expression GT expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 81 (operator -> expression GT expression .) ]
  ! DIVIDE          [ reduce using rule 81 (operator -> expression GT expression .) ]
  ! MODULE          [ reduce using rule 81 (operator -> expression GT expression .) ]
  ! PLUS            [ reduce using rule 81 (operator -> expression GT expression .) ]
  ! MINUS           [ reduce using rule 81 (operator -> expression GT expression .) ]
  ! URSHIFT         [ reduce using rule 81 (operator -> expression GT expression .) ]
  ! LSHIFT          [ reduce using rule 81 (operator -> expression GT expression .) ]
  ! RSHIFT          [ reduce using rule 81 (operator -> expression GT expression .) ]
  ! LEQ             [ shift and go to state 82 ]
  ! GEQ             [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! GT              [ shift and go to state 85 ]
  ! NEQ             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 87 ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]
  ! BITWISE_XOR     [ shift and go to state 92 ]

    operatorbittobit               shift and go to state 93

state 139

    (82) operator -> expression NEQ expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 82 (operator -> expression NEQ expression .)
    NEQ             reduce using rule 82 (operator -> expression NEQ expression .)
    EQ              reduce using rule 82 (operator -> expression NEQ expression .)
    AND             reduce using rule 82 (operator -> expression NEQ expression .)
    OR              reduce using rule 82 (operator -> expression NEQ expression .)
    BITWISE_AND     reduce using rule 82 (operator -> expression NEQ expression .)
    BITWISE_OR      reduce using rule 82 (operator -> expression NEQ expression .)
    BITWISE_XOR     reduce using rule 82 (operator -> expression NEQ expression .)
    RPAREN          reduce using rule 82 (operator -> expression NEQ expression .)
    COMMA           reduce using rule 82 (operator -> expression NEQ expression .)
    RBRACKET        reduce using rule 82 (operator -> expression NEQ expression .)
    RCHAV           reduce using rule 82 (operator -> expression NEQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 82 (operator -> expression NEQ expression .) ]
  ! DIVIDE          [ reduce using rule 82 (operator -> expression NEQ expression .) ]
  ! MODULE          [ reduce using rule 82 (operator -> expression NEQ expression .) ]
  ! PLUS            [ reduce using rule 82 (operator -> expression NEQ expression .) ]
  ! MINUS           [ reduce using rule 82 (operator -> expression NEQ expression .) ]
  ! LEQ             [ reduce using rule 82 (operator -> expression NEQ expression .) ]
  ! GEQ             [ reduce using rule 82 (operator -> expression NEQ expression .) ]
  ! LT              [ reduce using rule 82 (operator -> expression NEQ expression .) ]
  ! GT              [ reduce using rule 82 (operator -> expression NEQ expression .) ]
  ! URSHIFT         [ reduce using rule 82 (operator -> expression NEQ expression .) ]
  ! LSHIFT          [ reduce using rule 82 (operator -> expression NEQ expression .) ]
  ! RSHIFT          [ reduce using rule 82 (operator -> expression NEQ expression .) ]
  ! NEQ             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 87 ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]
  ! BITWISE_XOR     [ shift and go to state 92 ]

    operatorbittobit               shift and go to state 93

state 140

    (83) operator -> expression EQ expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 83 (operator -> expression EQ expression .)
    NEQ             reduce using rule 83 (operator -> expression EQ expression .)
    EQ              reduce using rule 83 (operator -> expression EQ expression .)
    AND             reduce using rule 83 (operator -> expression EQ expression .)
    OR              reduce using rule 83 (operator -> expression EQ expression .)
    BITWISE_AND     reduce using rule 83 (operator -> expression EQ expression .)
    BITWISE_OR      reduce using rule 83 (operator -> expression EQ expression .)
    BITWISE_XOR     reduce using rule 83 (operator -> expression EQ expression .)
    RPAREN          reduce using rule 83 (operator -> expression EQ expression .)
    COMMA           reduce using rule 83 (operator -> expression EQ expression .)
    RBRACKET        reduce using rule 83 (operator -> expression EQ expression .)
    RCHAV           reduce using rule 83 (operator -> expression EQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 83 (operator -> expression EQ expression .) ]
  ! DIVIDE          [ reduce using rule 83 (operator -> expression EQ expression .) ]
  ! MODULE          [ reduce using rule 83 (operator -> expression EQ expression .) ]
  ! PLUS            [ reduce using rule 83 (operator -> expression EQ expression .) ]
  ! MINUS           [ reduce using rule 83 (operator -> expression EQ expression .) ]
  ! LEQ             [ reduce using rule 83 (operator -> expression EQ expression .) ]
  ! GEQ             [ reduce using rule 83 (operator -> expression EQ expression .) ]
  ! LT              [ reduce using rule 83 (operator -> expression EQ expression .) ]
  ! GT              [ reduce using rule 83 (operator -> expression EQ expression .) ]
  ! URSHIFT         [ reduce using rule 83 (operator -> expression EQ expression .) ]
  ! LSHIFT          [ reduce using rule 83 (operator -> expression EQ expression .) ]
  ! RSHIFT          [ reduce using rule 83 (operator -> expression EQ expression .) ]
  ! NEQ             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 87 ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]
  ! BITWISE_XOR     [ shift and go to state 92 ]

    operatorbittobit               shift and go to state 93

state 141

    (84) operator -> expression AND expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 84 (operator -> expression AND expression .)
    AND             reduce using rule 84 (operator -> expression AND expression .)
    OR              reduce using rule 84 (operator -> expression AND expression .)
    RPAREN          reduce using rule 84 (operator -> expression AND expression .)
    COMMA           reduce using rule 84 (operator -> expression AND expression .)
    RBRACKET        reduce using rule 84 (operator -> expression AND expression .)
    RCHAV           reduce using rule 84 (operator -> expression AND expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 84 (operator -> expression AND expression .) ]
  ! DIVIDE          [ reduce using rule 84 (operator -> expression AND expression .) ]
  ! MODULE          [ reduce using rule 84 (operator -> expression AND expression .) ]
  ! PLUS            [ reduce using rule 84 (operator -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 84 (operator -> expression AND expression .) ]
  ! LEQ             [ reduce using rule 84 (operator -> expression AND expression .) ]
  ! GEQ             [ reduce using rule 84 (operator -> expression AND expression .) ]
  ! LT              [ reduce using rule 84 (operator -> expression AND expression .) ]
  ! GT              [ reduce using rule 84 (operator -> expression AND expression .) ]
  ! NEQ             [ reduce using rule 84 (operator -> expression AND expression .) ]
  ! EQ              [ reduce using rule 84 (operator -> expression AND expression .) ]
  ! BITWISE_AND     [ reduce using rule 84 (operator -> expression AND expression .) ]
  ! BITWISE_OR      [ reduce using rule 84 (operator -> expression AND expression .) ]
  ! BITWISE_XOR     [ reduce using rule 84 (operator -> expression AND expression .) ]
  ! URSHIFT         [ reduce using rule 84 (operator -> expression AND expression .) ]
  ! LSHIFT          [ reduce using rule 84 (operator -> expression AND expression .) ]
  ! RSHIFT          [ reduce using rule 84 (operator -> expression AND expression .) ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]

    operatorbittobit               shift and go to state 93

state 142

    (85) operator -> expression OR expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 85 (operator -> expression OR expression .)
    OR              reduce using rule 85 (operator -> expression OR expression .)
    RPAREN          reduce using rule 85 (operator -> expression OR expression .)
    COMMA           reduce using rule 85 (operator -> expression OR expression .)
    RBRACKET        reduce using rule 85 (operator -> expression OR expression .)
    RCHAV           reduce using rule 85 (operator -> expression OR expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 85 (operator -> expression OR expression .) ]
  ! DIVIDE          [ reduce using rule 85 (operator -> expression OR expression .) ]
  ! MODULE          [ reduce using rule 85 (operator -> expression OR expression .) ]
  ! PLUS            [ reduce using rule 85 (operator -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 85 (operator -> expression OR expression .) ]
  ! LEQ             [ reduce using rule 85 (operator -> expression OR expression .) ]
  ! GEQ             [ reduce using rule 85 (operator -> expression OR expression .) ]
  ! LT              [ reduce using rule 85 (operator -> expression OR expression .) ]
  ! GT              [ reduce using rule 85 (operator -> expression OR expression .) ]
  ! NEQ             [ reduce using rule 85 (operator -> expression OR expression .) ]
  ! EQ              [ reduce using rule 85 (operator -> expression OR expression .) ]
  ! AND             [ reduce using rule 85 (operator -> expression OR expression .) ]
  ! BITWISE_AND     [ reduce using rule 85 (operator -> expression OR expression .) ]
  ! BITWISE_OR      [ reduce using rule 85 (operator -> expression OR expression .) ]
  ! BITWISE_XOR     [ reduce using rule 85 (operator -> expression OR expression .) ]
  ! URSHIFT         [ reduce using rule 85 (operator -> expression OR expression .) ]
  ! LSHIFT          [ reduce using rule 85 (operator -> expression OR expression .) ]
  ! RSHIFT          [ reduce using rule 85 (operator -> expression OR expression .) ]
  ! OR              [ shift and go to state 89 ]

    operatorbittobit               shift and go to state 93

state 143

    (86) operator -> expression BITWISE_AND expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 86 (operator -> expression BITWISE_AND expression .)
    AND             reduce using rule 86 (operator -> expression BITWISE_AND expression .)
    OR              reduce using rule 86 (operator -> expression BITWISE_AND expression .)
    BITWISE_AND     reduce using rule 86 (operator -> expression BITWISE_AND expression .)
    BITWISE_OR      reduce using rule 86 (operator -> expression BITWISE_AND expression .)
    BITWISE_XOR     reduce using rule 86 (operator -> expression BITWISE_AND expression .)
    RPAREN          reduce using rule 86 (operator -> expression BITWISE_AND expression .)
    COMMA           reduce using rule 86 (operator -> expression BITWISE_AND expression .)
    RBRACKET        reduce using rule 86 (operator -> expression BITWISE_AND expression .)
    RCHAV           reduce using rule 86 (operator -> expression BITWISE_AND expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 86 (operator -> expression BITWISE_AND expression .) ]
  ! DIVIDE          [ reduce using rule 86 (operator -> expression BITWISE_AND expression .) ]
  ! MODULE          [ reduce using rule 86 (operator -> expression BITWISE_AND expression .) ]
  ! PLUS            [ reduce using rule 86 (operator -> expression BITWISE_AND expression .) ]
  ! MINUS           [ reduce using rule 86 (operator -> expression BITWISE_AND expression .) ]
  ! LEQ             [ reduce using rule 86 (operator -> expression BITWISE_AND expression .) ]
  ! GEQ             [ reduce using rule 86 (operator -> expression BITWISE_AND expression .) ]
  ! LT              [ reduce using rule 86 (operator -> expression BITWISE_AND expression .) ]
  ! GT              [ reduce using rule 86 (operator -> expression BITWISE_AND expression .) ]
  ! NEQ             [ reduce using rule 86 (operator -> expression BITWISE_AND expression .) ]
  ! EQ              [ reduce using rule 86 (operator -> expression BITWISE_AND expression .) ]
  ! URSHIFT         [ reduce using rule 86 (operator -> expression BITWISE_AND expression .) ]
  ! LSHIFT          [ reduce using rule 86 (operator -> expression BITWISE_AND expression .) ]
  ! RSHIFT          [ reduce using rule 86 (operator -> expression BITWISE_AND expression .) ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]
  ! BITWISE_XOR     [ shift and go to state 92 ]

    operatorbittobit               shift and go to state 93

state 144

    (87) operator -> expression BITWISE_OR expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 87 (operator -> expression BITWISE_OR expression .)
    AND             reduce using rule 87 (operator -> expression BITWISE_OR expression .)
    OR              reduce using rule 87 (operator -> expression BITWISE_OR expression .)
    BITWISE_OR      reduce using rule 87 (operator -> expression BITWISE_OR expression .)
    RPAREN          reduce using rule 87 (operator -> expression BITWISE_OR expression .)
    COMMA           reduce using rule 87 (operator -> expression BITWISE_OR expression .)
    RBRACKET        reduce using rule 87 (operator -> expression BITWISE_OR expression .)
    RCHAV           reduce using rule 87 (operator -> expression BITWISE_OR expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    BITWISE_AND     shift and go to state 90
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 87 (operator -> expression BITWISE_OR expression .) ]
  ! DIVIDE          [ reduce using rule 87 (operator -> expression BITWISE_OR expression .) ]
  ! MODULE          [ reduce using rule 87 (operator -> expression BITWISE_OR expression .) ]
  ! PLUS            [ reduce using rule 87 (operator -> expression BITWISE_OR expression .) ]
  ! MINUS           [ reduce using rule 87 (operator -> expression BITWISE_OR expression .) ]
  ! LEQ             [ reduce using rule 87 (operator -> expression BITWISE_OR expression .) ]
  ! GEQ             [ reduce using rule 87 (operator -> expression BITWISE_OR expression .) ]
  ! LT              [ reduce using rule 87 (operator -> expression BITWISE_OR expression .) ]
  ! GT              [ reduce using rule 87 (operator -> expression BITWISE_OR expression .) ]
  ! NEQ             [ reduce using rule 87 (operator -> expression BITWISE_OR expression .) ]
  ! EQ              [ reduce using rule 87 (operator -> expression BITWISE_OR expression .) ]
  ! BITWISE_AND     [ reduce using rule 87 (operator -> expression BITWISE_OR expression .) ]
  ! BITWISE_XOR     [ reduce using rule 87 (operator -> expression BITWISE_OR expression .) ]
  ! URSHIFT         [ reduce using rule 87 (operator -> expression BITWISE_OR expression .) ]
  ! LSHIFT          [ reduce using rule 87 (operator -> expression BITWISE_OR expression .) ]
  ! RSHIFT          [ reduce using rule 87 (operator -> expression BITWISE_OR expression .) ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! BITWISE_OR      [ shift and go to state 91 ]

    operatorbittobit               shift and go to state 93

state 145

    (88) operator -> expression BITWISE_XOR expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 88 (operator -> expression BITWISE_XOR expression .)
    AND             reduce using rule 88 (operator -> expression BITWISE_XOR expression .)
    OR              reduce using rule 88 (operator -> expression BITWISE_XOR expression .)
    BITWISE_OR      reduce using rule 88 (operator -> expression BITWISE_XOR expression .)
    BITWISE_XOR     reduce using rule 88 (operator -> expression BITWISE_XOR expression .)
    RPAREN          reduce using rule 88 (operator -> expression BITWISE_XOR expression .)
    COMMA           reduce using rule 88 (operator -> expression BITWISE_XOR expression .)
    RBRACKET        reduce using rule 88 (operator -> expression BITWISE_XOR expression .)
    RCHAV           reduce using rule 88 (operator -> expression BITWISE_XOR expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    BITWISE_AND     shift and go to state 90
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 88 (operator -> expression BITWISE_XOR expression .) ]
  ! DIVIDE          [ reduce using rule 88 (operator -> expression BITWISE_XOR expression .) ]
  ! MODULE          [ reduce using rule 88 (operator -> expression BITWISE_XOR expression .) ]
  ! PLUS            [ reduce using rule 88 (operator -> expression BITWISE_XOR expression .) ]
  ! MINUS           [ reduce using rule 88 (operator -> expression BITWISE_XOR expression .) ]
  ! LEQ             [ reduce using rule 88 (operator -> expression BITWISE_XOR expression .) ]
  ! GEQ             [ reduce using rule 88 (operator -> expression BITWISE_XOR expression .) ]
  ! LT              [ reduce using rule 88 (operator -> expression BITWISE_XOR expression .) ]
  ! GT              [ reduce using rule 88 (operator -> expression BITWISE_XOR expression .) ]
  ! NEQ             [ reduce using rule 88 (operator -> expression BITWISE_XOR expression .) ]
  ! EQ              [ reduce using rule 88 (operator -> expression BITWISE_XOR expression .) ]
  ! BITWISE_AND     [ reduce using rule 88 (operator -> expression BITWISE_XOR expression .) ]
  ! URSHIFT         [ reduce using rule 88 (operator -> expression BITWISE_XOR expression .) ]
  ! LSHIFT          [ reduce using rule 88 (operator -> expression BITWISE_XOR expression .) ]
  ! RSHIFT          [ reduce using rule 88 (operator -> expression BITWISE_XOR expression .) ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! BITWISE_OR      [ shift and go to state 91 ]
  ! BITWISE_XOR     [ shift and go to state 92 ]

    operatorbittobit               shift and go to state 93

state 146

    (31) stm -> WHILE LPAREN expression . RPAREN bodyorstm
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    RPAREN          shift and go to state 178
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

    operatorbittobit               shift and go to state 93

state 147

    (32) stm -> DO bodyorstm WHILE . LPAREN expression RPAREN SEMICOLON

    LPAREN          shift and go to state 179


state 148

    (33) stm -> FOR LPAREN expression_for . SEMICOLON expression SEMICOLON expression RPAREN bodyorstm

    SEMICOLON       shift and go to state 180


state 149

    (50) expression_for -> type . ID EQUAL expression

    ID              shift and go to state 181


state 150

    (51) expression_for -> ID . EQUAL expression

    EQUAL           shift and go to state 182


state 151

    (34) stm -> IF LPAREN expression . RPAREN bodyorstm
    (35) stm -> IF LPAREN expression . RPAREN bodyorstm ELSE bodyorstm
    (36) stm -> IF LPAREN expression . RPAREN bodyorstm ELSE IF bodyorstm
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    RPAREN          shift and go to state 183
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

    operatorbittobit               shift and go to state 93

state 152

    (38) stm -> atributemodifier type ID . SEMICOLON
    (39) stm -> atributemodifier type ID . EQUAL expression SEMICOLON
    (40) stm -> atributemodifier type ID . LBRACKET RBRACKET SEMICOLON
    (43) stm -> atributemodifier type ID . LBRACKET RBRACKET EQUAL expression SEMICOLON
    (44) stm -> atributemodifier type ID . LBRACKET RBRACKET EQUAL chav_exp SEMICOLON

    SEMICOLON       shift and go to state 184
    EQUAL           shift and go to state 185
    LBRACKET        shift and go to state 186


state 153

    (41) stm -> atributemodifier type LBRACKET . RBRACKET ID SEMICOLON
    (42) stm -> atributemodifier type LBRACKET . RBRACKET ID EQUAL chav_exp SEMICOLON
    (45) stm -> atributemodifier type LBRACKET . RBRACKET ID LBRACKET RBRACKET SEMICOLON
    (46) stm -> atributemodifier type LBRACKET . RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON

    RBRACKET        shift and go to state 187


state 154

    (66) operator -> ID EQUAL expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 66 (operator -> ID EQUAL expression .)
    RPAREN          reduce using rule 66 (operator -> ID EQUAL expression .)
    COMMA           reduce using rule 66 (operator -> ID EQUAL expression .)
    RBRACKET        reduce using rule 66 (operator -> ID EQUAL expression .)
    RCHAV           reduce using rule 66 (operator -> ID EQUAL expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 66 (operator -> ID EQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 66 (operator -> ID EQUAL expression .) ]
  ! MODULE          [ reduce using rule 66 (operator -> ID EQUAL expression .) ]
  ! PLUS            [ reduce using rule 66 (operator -> ID EQUAL expression .) ]
  ! MINUS           [ reduce using rule 66 (operator -> ID EQUAL expression .) ]
  ! LEQ             [ reduce using rule 66 (operator -> ID EQUAL expression .) ]
  ! GEQ             [ reduce using rule 66 (operator -> ID EQUAL expression .) ]
  ! LT              [ reduce using rule 66 (operator -> ID EQUAL expression .) ]
  ! GT              [ reduce using rule 66 (operator -> ID EQUAL expression .) ]
  ! NEQ             [ reduce using rule 66 (operator -> ID EQUAL expression .) ]
  ! EQ              [ reduce using rule 66 (operator -> ID EQUAL expression .) ]
  ! AND             [ reduce using rule 66 (operator -> ID EQUAL expression .) ]
  ! OR              [ reduce using rule 66 (operator -> ID EQUAL expression .) ]
  ! BITWISE_AND     [ reduce using rule 66 (operator -> ID EQUAL expression .) ]
  ! BITWISE_OR      [ reduce using rule 66 (operator -> ID EQUAL expression .) ]
  ! BITWISE_XOR     [ reduce using rule 66 (operator -> ID EQUAL expression .) ]
  ! URSHIFT         [ reduce using rule 66 (operator -> ID EQUAL expression .) ]
  ! LSHIFT          [ reduce using rule 66 (operator -> ID EQUAL expression .) ]
  ! RSHIFT          [ reduce using rule 66 (operator -> ID EQUAL expression .) ]

    operatorbittobit               shift and go to state 93

state 155

    (67) operator -> ID MINUS_EQ expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 67 (operator -> ID MINUS_EQ expression .)
    RPAREN          reduce using rule 67 (operator -> ID MINUS_EQ expression .)
    COMMA           reduce using rule 67 (operator -> ID MINUS_EQ expression .)
    RBRACKET        reduce using rule 67 (operator -> ID MINUS_EQ expression .)
    RCHAV           reduce using rule 67 (operator -> ID MINUS_EQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 67 (operator -> ID MINUS_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 67 (operator -> ID MINUS_EQ expression .) ]
  ! MODULE          [ reduce using rule 67 (operator -> ID MINUS_EQ expression .) ]
  ! PLUS            [ reduce using rule 67 (operator -> ID MINUS_EQ expression .) ]
  ! MINUS           [ reduce using rule 67 (operator -> ID MINUS_EQ expression .) ]
  ! LEQ             [ reduce using rule 67 (operator -> ID MINUS_EQ expression .) ]
  ! GEQ             [ reduce using rule 67 (operator -> ID MINUS_EQ expression .) ]
  ! LT              [ reduce using rule 67 (operator -> ID MINUS_EQ expression .) ]
  ! GT              [ reduce using rule 67 (operator -> ID MINUS_EQ expression .) ]
  ! NEQ             [ reduce using rule 67 (operator -> ID MINUS_EQ expression .) ]
  ! EQ              [ reduce using rule 67 (operator -> ID MINUS_EQ expression .) ]
  ! AND             [ reduce using rule 67 (operator -> ID MINUS_EQ expression .) ]
  ! OR              [ reduce using rule 67 (operator -> ID MINUS_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 67 (operator -> ID MINUS_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 67 (operator -> ID MINUS_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 67 (operator -> ID MINUS_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 67 (operator -> ID MINUS_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 67 (operator -> ID MINUS_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 67 (operator -> ID MINUS_EQ expression .) ]

    operatorbittobit               shift and go to state 93

state 156

    (68) operator -> ID TIMES_EQ expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 68 (operator -> ID TIMES_EQ expression .)
    RPAREN          reduce using rule 68 (operator -> ID TIMES_EQ expression .)
    COMMA           reduce using rule 68 (operator -> ID TIMES_EQ expression .)
    RBRACKET        reduce using rule 68 (operator -> ID TIMES_EQ expression .)
    RCHAV           reduce using rule 68 (operator -> ID TIMES_EQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 68 (operator -> ID TIMES_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 68 (operator -> ID TIMES_EQ expression .) ]
  ! MODULE          [ reduce using rule 68 (operator -> ID TIMES_EQ expression .) ]
  ! PLUS            [ reduce using rule 68 (operator -> ID TIMES_EQ expression .) ]
  ! MINUS           [ reduce using rule 68 (operator -> ID TIMES_EQ expression .) ]
  ! LEQ             [ reduce using rule 68 (operator -> ID TIMES_EQ expression .) ]
  ! GEQ             [ reduce using rule 68 (operator -> ID TIMES_EQ expression .) ]
  ! LT              [ reduce using rule 68 (operator -> ID TIMES_EQ expression .) ]
  ! GT              [ reduce using rule 68 (operator -> ID TIMES_EQ expression .) ]
  ! NEQ             [ reduce using rule 68 (operator -> ID TIMES_EQ expression .) ]
  ! EQ              [ reduce using rule 68 (operator -> ID TIMES_EQ expression .) ]
  ! AND             [ reduce using rule 68 (operator -> ID TIMES_EQ expression .) ]
  ! OR              [ reduce using rule 68 (operator -> ID TIMES_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 68 (operator -> ID TIMES_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 68 (operator -> ID TIMES_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 68 (operator -> ID TIMES_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 68 (operator -> ID TIMES_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 68 (operator -> ID TIMES_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 68 (operator -> ID TIMES_EQ expression .) ]

    operatorbittobit               shift and go to state 93

state 157

    (69) operator -> ID PLUS_EQ expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 69 (operator -> ID PLUS_EQ expression .)
    RPAREN          reduce using rule 69 (operator -> ID PLUS_EQ expression .)
    COMMA           reduce using rule 69 (operator -> ID PLUS_EQ expression .)
    RBRACKET        reduce using rule 69 (operator -> ID PLUS_EQ expression .)
    RCHAV           reduce using rule 69 (operator -> ID PLUS_EQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 69 (operator -> ID PLUS_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 69 (operator -> ID PLUS_EQ expression .) ]
  ! MODULE          [ reduce using rule 69 (operator -> ID PLUS_EQ expression .) ]
  ! PLUS            [ reduce using rule 69 (operator -> ID PLUS_EQ expression .) ]
  ! MINUS           [ reduce using rule 69 (operator -> ID PLUS_EQ expression .) ]
  ! LEQ             [ reduce using rule 69 (operator -> ID PLUS_EQ expression .) ]
  ! GEQ             [ reduce using rule 69 (operator -> ID PLUS_EQ expression .) ]
  ! LT              [ reduce using rule 69 (operator -> ID PLUS_EQ expression .) ]
  ! GT              [ reduce using rule 69 (operator -> ID PLUS_EQ expression .) ]
  ! NEQ             [ reduce using rule 69 (operator -> ID PLUS_EQ expression .) ]
  ! EQ              [ reduce using rule 69 (operator -> ID PLUS_EQ expression .) ]
  ! AND             [ reduce using rule 69 (operator -> ID PLUS_EQ expression .) ]
  ! OR              [ reduce using rule 69 (operator -> ID PLUS_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 69 (operator -> ID PLUS_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 69 (operator -> ID PLUS_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 69 (operator -> ID PLUS_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 69 (operator -> ID PLUS_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 69 (operator -> ID PLUS_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 69 (operator -> ID PLUS_EQ expression .) ]

    operatorbittobit               shift and go to state 93

state 158

    (70) operator -> ID DIVIDE_EQ expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 70 (operator -> ID DIVIDE_EQ expression .)
    RPAREN          reduce using rule 70 (operator -> ID DIVIDE_EQ expression .)
    COMMA           reduce using rule 70 (operator -> ID DIVIDE_EQ expression .)
    RBRACKET        reduce using rule 70 (operator -> ID DIVIDE_EQ expression .)
    RCHAV           reduce using rule 70 (operator -> ID DIVIDE_EQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 70 (operator -> ID DIVIDE_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 70 (operator -> ID DIVIDE_EQ expression .) ]
  ! MODULE          [ reduce using rule 70 (operator -> ID DIVIDE_EQ expression .) ]
  ! PLUS            [ reduce using rule 70 (operator -> ID DIVIDE_EQ expression .) ]
  ! MINUS           [ reduce using rule 70 (operator -> ID DIVIDE_EQ expression .) ]
  ! LEQ             [ reduce using rule 70 (operator -> ID DIVIDE_EQ expression .) ]
  ! GEQ             [ reduce using rule 70 (operator -> ID DIVIDE_EQ expression .) ]
  ! LT              [ reduce using rule 70 (operator -> ID DIVIDE_EQ expression .) ]
  ! GT              [ reduce using rule 70 (operator -> ID DIVIDE_EQ expression .) ]
  ! NEQ             [ reduce using rule 70 (operator -> ID DIVIDE_EQ expression .) ]
  ! EQ              [ reduce using rule 70 (operator -> ID DIVIDE_EQ expression .) ]
  ! AND             [ reduce using rule 70 (operator -> ID DIVIDE_EQ expression .) ]
  ! OR              [ reduce using rule 70 (operator -> ID DIVIDE_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 70 (operator -> ID DIVIDE_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 70 (operator -> ID DIVIDE_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 70 (operator -> ID DIVIDE_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 70 (operator -> ID DIVIDE_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 70 (operator -> ID DIVIDE_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 70 (operator -> ID DIVIDE_EQ expression .) ]

    operatorbittobit               shift and go to state 93

state 159

    (71) operator -> ID MOD_EQ expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 71 (operator -> ID MOD_EQ expression .)
    RPAREN          reduce using rule 71 (operator -> ID MOD_EQ expression .)
    COMMA           reduce using rule 71 (operator -> ID MOD_EQ expression .)
    RBRACKET        reduce using rule 71 (operator -> ID MOD_EQ expression .)
    RCHAV           reduce using rule 71 (operator -> ID MOD_EQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 71 (operator -> ID MOD_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 71 (operator -> ID MOD_EQ expression .) ]
  ! MODULE          [ reduce using rule 71 (operator -> ID MOD_EQ expression .) ]
  ! PLUS            [ reduce using rule 71 (operator -> ID MOD_EQ expression .) ]
  ! MINUS           [ reduce using rule 71 (operator -> ID MOD_EQ expression .) ]
  ! LEQ             [ reduce using rule 71 (operator -> ID MOD_EQ expression .) ]
  ! GEQ             [ reduce using rule 71 (operator -> ID MOD_EQ expression .) ]
  ! LT              [ reduce using rule 71 (operator -> ID MOD_EQ expression .) ]
  ! GT              [ reduce using rule 71 (operator -> ID MOD_EQ expression .) ]
  ! NEQ             [ reduce using rule 71 (operator -> ID MOD_EQ expression .) ]
  ! EQ              [ reduce using rule 71 (operator -> ID MOD_EQ expression .) ]
  ! AND             [ reduce using rule 71 (operator -> ID MOD_EQ expression .) ]
  ! OR              [ reduce using rule 71 (operator -> ID MOD_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 71 (operator -> ID MOD_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 71 (operator -> ID MOD_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 71 (operator -> ID MOD_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 71 (operator -> ID MOD_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 71 (operator -> ID MOD_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 71 (operator -> ID MOD_EQ expression .) ]

    operatorbittobit               shift and go to state 93

state 160

    (72) operator -> ID BITWISE_AND_EQ expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 72 (operator -> ID BITWISE_AND_EQ expression .)
    RPAREN          reduce using rule 72 (operator -> ID BITWISE_AND_EQ expression .)
    COMMA           reduce using rule 72 (operator -> ID BITWISE_AND_EQ expression .)
    RBRACKET        reduce using rule 72 (operator -> ID BITWISE_AND_EQ expression .)
    RCHAV           reduce using rule 72 (operator -> ID BITWISE_AND_EQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 72 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 72 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! MODULE          [ reduce using rule 72 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! PLUS            [ reduce using rule 72 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! MINUS           [ reduce using rule 72 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! LEQ             [ reduce using rule 72 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! GEQ             [ reduce using rule 72 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! LT              [ reduce using rule 72 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! GT              [ reduce using rule 72 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! NEQ             [ reduce using rule 72 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! EQ              [ reduce using rule 72 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! AND             [ reduce using rule 72 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! OR              [ reduce using rule 72 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 72 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 72 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 72 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 72 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 72 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 72 (operator -> ID BITWISE_AND_EQ expression .) ]

    operatorbittobit               shift and go to state 93

state 161

    (73) operator -> ID BITWISE_OR_EQ expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 73 (operator -> ID BITWISE_OR_EQ expression .)
    RPAREN          reduce using rule 73 (operator -> ID BITWISE_OR_EQ expression .)
    COMMA           reduce using rule 73 (operator -> ID BITWISE_OR_EQ expression .)
    RBRACKET        reduce using rule 73 (operator -> ID BITWISE_OR_EQ expression .)
    RCHAV           reduce using rule 73 (operator -> ID BITWISE_OR_EQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 73 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 73 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! MODULE          [ reduce using rule 73 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! PLUS            [ reduce using rule 73 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! MINUS           [ reduce using rule 73 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! LEQ             [ reduce using rule 73 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! GEQ             [ reduce using rule 73 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! LT              [ reduce using rule 73 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! GT              [ reduce using rule 73 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! NEQ             [ reduce using rule 73 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! EQ              [ reduce using rule 73 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! AND             [ reduce using rule 73 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! OR              [ reduce using rule 73 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 73 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 73 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 73 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 73 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 73 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 73 (operator -> ID BITWISE_OR_EQ expression .) ]

    operatorbittobit               shift and go to state 93

state 162

    (74) operator -> ID BITWISE_XOR_EQ expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 74 (operator -> ID BITWISE_XOR_EQ expression .)
    RPAREN          reduce using rule 74 (operator -> ID BITWISE_XOR_EQ expression .)
    COMMA           reduce using rule 74 (operator -> ID BITWISE_XOR_EQ expression .)
    RBRACKET        reduce using rule 74 (operator -> ID BITWISE_XOR_EQ expression .)
    RCHAV           reduce using rule 74 (operator -> ID BITWISE_XOR_EQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 74 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 74 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! MODULE          [ reduce using rule 74 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! PLUS            [ reduce using rule 74 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! MINUS           [ reduce using rule 74 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! LEQ             [ reduce using rule 74 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! GEQ             [ reduce using rule 74 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! LT              [ reduce using rule 74 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! GT              [ reduce using rule 74 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! NEQ             [ reduce using rule 74 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! EQ              [ reduce using rule 74 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! AND             [ reduce using rule 74 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! OR              [ reduce using rule 74 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 74 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 74 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 74 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 74 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 74 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 74 (operator -> ID BITWISE_XOR_EQ expression .) ]

    operatorbittobit               shift and go to state 93

state 163

    (75) operator -> ID URSHIFT_EQ expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 75 (operator -> ID URSHIFT_EQ expression .)
    RPAREN          reduce using rule 75 (operator -> ID URSHIFT_EQ expression .)
    COMMA           reduce using rule 75 (operator -> ID URSHIFT_EQ expression .)
    RBRACKET        reduce using rule 75 (operator -> ID URSHIFT_EQ expression .)
    RCHAV           reduce using rule 75 (operator -> ID URSHIFT_EQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 75 (operator -> ID URSHIFT_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 75 (operator -> ID URSHIFT_EQ expression .) ]
  ! MODULE          [ reduce using rule 75 (operator -> ID URSHIFT_EQ expression .) ]
  ! PLUS            [ reduce using rule 75 (operator -> ID URSHIFT_EQ expression .) ]
  ! MINUS           [ reduce using rule 75 (operator -> ID URSHIFT_EQ expression .) ]
  ! LEQ             [ reduce using rule 75 (operator -> ID URSHIFT_EQ expression .) ]
  ! GEQ             [ reduce using rule 75 (operator -> ID URSHIFT_EQ expression .) ]
  ! LT              [ reduce using rule 75 (operator -> ID URSHIFT_EQ expression .) ]
  ! GT              [ reduce using rule 75 (operator -> ID URSHIFT_EQ expression .) ]
  ! NEQ             [ reduce using rule 75 (operator -> ID URSHIFT_EQ expression .) ]
  ! EQ              [ reduce using rule 75 (operator -> ID URSHIFT_EQ expression .) ]
  ! AND             [ reduce using rule 75 (operator -> ID URSHIFT_EQ expression .) ]
  ! OR              [ reduce using rule 75 (operator -> ID URSHIFT_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 75 (operator -> ID URSHIFT_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 75 (operator -> ID URSHIFT_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 75 (operator -> ID URSHIFT_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 75 (operator -> ID URSHIFT_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 75 (operator -> ID URSHIFT_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 75 (operator -> ID URSHIFT_EQ expression .) ]

    operatorbittobit               shift and go to state 93

state 164

    (76) operator -> ID LSHIFT_EQ expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 76 (operator -> ID LSHIFT_EQ expression .)
    RPAREN          reduce using rule 76 (operator -> ID LSHIFT_EQ expression .)
    COMMA           reduce using rule 76 (operator -> ID LSHIFT_EQ expression .)
    RBRACKET        reduce using rule 76 (operator -> ID LSHIFT_EQ expression .)
    RCHAV           reduce using rule 76 (operator -> ID LSHIFT_EQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 76 (operator -> ID LSHIFT_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 76 (operator -> ID LSHIFT_EQ expression .) ]
  ! MODULE          [ reduce using rule 76 (operator -> ID LSHIFT_EQ expression .) ]
  ! PLUS            [ reduce using rule 76 (operator -> ID LSHIFT_EQ expression .) ]
  ! MINUS           [ reduce using rule 76 (operator -> ID LSHIFT_EQ expression .) ]
  ! LEQ             [ reduce using rule 76 (operator -> ID LSHIFT_EQ expression .) ]
  ! GEQ             [ reduce using rule 76 (operator -> ID LSHIFT_EQ expression .) ]
  ! LT              [ reduce using rule 76 (operator -> ID LSHIFT_EQ expression .) ]
  ! GT              [ reduce using rule 76 (operator -> ID LSHIFT_EQ expression .) ]
  ! NEQ             [ reduce using rule 76 (operator -> ID LSHIFT_EQ expression .) ]
  ! EQ              [ reduce using rule 76 (operator -> ID LSHIFT_EQ expression .) ]
  ! AND             [ reduce using rule 76 (operator -> ID LSHIFT_EQ expression .) ]
  ! OR              [ reduce using rule 76 (operator -> ID LSHIFT_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 76 (operator -> ID LSHIFT_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 76 (operator -> ID LSHIFT_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 76 (operator -> ID LSHIFT_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 76 (operator -> ID LSHIFT_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 76 (operator -> ID LSHIFT_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 76 (operator -> ID LSHIFT_EQ expression .) ]

    operatorbittobit               shift and go to state 93

state 165

    (77) operator -> ID RSHIFT_EQ expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 77 (operator -> ID RSHIFT_EQ expression .)
    RPAREN          reduce using rule 77 (operator -> ID RSHIFT_EQ expression .)
    COMMA           reduce using rule 77 (operator -> ID RSHIFT_EQ expression .)
    RBRACKET        reduce using rule 77 (operator -> ID RSHIFT_EQ expression .)
    RCHAV           reduce using rule 77 (operator -> ID RSHIFT_EQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 77 (operator -> ID RSHIFT_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 77 (operator -> ID RSHIFT_EQ expression .) ]
  ! MODULE          [ reduce using rule 77 (operator -> ID RSHIFT_EQ expression .) ]
  ! PLUS            [ reduce using rule 77 (operator -> ID RSHIFT_EQ expression .) ]
  ! MINUS           [ reduce using rule 77 (operator -> ID RSHIFT_EQ expression .) ]
  ! LEQ             [ reduce using rule 77 (operator -> ID RSHIFT_EQ expression .) ]
  ! GEQ             [ reduce using rule 77 (operator -> ID RSHIFT_EQ expression .) ]
  ! LT              [ reduce using rule 77 (operator -> ID RSHIFT_EQ expression .) ]
  ! GT              [ reduce using rule 77 (operator -> ID RSHIFT_EQ expression .) ]
  ! NEQ             [ reduce using rule 77 (operator -> ID RSHIFT_EQ expression .) ]
  ! EQ              [ reduce using rule 77 (operator -> ID RSHIFT_EQ expression .) ]
  ! AND             [ reduce using rule 77 (operator -> ID RSHIFT_EQ expression .) ]
  ! OR              [ reduce using rule 77 (operator -> ID RSHIFT_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 77 (operator -> ID RSHIFT_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 77 (operator -> ID RSHIFT_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 77 (operator -> ID RSHIFT_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 77 (operator -> ID RSHIFT_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 77 (operator -> ID RSHIFT_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 77 (operator -> ID RSHIFT_EQ expression .) ]

    operatorbittobit               shift and go to state 93

state 166

    (115) call -> ID LPAREN params_call . RPAREN

    RPAREN          shift and go to state 188


state 167

    (116) call -> ID LPAREN RPAREN .

    SEMICOLON       reduce using rule 116 (call -> ID LPAREN RPAREN .)
    TIMES           reduce using rule 116 (call -> ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 116 (call -> ID LPAREN RPAREN .)
    MODULE          reduce using rule 116 (call -> ID LPAREN RPAREN .)
    PLUS            reduce using rule 116 (call -> ID LPAREN RPAREN .)
    MINUS           reduce using rule 116 (call -> ID LPAREN RPAREN .)
    LEQ             reduce using rule 116 (call -> ID LPAREN RPAREN .)
    GEQ             reduce using rule 116 (call -> ID LPAREN RPAREN .)
    LT              reduce using rule 116 (call -> ID LPAREN RPAREN .)
    GT              reduce using rule 116 (call -> ID LPAREN RPAREN .)
    NEQ             reduce using rule 116 (call -> ID LPAREN RPAREN .)
    EQ              reduce using rule 116 (call -> ID LPAREN RPAREN .)
    AND             reduce using rule 116 (call -> ID LPAREN RPAREN .)
    OR              reduce using rule 116 (call -> ID LPAREN RPAREN .)
    BITWISE_AND     reduce using rule 116 (call -> ID LPAREN RPAREN .)
    BITWISE_OR      reduce using rule 116 (call -> ID LPAREN RPAREN .)
    BITWISE_XOR     reduce using rule 116 (call -> ID LPAREN RPAREN .)
    URSHIFT         reduce using rule 116 (call -> ID LPAREN RPAREN .)
    LSHIFT          reduce using rule 116 (call -> ID LPAREN RPAREN .)
    RSHIFT          reduce using rule 116 (call -> ID LPAREN RPAREN .)
    RPAREN          reduce using rule 116 (call -> ID LPAREN RPAREN .)
    COMMA           reduce using rule 116 (call -> ID LPAREN RPAREN .)
    RBRACKET        reduce using rule 116 (call -> ID LPAREN RPAREN .)
    RCHAV           reduce using rule 116 (call -> ID LPAREN RPAREN .)


state 168

    (117) params_call -> expression . COMMA params_call
    (118) params_call -> expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    COMMA           shift and go to state 189
    RPAREN          reduce using rule 118 (params_call -> expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

    operatorbittobit               shift and go to state 93

state 169

    (47) stm -> RETURN expression SEMICOLON .

    WHILE           reduce using rule 47 (stm -> RETURN expression SEMICOLON .)
    DO              reduce using rule 47 (stm -> RETURN expression SEMICOLON .)
    FOR             reduce using rule 47 (stm -> RETURN expression SEMICOLON .)
    IF              reduce using rule 47 (stm -> RETURN expression SEMICOLON .)
    SEMICOLON       reduce using rule 47 (stm -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 47 (stm -> RETURN expression SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 47 (stm -> RETURN expression SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 47 (stm -> RETURN expression SEMICOLON .)
    INT_NUMBER      reduce using rule 47 (stm -> RETURN expression SEMICOLON .)
    STRING          reduce using rule 47 (stm -> RETURN expression SEMICOLON .)
    ID              reduce using rule 47 (stm -> RETURN expression SEMICOLON .)
    NEW             reduce using rule 47 (stm -> RETURN expression SEMICOLON .)
    STATIC          reduce using rule 47 (stm -> RETURN expression SEMICOLON .)
    FINAL           reduce using rule 47 (stm -> RETURN expression SEMICOLON .)
    INCREMENT       reduce using rule 47 (stm -> RETURN expression SEMICOLON .)
    DECREMENT       reduce using rule 47 (stm -> RETURN expression SEMICOLON .)
    MINUS           reduce using rule 47 (stm -> RETURN expression SEMICOLON .)
    PLUS            reduce using rule 47 (stm -> RETURN expression SEMICOLON .)
    NOT             reduce using rule 47 (stm -> RETURN expression SEMICOLON .)
    TYPE_INT        reduce using rule 47 (stm -> RETURN expression SEMICOLON .)
    TYPE_FLOAT      reduce using rule 47 (stm -> RETURN expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 47 (stm -> RETURN expression SEMICOLON .)
    TYPE_BYTE       reduce using rule 47 (stm -> RETURN expression SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 47 (stm -> RETURN expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 47 (stm -> RETURN expression SEMICOLON .)
    TYPE_STRING     reduce using rule 47 (stm -> RETURN expression SEMICOLON .)
    TYPE_LONG       reduce using rule 47 (stm -> RETURN expression SEMICOLON .)
    TYPE_VOID       reduce using rule 47 (stm -> RETURN expression SEMICOLON .)
    RCHAV           reduce using rule 47 (stm -> RETURN expression SEMICOLON .)


state 170

    (59) expression -> NEW type LPAREN . params_call RPAREN
    (117) params_call -> . expression COMMA params_call
    (118) params_call -> . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    params_call                    shift and go to state 190
    expression                     shift and go to state 168
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 171

    (60) expression -> NEW type LBRACKET . expression RBRACKET
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 191
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 172

    (18) atribute -> visibility atributemodifier type ID EQUAL expression . SEMICOLON
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       shift and go to state 192
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

    operatorbittobit               shift and go to state 93

state 173

    (25) sigparams -> type . ID
    (26) sigparams -> type . ID COMMA sigparams

    ID              shift and go to state 193


state 174

    (23) signature -> visibility atributemodifier type ID LPAREN sigparams . RPAREN

    RPAREN          shift and go to state 194


state 175

    (24) signature -> visibility atributemodifier type brackets_expression ID LPAREN . sigparams RPAREN
    (25) sigparams -> . type ID
    (26) sigparams -> . type ID COMMA sigparams
    (105) type -> . primitivetypes
    (106) primitivetypes -> . TYPE_INT
    (107) primitivetypes -> . TYPE_FLOAT
    (108) primitivetypes -> . TYPE_DOUBLE
    (109) primitivetypes -> . TYPE_BYTE
    (110) primitivetypes -> . TYPE_BOOLEAN
    (111) primitivetypes -> . TYPE_CHAR
    (112) primitivetypes -> . TYPE_STRING
    (113) primitivetypes -> . TYPE_LONG
    (114) primitivetypes -> . TYPE_VOID

    TYPE_INT        shift and go to state 36
    TYPE_FLOAT      shift and go to state 37
    TYPE_DOUBLE     shift and go to state 38
    TYPE_BYTE       shift and go to state 39
    TYPE_BOOLEAN    shift and go to state 40
    TYPE_CHAR       shift and go to state 41
    TYPE_STRING     shift and go to state 42
    TYPE_LONG       shift and go to state 43
    TYPE_VOID       shift and go to state 44

    type                           shift and go to state 173
    sigparams                      shift and go to state 195
    primitivetypes                 shift and go to state 35

state 176

    (103) brackets_expression -> LBRACKET INT_NUMBER RBRACKET .

    ID              reduce using rule 103 (brackets_expression -> LBRACKET INT_NUMBER RBRACKET .)


state 177

    (104) brackets_expression -> LBRACKET ID RBRACKET .

    ID              reduce using rule 104 (brackets_expression -> LBRACKET ID RBRACKET .)


state 178

    (31) stm -> WHILE LPAREN expression RPAREN . bodyorstm
    (49) bodyorstm -> . body
    (27) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 31

    bodyorstm                      shift and go to state 196
    body                           shift and go to state 99

state 179

    (32) stm -> DO bodyorstm WHILE LPAREN . expression RPAREN SEMICOLON
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 197
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 180

    (33) stm -> FOR LPAREN expression_for SEMICOLON . expression SEMICOLON expression RPAREN bodyorstm
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 198
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 181

    (50) expression_for -> type ID . EQUAL expression

    EQUAL           shift and go to state 199


state 182

    (51) expression_for -> ID EQUAL . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 200
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 183

    (34) stm -> IF LPAREN expression RPAREN . bodyorstm
    (35) stm -> IF LPAREN expression RPAREN . bodyorstm ELSE bodyorstm
    (36) stm -> IF LPAREN expression RPAREN . bodyorstm ELSE IF bodyorstm
    (49) bodyorstm -> . body
    (27) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 31

    bodyorstm                      shift and go to state 201
    body                           shift and go to state 99

state 184

    (38) stm -> atributemodifier type ID SEMICOLON .

    WHILE           reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    DO              reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    FOR             reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    IF              reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    SEMICOLON       reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    RETURN          reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    INT_NUMBER      reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    STRING          reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    ID              reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    NEW             reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    STATIC          reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    FINAL           reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    INCREMENT       reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    DECREMENT       reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    MINUS           reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    PLUS            reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    NOT             reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    TYPE_INT        reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    TYPE_FLOAT      reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    TYPE_BYTE       reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    TYPE_CHAR       reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    TYPE_STRING     reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    TYPE_LONG       reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    TYPE_VOID       reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    RCHAV           reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)


state 185

    (39) stm -> atributemodifier type ID EQUAL . expression SEMICOLON
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 202
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 186

    (40) stm -> atributemodifier type ID LBRACKET . RBRACKET SEMICOLON
    (43) stm -> atributemodifier type ID LBRACKET . RBRACKET EQUAL expression SEMICOLON
    (44) stm -> atributemodifier type ID LBRACKET . RBRACKET EQUAL chav_exp SEMICOLON

    RBRACKET        shift and go to state 203


state 187

    (41) stm -> atributemodifier type LBRACKET RBRACKET . ID SEMICOLON
    (42) stm -> atributemodifier type LBRACKET RBRACKET . ID EQUAL chav_exp SEMICOLON
    (45) stm -> atributemodifier type LBRACKET RBRACKET . ID LBRACKET RBRACKET SEMICOLON
    (46) stm -> atributemodifier type LBRACKET RBRACKET . ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON

    ID              shift and go to state 204


state 188

    (115) call -> ID LPAREN params_call RPAREN .

    SEMICOLON       reduce using rule 115 (call -> ID LPAREN params_call RPAREN .)
    TIMES           reduce using rule 115 (call -> ID LPAREN params_call RPAREN .)
    DIVIDE          reduce using rule 115 (call -> ID LPAREN params_call RPAREN .)
    MODULE          reduce using rule 115 (call -> ID LPAREN params_call RPAREN .)
    PLUS            reduce using rule 115 (call -> ID LPAREN params_call RPAREN .)
    MINUS           reduce using rule 115 (call -> ID LPAREN params_call RPAREN .)
    LEQ             reduce using rule 115 (call -> ID LPAREN params_call RPAREN .)
    GEQ             reduce using rule 115 (call -> ID LPAREN params_call RPAREN .)
    LT              reduce using rule 115 (call -> ID LPAREN params_call RPAREN .)
    GT              reduce using rule 115 (call -> ID LPAREN params_call RPAREN .)
    NEQ             reduce using rule 115 (call -> ID LPAREN params_call RPAREN .)
    EQ              reduce using rule 115 (call -> ID LPAREN params_call RPAREN .)
    AND             reduce using rule 115 (call -> ID LPAREN params_call RPAREN .)
    OR              reduce using rule 115 (call -> ID LPAREN params_call RPAREN .)
    BITWISE_AND     reduce using rule 115 (call -> ID LPAREN params_call RPAREN .)
    BITWISE_OR      reduce using rule 115 (call -> ID LPAREN params_call RPAREN .)
    BITWISE_XOR     reduce using rule 115 (call -> ID LPAREN params_call RPAREN .)
    URSHIFT         reduce using rule 115 (call -> ID LPAREN params_call RPAREN .)
    LSHIFT          reduce using rule 115 (call -> ID LPAREN params_call RPAREN .)
    RSHIFT          reduce using rule 115 (call -> ID LPAREN params_call RPAREN .)
    RPAREN          reduce using rule 115 (call -> ID LPAREN params_call RPAREN .)
    COMMA           reduce using rule 115 (call -> ID LPAREN params_call RPAREN .)
    RBRACKET        reduce using rule 115 (call -> ID LPAREN params_call RPAREN .)
    RCHAV           reduce using rule 115 (call -> ID LPAREN params_call RPAREN .)


state 189

    (117) params_call -> expression COMMA . params_call
    (117) params_call -> . expression COMMA params_call
    (118) params_call -> . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 168
    params_call                    shift and go to state 205
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 190

    (59) expression -> NEW type LPAREN params_call . RPAREN

    RPAREN          shift and go to state 206


state 191

    (60) expression -> NEW type LBRACKET expression . RBRACKET
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    RBRACKET        shift and go to state 207
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

    operatorbittobit               shift and go to state 93

state 192

    (18) atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .

    PUBLIC          reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    PRIVATE         reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    PROTECTED       reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    STATIC          reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    FINAL           reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_INT        reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_FLOAT      reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_BYTE       reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_STRING     reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_LONG       reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_VOID       reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    RCHAV           reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)


state 193

    (25) sigparams -> type ID .
    (26) sigparams -> type ID . COMMA sigparams

    RPAREN          reduce using rule 25 (sigparams -> type ID .)
    COMMA           shift and go to state 208


state 194

    (23) signature -> visibility atributemodifier type ID LPAREN sigparams RPAREN .

    LCHAV           reduce using rule 23 (signature -> visibility atributemodifier type ID LPAREN sigparams RPAREN .)


state 195

    (24) signature -> visibility atributemodifier type brackets_expression ID LPAREN sigparams . RPAREN

    RPAREN          shift and go to state 209


state 196

    (31) stm -> WHILE LPAREN expression RPAREN bodyorstm .

    WHILE           reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    DO              reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    FOR             reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    IF              reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    SEMICOLON       reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    RETURN          reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    FLOAT_NUMBER    reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    DOUBLE_NUMBER   reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    INT_NUMBER      reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    STRING          reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    ID              reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    NEW             reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    STATIC          reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    FINAL           reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    INCREMENT       reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    DECREMENT       reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    MINUS           reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    PLUS            reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    NOT             reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    TYPE_INT        reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    TYPE_FLOAT      reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    TYPE_DOUBLE     reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    TYPE_BYTE       reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    TYPE_BOOLEAN    reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    TYPE_CHAR       reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    TYPE_STRING     reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    TYPE_LONG       reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    TYPE_VOID       reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    RCHAV           reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)


state 197

    (32) stm -> DO bodyorstm WHILE LPAREN expression . RPAREN SEMICOLON
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    RPAREN          shift and go to state 210
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

    operatorbittobit               shift and go to state 93

state 198

    (33) stm -> FOR LPAREN expression_for SEMICOLON expression . SEMICOLON expression RPAREN bodyorstm
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       shift and go to state 211
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

    operatorbittobit               shift and go to state 93

state 199

    (50) expression_for -> type ID EQUAL . expression
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 212
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 200

    (51) expression_for -> ID EQUAL expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 51 (expression_for -> ID EQUAL expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

    operatorbittobit               shift and go to state 93

state 201

    (34) stm -> IF LPAREN expression RPAREN bodyorstm .
    (35) stm -> IF LPAREN expression RPAREN bodyorstm . ELSE bodyorstm
    (36) stm -> IF LPAREN expression RPAREN bodyorstm . ELSE IF bodyorstm

    WHILE           reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    DO              reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    FOR             reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    IF              reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    SEMICOLON       reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    RETURN          reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    FLOAT_NUMBER    reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    DOUBLE_NUMBER   reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    INT_NUMBER      reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    STRING          reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    ID              reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    NEW             reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    STATIC          reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    FINAL           reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    INCREMENT       reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    DECREMENT       reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    MINUS           reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    PLUS            reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    NOT             reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    TYPE_INT        reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    TYPE_FLOAT      reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    TYPE_DOUBLE     reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    TYPE_BYTE       reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    TYPE_BOOLEAN    reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    TYPE_CHAR       reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    TYPE_STRING     reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    TYPE_LONG       reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    TYPE_VOID       reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    RCHAV           reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    ELSE            shift and go to state 213


state 202

    (39) stm -> atributemodifier type ID EQUAL expression . SEMICOLON
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       shift and go to state 214
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

    operatorbittobit               shift and go to state 93

state 203

    (40) stm -> atributemodifier type ID LBRACKET RBRACKET . SEMICOLON
    (43) stm -> atributemodifier type ID LBRACKET RBRACKET . EQUAL expression SEMICOLON
    (44) stm -> atributemodifier type ID LBRACKET RBRACKET . EQUAL chav_exp SEMICOLON

    SEMICOLON       shift and go to state 215
    EQUAL           shift and go to state 216


state 204

    (41) stm -> atributemodifier type LBRACKET RBRACKET ID . SEMICOLON
    (42) stm -> atributemodifier type LBRACKET RBRACKET ID . EQUAL chav_exp SEMICOLON
    (45) stm -> atributemodifier type LBRACKET RBRACKET ID . LBRACKET RBRACKET SEMICOLON
    (46) stm -> atributemodifier type LBRACKET RBRACKET ID . LBRACKET RBRACKET EQUAL chav_exp SEMICOLON

    SEMICOLON       shift and go to state 218
    EQUAL           shift and go to state 219
    LBRACKET        shift and go to state 217


state 205

    (117) params_call -> expression COMMA params_call .

    RPAREN          reduce using rule 117 (params_call -> expression COMMA params_call .)


state 206

    (59) expression -> NEW type LPAREN params_call RPAREN .

    SEMICOLON       reduce using rule 59 (expression -> NEW type LPAREN params_call RPAREN .)
    TIMES           reduce using rule 59 (expression -> NEW type LPAREN params_call RPAREN .)
    DIVIDE          reduce using rule 59 (expression -> NEW type LPAREN params_call RPAREN .)
    MODULE          reduce using rule 59 (expression -> NEW type LPAREN params_call RPAREN .)
    PLUS            reduce using rule 59 (expression -> NEW type LPAREN params_call RPAREN .)
    MINUS           reduce using rule 59 (expression -> NEW type LPAREN params_call RPAREN .)
    LEQ             reduce using rule 59 (expression -> NEW type LPAREN params_call RPAREN .)
    GEQ             reduce using rule 59 (expression -> NEW type LPAREN params_call RPAREN .)
    LT              reduce using rule 59 (expression -> NEW type LPAREN params_call RPAREN .)
    GT              reduce using rule 59 (expression -> NEW type LPAREN params_call RPAREN .)
    NEQ             reduce using rule 59 (expression -> NEW type LPAREN params_call RPAREN .)
    EQ              reduce using rule 59 (expression -> NEW type LPAREN params_call RPAREN .)
    AND             reduce using rule 59 (expression -> NEW type LPAREN params_call RPAREN .)
    OR              reduce using rule 59 (expression -> NEW type LPAREN params_call RPAREN .)
    BITWISE_AND     reduce using rule 59 (expression -> NEW type LPAREN params_call RPAREN .)
    BITWISE_OR      reduce using rule 59 (expression -> NEW type LPAREN params_call RPAREN .)
    BITWISE_XOR     reduce using rule 59 (expression -> NEW type LPAREN params_call RPAREN .)
    URSHIFT         reduce using rule 59 (expression -> NEW type LPAREN params_call RPAREN .)
    LSHIFT          reduce using rule 59 (expression -> NEW type LPAREN params_call RPAREN .)
    RSHIFT          reduce using rule 59 (expression -> NEW type LPAREN params_call RPAREN .)
    RPAREN          reduce using rule 59 (expression -> NEW type LPAREN params_call RPAREN .)
    COMMA           reduce using rule 59 (expression -> NEW type LPAREN params_call RPAREN .)
    RBRACKET        reduce using rule 59 (expression -> NEW type LPAREN params_call RPAREN .)
    RCHAV           reduce using rule 59 (expression -> NEW type LPAREN params_call RPAREN .)


state 207

    (60) expression -> NEW type LBRACKET expression RBRACKET .

    SEMICOLON       reduce using rule 60 (expression -> NEW type LBRACKET expression RBRACKET .)
    TIMES           reduce using rule 60 (expression -> NEW type LBRACKET expression RBRACKET .)
    DIVIDE          reduce using rule 60 (expression -> NEW type LBRACKET expression RBRACKET .)
    MODULE          reduce using rule 60 (expression -> NEW type LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 60 (expression -> NEW type LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 60 (expression -> NEW type LBRACKET expression RBRACKET .)
    LEQ             reduce using rule 60 (expression -> NEW type LBRACKET expression RBRACKET .)
    GEQ             reduce using rule 60 (expression -> NEW type LBRACKET expression RBRACKET .)
    LT              reduce using rule 60 (expression -> NEW type LBRACKET expression RBRACKET .)
    GT              reduce using rule 60 (expression -> NEW type LBRACKET expression RBRACKET .)
    NEQ             reduce using rule 60 (expression -> NEW type LBRACKET expression RBRACKET .)
    EQ              reduce using rule 60 (expression -> NEW type LBRACKET expression RBRACKET .)
    AND             reduce using rule 60 (expression -> NEW type LBRACKET expression RBRACKET .)
    OR              reduce using rule 60 (expression -> NEW type LBRACKET expression RBRACKET .)
    BITWISE_AND     reduce using rule 60 (expression -> NEW type LBRACKET expression RBRACKET .)
    BITWISE_OR      reduce using rule 60 (expression -> NEW type LBRACKET expression RBRACKET .)
    BITWISE_XOR     reduce using rule 60 (expression -> NEW type LBRACKET expression RBRACKET .)
    URSHIFT         reduce using rule 60 (expression -> NEW type LBRACKET expression RBRACKET .)
    LSHIFT          reduce using rule 60 (expression -> NEW type LBRACKET expression RBRACKET .)
    RSHIFT          reduce using rule 60 (expression -> NEW type LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 60 (expression -> NEW type LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 60 (expression -> NEW type LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 60 (expression -> NEW type LBRACKET expression RBRACKET .)
    RCHAV           reduce using rule 60 (expression -> NEW type LBRACKET expression RBRACKET .)


state 208

    (26) sigparams -> type ID COMMA . sigparams
    (25) sigparams -> . type ID
    (26) sigparams -> . type ID COMMA sigparams
    (105) type -> . primitivetypes
    (106) primitivetypes -> . TYPE_INT
    (107) primitivetypes -> . TYPE_FLOAT
    (108) primitivetypes -> . TYPE_DOUBLE
    (109) primitivetypes -> . TYPE_BYTE
    (110) primitivetypes -> . TYPE_BOOLEAN
    (111) primitivetypes -> . TYPE_CHAR
    (112) primitivetypes -> . TYPE_STRING
    (113) primitivetypes -> . TYPE_LONG
    (114) primitivetypes -> . TYPE_VOID

    TYPE_INT        shift and go to state 36
    TYPE_FLOAT      shift and go to state 37
    TYPE_DOUBLE     shift and go to state 38
    TYPE_BYTE       shift and go to state 39
    TYPE_BOOLEAN    shift and go to state 40
    TYPE_CHAR       shift and go to state 41
    TYPE_STRING     shift and go to state 42
    TYPE_LONG       shift and go to state 43
    TYPE_VOID       shift and go to state 44

    type                           shift and go to state 173
    sigparams                      shift and go to state 220
    primitivetypes                 shift and go to state 35

state 209

    (24) signature -> visibility atributemodifier type brackets_expression ID LPAREN sigparams RPAREN .

    LCHAV           reduce using rule 24 (signature -> visibility atributemodifier type brackets_expression ID LPAREN sigparams RPAREN .)


state 210

    (32) stm -> DO bodyorstm WHILE LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 221


state 211

    (33) stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON . expression RPAREN bodyorstm
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 222
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 212

    (50) expression_for -> type ID EQUAL expression .
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 50 (expression_for -> type ID EQUAL expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

    operatorbittobit               shift and go to state 93

state 213

    (35) stm -> IF LPAREN expression RPAREN bodyorstm ELSE . bodyorstm
    (36) stm -> IF LPAREN expression RPAREN bodyorstm ELSE . IF bodyorstm
    (49) bodyorstm -> . body
    (27) body -> . LCHAV stms RCHAV

    IF              shift and go to state 223
    LCHAV           shift and go to state 31

    bodyorstm                      shift and go to state 224
    body                           shift and go to state 99

state 214

    (39) stm -> atributemodifier type ID EQUAL expression SEMICOLON .

    WHILE           reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    DO              reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    FOR             reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    IF              reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    SEMICOLON       reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    RETURN          reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    INT_NUMBER      reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    STRING          reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    ID              reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    NEW             reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    STATIC          reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    FINAL           reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    INCREMENT       reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    DECREMENT       reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    MINUS           reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    PLUS            reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    NOT             reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_INT        reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_FLOAT      reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_BYTE       reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_STRING     reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_LONG       reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_VOID       reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    RCHAV           reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)


state 215

    (40) stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .

    WHILE           reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    DO              reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    FOR             reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    IF              reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    SEMICOLON       reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    RETURN          reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    INT_NUMBER      reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    STRING          reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    ID              reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    NEW             reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    STATIC          reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    FINAL           reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    INCREMENT       reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    DECREMENT       reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    MINUS           reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    PLUS            reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    NOT             reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_INT        reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_FLOAT      reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_BYTE       reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_CHAR       reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_STRING     reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_LONG       reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_VOID       reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)
    RCHAV           reduce using rule 40 (stm -> atributemodifier type ID LBRACKET RBRACKET SEMICOLON .)


state 216

    (43) stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL . expression SEMICOLON
    (44) stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL . chav_exp SEMICOLON
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (119) chav_exp -> . LCHAV RCHAV
    (120) chav_exp -> . LCHAV expression_chav
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    LCHAV           shift and go to state 227
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 225
    chav_exp                       shift and go to state 226
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 217

    (45) stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET . RBRACKET SEMICOLON
    (46) stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET . RBRACKET EQUAL chav_exp SEMICOLON

    RBRACKET        shift and go to state 228


state 218

    (41) stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .

    WHILE           reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    DO              reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    FOR             reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    IF              reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    SEMICOLON       reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    RETURN          reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    INT_NUMBER      reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    STRING          reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    ID              reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    NEW             reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    STATIC          reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    FINAL           reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    INCREMENT       reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    DECREMENT       reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    MINUS           reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    PLUS            reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    NOT             reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    TYPE_INT        reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    TYPE_FLOAT      reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    TYPE_BYTE       reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    TYPE_CHAR       reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    TYPE_STRING     reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    TYPE_LONG       reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    TYPE_VOID       reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)
    RCHAV           reduce using rule 41 (stm -> atributemodifier type LBRACKET RBRACKET ID SEMICOLON .)


state 219

    (42) stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL . chav_exp SEMICOLON
    (119) chav_exp -> . LCHAV RCHAV
    (120) chav_exp -> . LCHAV expression_chav

    LCHAV           shift and go to state 227

    chav_exp                       shift and go to state 229

state 220

    (26) sigparams -> type ID COMMA sigparams .

    RPAREN          reduce using rule 26 (sigparams -> type ID COMMA sigparams .)


state 221

    (32) stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .

    WHILE           reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    DO              reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    FOR             reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    IF              reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    RETURN          reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    INT_NUMBER      reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    STRING          reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    ID              reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    NEW             reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    STATIC          reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    FINAL           reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    DECREMENT       reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    MINUS           reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    PLUS            reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    NOT             reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    TYPE_INT        reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    TYPE_FLOAT      reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    TYPE_BYTE       reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    TYPE_CHAR       reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    TYPE_STRING     reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    TYPE_LONG       reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    TYPE_VOID       reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    RCHAV           reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)


state 222

    (33) stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression . RPAREN bodyorstm
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    RPAREN          shift and go to state 230
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

    operatorbittobit               shift and go to state 93

state 223

    (36) stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF . bodyorstm
    (49) bodyorstm -> . body
    (27) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 31

    bodyorstm                      shift and go to state 231
    body                           shift and go to state 99

state 224

    (35) stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .

    WHILE           reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    DO              reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    FOR             reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    IF              reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    SEMICOLON       reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    RETURN          reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    FLOAT_NUMBER    reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    DOUBLE_NUMBER   reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    INT_NUMBER      reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    STRING          reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    ID              reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    NEW             reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    STATIC          reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    FINAL           reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    INCREMENT       reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    DECREMENT       reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    MINUS           reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    PLUS            reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    NOT             reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    TYPE_INT        reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    TYPE_FLOAT      reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    TYPE_DOUBLE     reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    TYPE_BYTE       reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    TYPE_BOOLEAN    reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    TYPE_CHAR       reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    TYPE_STRING     reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    TYPE_LONG       reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    TYPE_VOID       reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    RCHAV           reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)


state 225

    (43) stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression . SEMICOLON
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    SEMICOLON       shift and go to state 232
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

    operatorbittobit               shift and go to state 93

state 226

    (44) stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp . SEMICOLON

    SEMICOLON       shift and go to state 233


state 227

    (119) chav_exp -> LCHAV . RCHAV
    (120) chav_exp -> LCHAV . expression_chav
    (121) expression_chav -> . expression COMMA expression_chav
    (122) expression_chav -> . expression RCHAV
    (123) expression_chav -> . expression COMMA RCHAV
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    RCHAV           shift and go to state 234
    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression_chav                shift and go to state 235
    expression                     shift and go to state 236
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 228

    (45) stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET . SEMICOLON
    (46) stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET . EQUAL chav_exp SEMICOLON

    SEMICOLON       shift and go to state 237
    EQUAL           shift and go to state 238


state 229

    (42) stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp . SEMICOLON

    SEMICOLON       shift and go to state 239


state 230

    (33) stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN . bodyorstm
    (49) bodyorstm -> . body
    (27) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 31

    bodyorstm                      shift and go to state 240
    body                           shift and go to state 99

state 231

    (36) stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .

    WHILE           reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    DO              reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    FOR             reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    IF              reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    SEMICOLON       reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    RETURN          reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    FLOAT_NUMBER    reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    DOUBLE_NUMBER   reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    INT_NUMBER      reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    STRING          reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    ID              reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    NEW             reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    STATIC          reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    FINAL           reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    INCREMENT       reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    DECREMENT       reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    MINUS           reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    PLUS            reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    NOT             reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    TYPE_INT        reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    TYPE_FLOAT      reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    TYPE_DOUBLE     reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    TYPE_BYTE       reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    TYPE_BOOLEAN    reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    TYPE_CHAR       reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    TYPE_STRING     reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    TYPE_LONG       reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    TYPE_VOID       reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    RCHAV           reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)


state 232

    (43) stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .

    WHILE           reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    DO              reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    FOR             reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    IF              reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    SEMICOLON       reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    RETURN          reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    INT_NUMBER      reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    STRING          reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    ID              reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    NEW             reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    STATIC          reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    FINAL           reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    INCREMENT       reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    DECREMENT       reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    MINUS           reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    PLUS            reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    NOT             reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    TYPE_INT        reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    TYPE_FLOAT      reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    TYPE_BYTE       reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    TYPE_STRING     reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    TYPE_LONG       reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    TYPE_VOID       reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)
    RCHAV           reduce using rule 43 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL expression SEMICOLON .)


state 233

    (44) stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .

    WHILE           reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    DO              reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    FOR             reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    IF              reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    SEMICOLON       reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    RETURN          reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    INT_NUMBER      reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    STRING          reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    ID              reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    NEW             reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    STATIC          reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    FINAL           reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    INCREMENT       reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    DECREMENT       reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    MINUS           reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    PLUS            reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    NOT             reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_INT        reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_FLOAT      reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_BYTE       reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_CHAR       reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_STRING     reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_LONG       reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_VOID       reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    RCHAV           reduce using rule 44 (stm -> atributemodifier type ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)


state 234

    (119) chav_exp -> LCHAV RCHAV .

    SEMICOLON       reduce using rule 119 (chav_exp -> LCHAV RCHAV .)


state 235

    (120) chav_exp -> LCHAV expression_chav .

    SEMICOLON       reduce using rule 120 (chav_exp -> LCHAV expression_chav .)


state 236

    (121) expression_chav -> expression . COMMA expression_chav
    (122) expression_chav -> expression . RCHAV
    (123) expression_chav -> expression . COMMA RCHAV
    (61) operator -> expression . TIMES expression
    (62) operator -> expression . DIVIDE expression
    (63) operator -> expression . MODULE expression
    (64) operator -> expression . PLUS expression
    (65) operator -> expression . MINUS expression
    (78) operator -> expression . LEQ expression
    (79) operator -> expression . GEQ expression
    (80) operator -> expression . LT expression
    (81) operator -> expression . GT expression
    (82) operator -> expression . NEQ expression
    (83) operator -> expression . EQ expression
    (84) operator -> expression . AND expression
    (85) operator -> expression . OR expression
    (86) operator -> expression . BITWISE_AND expression
    (87) operator -> expression . BITWISE_OR expression
    (88) operator -> expression . BITWISE_XOR expression
    (91) operator -> expression . operatorbittobit
    (99) operatorbittobit -> . URSHIFT
    (100) operatorbittobit -> . LSHIFT
    (101) operatorbittobit -> . RSHIFT

    COMMA           shift and go to state 241
    RCHAV           shift and go to state 242
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

    operatorbittobit               shift and go to state 93

state 237

    (45) stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .

    WHILE           reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    DO              reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    FOR             reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    IF              reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    SEMICOLON       reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    RETURN          reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    INT_NUMBER      reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    STRING          reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    ID              reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    NEW             reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    STATIC          reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    FINAL           reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    INCREMENT       reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    DECREMENT       reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    MINUS           reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    PLUS            reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    NOT             reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_INT        reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_FLOAT      reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_BYTE       reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_CHAR       reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_STRING     reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_LONG       reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    TYPE_VOID       reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)
    RCHAV           reduce using rule 45 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET SEMICOLON .)


state 238

    (46) stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL . chav_exp SEMICOLON
    (119) chav_exp -> . LCHAV RCHAV
    (120) chav_exp -> . LCHAV expression_chav

    LCHAV           shift and go to state 227

    chav_exp                       shift and go to state 243

state 239

    (42) stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .

    WHILE           reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    DO              reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    FOR             reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    IF              reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    SEMICOLON       reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    RETURN          reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    INT_NUMBER      reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    STRING          reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    ID              reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    NEW             reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    STATIC          reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    FINAL           reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    INCREMENT       reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    DECREMENT       reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    MINUS           reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    PLUS            reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    NOT             reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    TYPE_INT        reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    TYPE_FLOAT      reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    TYPE_BYTE       reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    TYPE_CHAR       reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    TYPE_STRING     reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    TYPE_LONG       reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    TYPE_VOID       reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)
    RCHAV           reduce using rule 42 (stm -> atributemodifier type LBRACKET RBRACKET ID EQUAL chav_exp SEMICOLON .)


state 240

    (33) stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .

    WHILE           reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    DO              reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    FOR             reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    IF              reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    SEMICOLON       reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    RETURN          reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    FLOAT_NUMBER    reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    DOUBLE_NUMBER   reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    INT_NUMBER      reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    STRING          reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    ID              reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    NEW             reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    STATIC          reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    FINAL           reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    INCREMENT       reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    DECREMENT       reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    MINUS           reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    PLUS            reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    NOT             reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    TYPE_INT        reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    TYPE_FLOAT      reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    TYPE_DOUBLE     reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    TYPE_BYTE       reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    TYPE_BOOLEAN    reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    TYPE_CHAR       reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    TYPE_STRING     reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    TYPE_LONG       reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    TYPE_VOID       reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    RCHAV           reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)


state 241

    (121) expression_chav -> expression COMMA . expression_chav
    (123) expression_chav -> expression COMMA . RCHAV
    (121) expression_chav -> . expression COMMA expression_chav
    (122) expression_chav -> . expression RCHAV
    (123) expression_chav -> . expression COMMA RCHAV
    (52) expression -> . operator
    (53) expression -> . call
    (54) expression -> . FLOAT_NUMBER
    (55) expression -> . DOUBLE_NUMBER
    (56) expression -> . INT_NUMBER
    (57) expression -> . STRING
    (58) expression -> . ID
    (59) expression -> . NEW type LPAREN params_call RPAREN
    (60) expression -> . NEW type LBRACKET expression RBRACKET
    (61) operator -> . expression TIMES expression
    (62) operator -> . expression DIVIDE expression
    (63) operator -> . expression MODULE expression
    (64) operator -> . expression PLUS expression
    (65) operator -> . expression MINUS expression
    (66) operator -> . ID EQUAL expression
    (67) operator -> . ID MINUS_EQ expression
    (68) operator -> . ID TIMES_EQ expression
    (69) operator -> . ID PLUS_EQ expression
    (70) operator -> . ID DIVIDE_EQ expression
    (71) operator -> . ID MOD_EQ expression
    (72) operator -> . ID BITWISE_AND_EQ expression
    (73) operator -> . ID BITWISE_OR_EQ expression
    (74) operator -> . ID BITWISE_XOR_EQ expression
    (75) operator -> . ID URSHIFT_EQ expression
    (76) operator -> . ID LSHIFT_EQ expression
    (77) operator -> . ID RSHIFT_EQ expression
    (78) operator -> . expression LEQ expression
    (79) operator -> . expression GEQ expression
    (80) operator -> . expression LT expression
    (81) operator -> . expression GT expression
    (82) operator -> . expression NEQ expression
    (83) operator -> . expression EQ expression
    (84) operator -> . expression AND expression
    (85) operator -> . expression OR expression
    (86) operator -> . expression BITWISE_AND expression
    (87) operator -> . expression BITWISE_OR expression
    (88) operator -> . expression BITWISE_XOR expression
    (89) operator -> . unaryoperatorprefx ID
    (90) operator -> . ID unaryoperatorsufx
    (91) operator -> . expression operatorbittobit
    (115) call -> . ID LPAREN params_call RPAREN
    (116) call -> . ID LPAREN RPAREN
    (92) unaryoperatorprefx -> . INCREMENT
    (93) unaryoperatorprefx -> . DECREMENT
    (94) unaryoperatorprefx -> . MINUS
    (95) unaryoperatorprefx -> . PLUS
    (96) unaryoperatorprefx -> . NOT

    RCHAV           shift and go to state 245
    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 236
    expression_chav                shift and go to state 244
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 242

    (122) expression_chav -> expression RCHAV .

    SEMICOLON       reduce using rule 122 (expression_chav -> expression RCHAV .)


state 243

    (46) stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp . SEMICOLON

    SEMICOLON       shift and go to state 246


state 244

    (121) expression_chav -> expression COMMA expression_chav .

    SEMICOLON       reduce using rule 121 (expression_chav -> expression COMMA expression_chav .)


state 245

    (123) expression_chav -> expression COMMA RCHAV .

    SEMICOLON       reduce using rule 123 (expression_chav -> expression COMMA RCHAV .)


state 246

    (46) stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .

    WHILE           reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    DO              reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    FOR             reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    IF              reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    SEMICOLON       reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    RETURN          reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    INT_NUMBER      reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    STRING          reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    ID              reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    NEW             reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    STATIC          reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    FINAL           reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    INCREMENT       reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    DECREMENT       reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    MINUS           reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    PLUS            reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    NOT             reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_INT        reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_FLOAT      reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_BYTE       reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_CHAR       reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_STRING     reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_LONG       reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    TYPE_VOID       reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)
    RCHAV           reduce using rule 46 (stm -> atributemodifier type LBRACKET RBRACKET ID LBRACKET RBRACKET EQUAL chav_exp SEMICOLON .)

