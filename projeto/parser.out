Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ASSERT
    BIN_NUMBER
    BITWISE_NOT
    BREAK
    BYTE_NUMBER
    CASE
    CATCH
    CHAR
    CONST
    CONTINUE
    DEFAULT
    DOT
    ENUM
    FINALLY
    GOTO
    HEXA_NUMBER
    IMPORT
    INSTANCEOF
    INTERFACE
    LONG_NUMBER
    NATIVE
    OCTAL_NUMBER
    POT
    SHORT
    STRICTFP
    SUPER
    SWITCH
    SYNCHRONIZED
    TERNARY
    THIS
    THROW
    THROWS
    TRANSIENT
    TRY
    VOLATILE

Grammar

Rule 0     S' -> program
Rule 1     program -> class
Rule 2     class -> visibility classmodifier CLASS ID EXTENDS ID LCHAV membros RCHAV
Rule 3     class -> visibility classmodifier CLASS ID LCHAV membros RCHAV
Rule 4     class -> visibility classmodifier CLASS ID IMPLEMENTS LCHAV membros RCHAV
Rule 5     visibility -> PUBLIC
Rule 6     visibility -> PRIVATE
Rule 7     visibility -> PROTECTED
Rule 8     visibility -> <empty>
Rule 9     classmodifier -> <empty>
Rule 10    classmodifier -> ABSTRACT
Rule 11    classmodifier -> FINAL
Rule 12    classmodifier -> PACKAGE
Rule 13    membros -> membro
Rule 14    membros -> membro membros
Rule 15    membro -> atribute
Rule 16    membro -> function
Rule 17    atribute -> visibility atributemodifier type ID SEMICOLON
Rule 18    atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON
Rule 19    atributemodifier -> <empty>
Rule 20    atributemodifier -> STATIC
Rule 21    atributemodifier -> FINAL
Rule 22    function -> signature body
Rule 23    signature -> visibility atributemodifier type ID LPAREN sigparams RPAREN
Rule 24    signature -> visibility atributemodifier type brackets_expression ID LPAREN sigparams RPAREN
Rule 25    sigparams -> type ID
Rule 26    sigparams -> type ID COMMA sigparams
Rule 27    body -> LCHAV stms RCHAV
Rule 28    stms -> stm
Rule 29    stms -> stm stms
Rule 30    stm -> expression SEMICOLON
Rule 31    stm -> WHILE LPAREN expression RPAREN bodyorstm
Rule 32    stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON
Rule 33    stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm
Rule 34    stm -> IF LPAREN expression RPAREN bodyorstm
Rule 35    stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm
Rule 36    stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm
Rule 37    stm -> SEMICOLON
Rule 38    stm -> atributemodifier type ID SEMICOLON
Rule 39    stm -> atributemodifier type ID EQUAL expression SEMICOLON
Rule 40    stm -> RETURN expression SEMICOLON
Rule 41    stm -> RETURN SEMICOLON
Rule 42    bodyorstm -> body
Rule 43    expression_for -> type ID EQUAL expression
Rule 44    expression_for -> ID EQUAL expression
Rule 45    expression -> operator
Rule 46    expression -> call
Rule 47    expression -> FLOAT_NUMBER
Rule 48    expression -> DOUBLE_NUMBER
Rule 49    expression -> INT_NUMBER
Rule 50    expression -> STRING
Rule 51    expression -> ID
Rule 52    expression -> NEW type LPAREN params_call RPAREN
Rule 53    expression -> NEW type LBRACKET expression RBRACKET
Rule 54    operator -> expression TIMES expression
Rule 55    operator -> expression DIVIDE expression
Rule 56    operator -> expression MODULE expression
Rule 57    operator -> expression PLUS expression
Rule 58    operator -> expression MINUS expression
Rule 59    operator -> ID EQUAL expression
Rule 60    operator -> ID MINUS_EQ expression
Rule 61    operator -> ID TIMES_EQ expression
Rule 62    operator -> ID PLUS_EQ expression
Rule 63    operator -> ID DIVIDE_EQ expression
Rule 64    operator -> ID MOD_EQ expression
Rule 65    operator -> ID BITWISE_AND_EQ expression
Rule 66    operator -> ID BITWISE_OR_EQ expression
Rule 67    operator -> ID BITWISE_XOR_EQ expression
Rule 68    operator -> ID URSHIFT_EQ expression
Rule 69    operator -> ID LSHIFT_EQ expression
Rule 70    operator -> ID RSHIFT_EQ expression
Rule 71    operator -> expression LEQ expression
Rule 72    operator -> expression GEQ expression
Rule 73    operator -> expression LT expression
Rule 74    operator -> expression GT expression
Rule 75    operator -> expression NEQ expression
Rule 76    operator -> expression EQ expression
Rule 77    operator -> expression AND expression
Rule 78    operator -> expression OR expression
Rule 79    operator -> expression BITWISE_AND expression
Rule 80    operator -> expression BITWISE_OR expression
Rule 81    operator -> expression BITWISE_XOR expression
Rule 82    operator -> unaryoperatorprefx ID
Rule 83    operator -> ID unaryoperatorsufx
Rule 84    operator -> expression operatorbittobit
Rule 85    unaryoperatorprefx -> INCREMENT
Rule 86    unaryoperatorprefx -> DECREMENT
Rule 87    unaryoperatorprefx -> MINUS
Rule 88    unaryoperatorprefx -> PLUS
Rule 89    unaryoperatorprefx -> NOT
Rule 90    unaryoperatorsufx -> INCREMENT
Rule 91    unaryoperatorsufx -> DECREMENT
Rule 92    operatorbittobit -> URSHIFT
Rule 93    operatorbittobit -> LSHIFT
Rule 94    operatorbittobit -> RSHIFT
Rule 95    brackets_expression -> LBRACKET RBRACKET
Rule 96    brackets_expression -> LBRACKET INT_NUMBER RBRACKET
Rule 97    brackets_expression -> LBRACKET ID RBRACKET
Rule 98    type -> primitivetypes
Rule 99    primitivetypes -> TYPE_INT
Rule 100   primitivetypes -> TYPE_FLOAT
Rule 101   primitivetypes -> TYPE_DOUBLE
Rule 102   primitivetypes -> TYPE_BYTE
Rule 103   primitivetypes -> TYPE_BOOLEAN
Rule 104   primitivetypes -> TYPE_CHAR
Rule 105   primitivetypes -> TYPE_STRING
Rule 106   primitivetypes -> TYPE_LONG
Rule 107   primitivetypes -> TYPE_VOID
Rule 108   call -> ID LPAREN params_call RPAREN
Rule 109   call -> ID LPAREN RPAREN
Rule 110   params_call -> expression COMMA params_call
Rule 111   params_call -> expression

Terminals, with rules where they appear

ABSTRACT             : 10
AND                  : 77
ASSERT               : 
BIN_NUMBER           : 
BITWISE_AND          : 79
BITWISE_AND_EQ       : 65
BITWISE_NOT          : 
BITWISE_OR           : 80
BITWISE_OR_EQ        : 66
BITWISE_XOR          : 81
BITWISE_XOR_EQ       : 67
BREAK                : 
BYTE_NUMBER          : 
CASE                 : 
CATCH                : 
CHAR                 : 
CLASS                : 2 3 4
COMMA                : 26 110
CONST                : 
CONTINUE             : 
DECREMENT            : 86 91
DEFAULT              : 
DIVIDE               : 55
DIVIDE_EQ            : 63
DO                   : 32
DOT                  : 
DOUBLE_NUMBER        : 48
ELSE                 : 35 36
ENUM                 : 
EQ                   : 76
EQUAL                : 18 39 43 44 59
EXTENDS              : 2
FINAL                : 11 21
FINALLY              : 
FLOAT_NUMBER         : 47
FOR                  : 33
GEQ                  : 72
GOTO                 : 
GT                   : 74
HEXA_NUMBER          : 
ID                   : 2 2 3 4 17 18 23 24 25 26 38 39 43 44 51 59 60 61 62 63 64 65 66 67 68 69 70 82 83 97 108 109
IF                   : 34 35 36 36
IMPLEMENTS           : 4
IMPORT               : 
INCREMENT            : 85 90
INSTANCEOF           : 
INTERFACE            : 
INT_NUMBER           : 49 96
LBRACKET             : 53 95 96 97
LCHAV                : 2 3 4 27
LEQ                  : 71
LONG_NUMBER          : 
LPAREN               : 23 24 31 32 33 34 35 36 52 108 109
LSHIFT               : 93
LSHIFT_EQ            : 69
LT                   : 73
MINUS                : 58 87
MINUS_EQ             : 60
MODULE               : 56
MOD_EQ               : 64
NATIVE               : 
NEQ                  : 75
NEW                  : 52 53
NOT                  : 89
OCTAL_NUMBER         : 
OR                   : 78
PACKAGE              : 12
PLUS                 : 57 88
PLUS_EQ              : 62
POT                  : 
PRIVATE              : 6
PROTECTED            : 7
PUBLIC               : 5
RBRACKET             : 53 95 96 97
RCHAV                : 2 3 4 27
RETURN               : 40 41
RPAREN               : 23 24 31 32 33 34 35 36 52 108 109
RSHIFT               : 94
RSHIFT_EQ            : 70
SEMICOLON            : 17 18 30 32 33 33 37 38 39 40 41
SHORT                : 
STATIC               : 20
STRICTFP             : 
STRING               : 50
SUPER                : 
SWITCH               : 
SYNCHRONIZED         : 
TERNARY              : 
THIS                 : 
THROW                : 
THROWS               : 
TIMES                : 54
TIMES_EQ             : 61
TRANSIENT            : 
TRY                  : 
TYPE_BOOLEAN         : 103
TYPE_BYTE            : 102
TYPE_CHAR            : 104
TYPE_DOUBLE          : 101
TYPE_FLOAT           : 100
TYPE_INT             : 99
TYPE_LONG            : 106
TYPE_STRING          : 105
TYPE_VOID            : 107
URSHIFT              : 92
URSHIFT_EQ           : 68
VOLATILE             : 
WHILE                : 31 32
error                : 

Nonterminals, with rules where they appear

atribute             : 15
atributemodifier     : 17 18 23 24 38 39
body                 : 22 42
bodyorstm            : 31 32 33 34 35 35 36 36
brackets_expression  : 24
call                 : 46
class                : 1
classmodifier        : 2 3 4
expression           : 18 30 31 32 33 33 34 35 36 39 40 43 44 53 54 54 55 55 56 56 57 57 58 58 59 60 61 62 63 64 65 66 67 68 69 70 71 71 72 72 73 73 74 74 75 75 76 76 77 77 78 78 79 79 80 80 81 81 84 110 111
expression_for       : 33
function             : 16
membro               : 13 14
membros              : 2 3 4 14
operator             : 45
operatorbittobit     : 84
params_call          : 52 108 110
primitivetypes       : 98
program              : 0
signature            : 22
sigparams            : 23 24 26
stm                  : 28 29
stms                 : 27 29
type                 : 17 18 23 24 25 26 38 39 43 52 53
unaryoperatorprefx   : 82
unaryoperatorsufx    : 83
visibility           : 2 3 4 17 18 23 24

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . class
    (2) class -> . visibility classmodifier CLASS ID EXTENDS ID LCHAV membros RCHAV
    (3) class -> . visibility classmodifier CLASS ID LCHAV membros RCHAV
    (4) class -> . visibility classmodifier CLASS ID IMPLEMENTS LCHAV membros RCHAV
    (5) visibility -> . PUBLIC
    (6) visibility -> . PRIVATE
    (7) visibility -> . PROTECTED
    (8) visibility -> .

    PUBLIC          shift and go to state 4
    PRIVATE         shift and go to state 5
    PROTECTED       shift and go to state 6
    ABSTRACT        reduce using rule 8 (visibility -> .)
    FINAL           reduce using rule 8 (visibility -> .)
    PACKAGE         reduce using rule 8 (visibility -> .)
    CLASS           reduce using rule 8 (visibility -> .)

    program                        shift and go to state 1
    class                          shift and go to state 2
    visibility                     shift and go to state 3

state 1

    (0) S' -> program .



state 2

    (1) program -> class .

    $end            reduce using rule 1 (program -> class .)


state 3

    (2) class -> visibility . classmodifier CLASS ID EXTENDS ID LCHAV membros RCHAV
    (3) class -> visibility . classmodifier CLASS ID LCHAV membros RCHAV
    (4) class -> visibility . classmodifier CLASS ID IMPLEMENTS LCHAV membros RCHAV
    (9) classmodifier -> .
    (10) classmodifier -> . ABSTRACT
    (11) classmodifier -> . FINAL
    (12) classmodifier -> . PACKAGE

    CLASS           reduce using rule 9 (classmodifier -> .)
    ABSTRACT        shift and go to state 8
    FINAL           shift and go to state 9
    PACKAGE         shift and go to state 10

    classmodifier                  shift and go to state 7

state 4

    (5) visibility -> PUBLIC .

    ABSTRACT        reduce using rule 5 (visibility -> PUBLIC .)
    FINAL           reduce using rule 5 (visibility -> PUBLIC .)
    PACKAGE         reduce using rule 5 (visibility -> PUBLIC .)
    CLASS           reduce using rule 5 (visibility -> PUBLIC .)
    STATIC          reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_INT        reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_FLOAT      reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_DOUBLE     reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_BYTE       reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_BOOLEAN    reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_CHAR       reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_STRING     reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_LONG       reduce using rule 5 (visibility -> PUBLIC .)
    TYPE_VOID       reduce using rule 5 (visibility -> PUBLIC .)


state 5

    (6) visibility -> PRIVATE .

    ABSTRACT        reduce using rule 6 (visibility -> PRIVATE .)
    FINAL           reduce using rule 6 (visibility -> PRIVATE .)
    PACKAGE         reduce using rule 6 (visibility -> PRIVATE .)
    CLASS           reduce using rule 6 (visibility -> PRIVATE .)
    STATIC          reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_INT        reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_FLOAT      reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_DOUBLE     reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_BYTE       reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_BOOLEAN    reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_CHAR       reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_STRING     reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_LONG       reduce using rule 6 (visibility -> PRIVATE .)
    TYPE_VOID       reduce using rule 6 (visibility -> PRIVATE .)


state 6

    (7) visibility -> PROTECTED .

    ABSTRACT        reduce using rule 7 (visibility -> PROTECTED .)
    FINAL           reduce using rule 7 (visibility -> PROTECTED .)
    PACKAGE         reduce using rule 7 (visibility -> PROTECTED .)
    CLASS           reduce using rule 7 (visibility -> PROTECTED .)
    STATIC          reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_INT        reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_FLOAT      reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_DOUBLE     reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_BYTE       reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_BOOLEAN    reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_CHAR       reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_STRING     reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_LONG       reduce using rule 7 (visibility -> PROTECTED .)
    TYPE_VOID       reduce using rule 7 (visibility -> PROTECTED .)


state 7

    (2) class -> visibility classmodifier . CLASS ID EXTENDS ID LCHAV membros RCHAV
    (3) class -> visibility classmodifier . CLASS ID LCHAV membros RCHAV
    (4) class -> visibility classmodifier . CLASS ID IMPLEMENTS LCHAV membros RCHAV

    CLASS           shift and go to state 11


state 8

    (10) classmodifier -> ABSTRACT .

    CLASS           reduce using rule 10 (classmodifier -> ABSTRACT .)


state 9

    (11) classmodifier -> FINAL .

    CLASS           reduce using rule 11 (classmodifier -> FINAL .)


state 10

    (12) classmodifier -> PACKAGE .

    CLASS           reduce using rule 12 (classmodifier -> PACKAGE .)


state 11

    (2) class -> visibility classmodifier CLASS . ID EXTENDS ID LCHAV membros RCHAV
    (3) class -> visibility classmodifier CLASS . ID LCHAV membros RCHAV
    (4) class -> visibility classmodifier CLASS . ID IMPLEMENTS LCHAV membros RCHAV

    ID              shift and go to state 12


state 12

    (2) class -> visibility classmodifier CLASS ID . EXTENDS ID LCHAV membros RCHAV
    (3) class -> visibility classmodifier CLASS ID . LCHAV membros RCHAV
    (4) class -> visibility classmodifier CLASS ID . IMPLEMENTS LCHAV membros RCHAV

    EXTENDS         shift and go to state 13
    LCHAV           shift and go to state 14
    IMPLEMENTS      shift and go to state 15


state 13

    (2) class -> visibility classmodifier CLASS ID EXTENDS . ID LCHAV membros RCHAV

    ID              shift and go to state 16


state 14

    (3) class -> visibility classmodifier CLASS ID LCHAV . membros RCHAV
    (13) membros -> . membro
    (14) membros -> . membro membros
    (15) membro -> . atribute
    (16) membro -> . function
    (17) atribute -> . visibility atributemodifier type ID SEMICOLON
    (18) atribute -> . visibility atributemodifier type ID EQUAL expression SEMICOLON
    (22) function -> . signature body
    (5) visibility -> . PUBLIC
    (6) visibility -> . PRIVATE
    (7) visibility -> . PROTECTED
    (8) visibility -> .
    (23) signature -> . visibility atributemodifier type ID LPAREN sigparams RPAREN
    (24) signature -> . visibility atributemodifier type brackets_expression ID LPAREN sigparams RPAREN

    PUBLIC          shift and go to state 4
    PRIVATE         shift and go to state 5
    PROTECTED       shift and go to state 6
    STATIC          reduce using rule 8 (visibility -> .)
    FINAL           reduce using rule 8 (visibility -> .)
    TYPE_INT        reduce using rule 8 (visibility -> .)
    TYPE_FLOAT      reduce using rule 8 (visibility -> .)
    TYPE_DOUBLE     reduce using rule 8 (visibility -> .)
    TYPE_BYTE       reduce using rule 8 (visibility -> .)
    TYPE_BOOLEAN    reduce using rule 8 (visibility -> .)
    TYPE_CHAR       reduce using rule 8 (visibility -> .)
    TYPE_STRING     reduce using rule 8 (visibility -> .)
    TYPE_LONG       reduce using rule 8 (visibility -> .)
    TYPE_VOID       reduce using rule 8 (visibility -> .)

    visibility                     shift and go to state 17
    membros                        shift and go to state 18
    membro                         shift and go to state 19
    atribute                       shift and go to state 20
    function                       shift and go to state 21
    signature                      shift and go to state 22

state 15

    (4) class -> visibility classmodifier CLASS ID IMPLEMENTS . LCHAV membros RCHAV

    LCHAV           shift and go to state 23


state 16

    (2) class -> visibility classmodifier CLASS ID EXTENDS ID . LCHAV membros RCHAV

    LCHAV           shift and go to state 24


state 17

    (17) atribute -> visibility . atributemodifier type ID SEMICOLON
    (18) atribute -> visibility . atributemodifier type ID EQUAL expression SEMICOLON
    (23) signature -> visibility . atributemodifier type ID LPAREN sigparams RPAREN
    (24) signature -> visibility . atributemodifier type brackets_expression ID LPAREN sigparams RPAREN
    (19) atributemodifier -> .
    (20) atributemodifier -> . STATIC
    (21) atributemodifier -> . FINAL

    TYPE_INT        reduce using rule 19 (atributemodifier -> .)
    TYPE_FLOAT      reduce using rule 19 (atributemodifier -> .)
    TYPE_DOUBLE     reduce using rule 19 (atributemodifier -> .)
    TYPE_BYTE       reduce using rule 19 (atributemodifier -> .)
    TYPE_BOOLEAN    reduce using rule 19 (atributemodifier -> .)
    TYPE_CHAR       reduce using rule 19 (atributemodifier -> .)
    TYPE_STRING     reduce using rule 19 (atributemodifier -> .)
    TYPE_LONG       reduce using rule 19 (atributemodifier -> .)
    TYPE_VOID       reduce using rule 19 (atributemodifier -> .)
    STATIC          shift and go to state 26
    FINAL           shift and go to state 27

    atributemodifier               shift and go to state 25

state 18

    (3) class -> visibility classmodifier CLASS ID LCHAV membros . RCHAV

    RCHAV           shift and go to state 28


state 19

    (13) membros -> membro .
    (14) membros -> membro . membros
    (13) membros -> . membro
    (14) membros -> . membro membros
    (15) membro -> . atribute
    (16) membro -> . function
    (17) atribute -> . visibility atributemodifier type ID SEMICOLON
    (18) atribute -> . visibility atributemodifier type ID EQUAL expression SEMICOLON
    (22) function -> . signature body
    (5) visibility -> . PUBLIC
    (6) visibility -> . PRIVATE
    (7) visibility -> . PROTECTED
    (8) visibility -> .
    (23) signature -> . visibility atributemodifier type ID LPAREN sigparams RPAREN
    (24) signature -> . visibility atributemodifier type brackets_expression ID LPAREN sigparams RPAREN

    RCHAV           reduce using rule 13 (membros -> membro .)
    PUBLIC          shift and go to state 4
    PRIVATE         shift and go to state 5
    PROTECTED       shift and go to state 6
    STATIC          reduce using rule 8 (visibility -> .)
    FINAL           reduce using rule 8 (visibility -> .)
    TYPE_INT        reduce using rule 8 (visibility -> .)
    TYPE_FLOAT      reduce using rule 8 (visibility -> .)
    TYPE_DOUBLE     reduce using rule 8 (visibility -> .)
    TYPE_BYTE       reduce using rule 8 (visibility -> .)
    TYPE_BOOLEAN    reduce using rule 8 (visibility -> .)
    TYPE_CHAR       reduce using rule 8 (visibility -> .)
    TYPE_STRING     reduce using rule 8 (visibility -> .)
    TYPE_LONG       reduce using rule 8 (visibility -> .)
    TYPE_VOID       reduce using rule 8 (visibility -> .)

    membro                         shift and go to state 19
    membros                        shift and go to state 29
    atribute                       shift and go to state 20
    function                       shift and go to state 21
    visibility                     shift and go to state 17
    signature                      shift and go to state 22

state 20

    (15) membro -> atribute .

    PUBLIC          reduce using rule 15 (membro -> atribute .)
    PRIVATE         reduce using rule 15 (membro -> atribute .)
    PROTECTED       reduce using rule 15 (membro -> atribute .)
    STATIC          reduce using rule 15 (membro -> atribute .)
    FINAL           reduce using rule 15 (membro -> atribute .)
    TYPE_INT        reduce using rule 15 (membro -> atribute .)
    TYPE_FLOAT      reduce using rule 15 (membro -> atribute .)
    TYPE_DOUBLE     reduce using rule 15 (membro -> atribute .)
    TYPE_BYTE       reduce using rule 15 (membro -> atribute .)
    TYPE_BOOLEAN    reduce using rule 15 (membro -> atribute .)
    TYPE_CHAR       reduce using rule 15 (membro -> atribute .)
    TYPE_STRING     reduce using rule 15 (membro -> atribute .)
    TYPE_LONG       reduce using rule 15 (membro -> atribute .)
    TYPE_VOID       reduce using rule 15 (membro -> atribute .)
    RCHAV           reduce using rule 15 (membro -> atribute .)


state 21

    (16) membro -> function .

    PUBLIC          reduce using rule 16 (membro -> function .)
    PRIVATE         reduce using rule 16 (membro -> function .)
    PROTECTED       reduce using rule 16 (membro -> function .)
    STATIC          reduce using rule 16 (membro -> function .)
    FINAL           reduce using rule 16 (membro -> function .)
    TYPE_INT        reduce using rule 16 (membro -> function .)
    TYPE_FLOAT      reduce using rule 16 (membro -> function .)
    TYPE_DOUBLE     reduce using rule 16 (membro -> function .)
    TYPE_BYTE       reduce using rule 16 (membro -> function .)
    TYPE_BOOLEAN    reduce using rule 16 (membro -> function .)
    TYPE_CHAR       reduce using rule 16 (membro -> function .)
    TYPE_STRING     reduce using rule 16 (membro -> function .)
    TYPE_LONG       reduce using rule 16 (membro -> function .)
    TYPE_VOID       reduce using rule 16 (membro -> function .)
    RCHAV           reduce using rule 16 (membro -> function .)


state 22

    (22) function -> signature . body
    (27) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 31

    body                           shift and go to state 30

state 23

    (4) class -> visibility classmodifier CLASS ID IMPLEMENTS LCHAV . membros RCHAV
    (13) membros -> . membro
    (14) membros -> . membro membros
    (15) membro -> . atribute
    (16) membro -> . function
    (17) atribute -> . visibility atributemodifier type ID SEMICOLON
    (18) atribute -> . visibility atributemodifier type ID EQUAL expression SEMICOLON
    (22) function -> . signature body
    (5) visibility -> . PUBLIC
    (6) visibility -> . PRIVATE
    (7) visibility -> . PROTECTED
    (8) visibility -> .
    (23) signature -> . visibility atributemodifier type ID LPAREN sigparams RPAREN
    (24) signature -> . visibility atributemodifier type brackets_expression ID LPAREN sigparams RPAREN

    PUBLIC          shift and go to state 4
    PRIVATE         shift and go to state 5
    PROTECTED       shift and go to state 6
    STATIC          reduce using rule 8 (visibility -> .)
    FINAL           reduce using rule 8 (visibility -> .)
    TYPE_INT        reduce using rule 8 (visibility -> .)
    TYPE_FLOAT      reduce using rule 8 (visibility -> .)
    TYPE_DOUBLE     reduce using rule 8 (visibility -> .)
    TYPE_BYTE       reduce using rule 8 (visibility -> .)
    TYPE_BOOLEAN    reduce using rule 8 (visibility -> .)
    TYPE_CHAR       reduce using rule 8 (visibility -> .)
    TYPE_STRING     reduce using rule 8 (visibility -> .)
    TYPE_LONG       reduce using rule 8 (visibility -> .)
    TYPE_VOID       reduce using rule 8 (visibility -> .)

    visibility                     shift and go to state 17
    membros                        shift and go to state 32
    membro                         shift and go to state 19
    atribute                       shift and go to state 20
    function                       shift and go to state 21
    signature                      shift and go to state 22

state 24

    (2) class -> visibility classmodifier CLASS ID EXTENDS ID LCHAV . membros RCHAV
    (13) membros -> . membro
    (14) membros -> . membro membros
    (15) membro -> . atribute
    (16) membro -> . function
    (17) atribute -> . visibility atributemodifier type ID SEMICOLON
    (18) atribute -> . visibility atributemodifier type ID EQUAL expression SEMICOLON
    (22) function -> . signature body
    (5) visibility -> . PUBLIC
    (6) visibility -> . PRIVATE
    (7) visibility -> . PROTECTED
    (8) visibility -> .
    (23) signature -> . visibility atributemodifier type ID LPAREN sigparams RPAREN
    (24) signature -> . visibility atributemodifier type brackets_expression ID LPAREN sigparams RPAREN

    PUBLIC          shift and go to state 4
    PRIVATE         shift and go to state 5
    PROTECTED       shift and go to state 6
    STATIC          reduce using rule 8 (visibility -> .)
    FINAL           reduce using rule 8 (visibility -> .)
    TYPE_INT        reduce using rule 8 (visibility -> .)
    TYPE_FLOAT      reduce using rule 8 (visibility -> .)
    TYPE_DOUBLE     reduce using rule 8 (visibility -> .)
    TYPE_BYTE       reduce using rule 8 (visibility -> .)
    TYPE_BOOLEAN    reduce using rule 8 (visibility -> .)
    TYPE_CHAR       reduce using rule 8 (visibility -> .)
    TYPE_STRING     reduce using rule 8 (visibility -> .)
    TYPE_LONG       reduce using rule 8 (visibility -> .)
    TYPE_VOID       reduce using rule 8 (visibility -> .)

    visibility                     shift and go to state 17
    membros                        shift and go to state 33
    membro                         shift and go to state 19
    atribute                       shift and go to state 20
    function                       shift and go to state 21
    signature                      shift and go to state 22

state 25

    (17) atribute -> visibility atributemodifier . type ID SEMICOLON
    (18) atribute -> visibility atributemodifier . type ID EQUAL expression SEMICOLON
    (23) signature -> visibility atributemodifier . type ID LPAREN sigparams RPAREN
    (24) signature -> visibility atributemodifier . type brackets_expression ID LPAREN sigparams RPAREN
    (98) type -> . primitivetypes
    (99) primitivetypes -> . TYPE_INT
    (100) primitivetypes -> . TYPE_FLOAT
    (101) primitivetypes -> . TYPE_DOUBLE
    (102) primitivetypes -> . TYPE_BYTE
    (103) primitivetypes -> . TYPE_BOOLEAN
    (104) primitivetypes -> . TYPE_CHAR
    (105) primitivetypes -> . TYPE_STRING
    (106) primitivetypes -> . TYPE_LONG
    (107) primitivetypes -> . TYPE_VOID

    TYPE_INT        shift and go to state 36
    TYPE_FLOAT      shift and go to state 37
    TYPE_DOUBLE     shift and go to state 38
    TYPE_BYTE       shift and go to state 39
    TYPE_BOOLEAN    shift and go to state 40
    TYPE_CHAR       shift and go to state 41
    TYPE_STRING     shift and go to state 42
    TYPE_LONG       shift and go to state 43
    TYPE_VOID       shift and go to state 44

    type                           shift and go to state 34
    primitivetypes                 shift and go to state 35

state 26

    (20) atributemodifier -> STATIC .

    TYPE_INT        reduce using rule 20 (atributemodifier -> STATIC .)
    TYPE_FLOAT      reduce using rule 20 (atributemodifier -> STATIC .)
    TYPE_DOUBLE     reduce using rule 20 (atributemodifier -> STATIC .)
    TYPE_BYTE       reduce using rule 20 (atributemodifier -> STATIC .)
    TYPE_BOOLEAN    reduce using rule 20 (atributemodifier -> STATIC .)
    TYPE_CHAR       reduce using rule 20 (atributemodifier -> STATIC .)
    TYPE_STRING     reduce using rule 20 (atributemodifier -> STATIC .)
    TYPE_LONG       reduce using rule 20 (atributemodifier -> STATIC .)
    TYPE_VOID       reduce using rule 20 (atributemodifier -> STATIC .)


state 27

    (21) atributemodifier -> FINAL .

    TYPE_INT        reduce using rule 21 (atributemodifier -> FINAL .)
    TYPE_FLOAT      reduce using rule 21 (atributemodifier -> FINAL .)
    TYPE_DOUBLE     reduce using rule 21 (atributemodifier -> FINAL .)
    TYPE_BYTE       reduce using rule 21 (atributemodifier -> FINAL .)
    TYPE_BOOLEAN    reduce using rule 21 (atributemodifier -> FINAL .)
    TYPE_CHAR       reduce using rule 21 (atributemodifier -> FINAL .)
    TYPE_STRING     reduce using rule 21 (atributemodifier -> FINAL .)
    TYPE_LONG       reduce using rule 21 (atributemodifier -> FINAL .)
    TYPE_VOID       reduce using rule 21 (atributemodifier -> FINAL .)


state 28

    (3) class -> visibility classmodifier CLASS ID LCHAV membros RCHAV .

    $end            reduce using rule 3 (class -> visibility classmodifier CLASS ID LCHAV membros RCHAV .)


state 29

    (14) membros -> membro membros .

    RCHAV           reduce using rule 14 (membros -> membro membros .)


state 30

    (22) function -> signature body .

    PUBLIC          reduce using rule 22 (function -> signature body .)
    PRIVATE         reduce using rule 22 (function -> signature body .)
    PROTECTED       reduce using rule 22 (function -> signature body .)
    STATIC          reduce using rule 22 (function -> signature body .)
    FINAL           reduce using rule 22 (function -> signature body .)
    TYPE_INT        reduce using rule 22 (function -> signature body .)
    TYPE_FLOAT      reduce using rule 22 (function -> signature body .)
    TYPE_DOUBLE     reduce using rule 22 (function -> signature body .)
    TYPE_BYTE       reduce using rule 22 (function -> signature body .)
    TYPE_BOOLEAN    reduce using rule 22 (function -> signature body .)
    TYPE_CHAR       reduce using rule 22 (function -> signature body .)
    TYPE_STRING     reduce using rule 22 (function -> signature body .)
    TYPE_LONG       reduce using rule 22 (function -> signature body .)
    TYPE_VOID       reduce using rule 22 (function -> signature body .)
    RCHAV           reduce using rule 22 (function -> signature body .)


state 31

    (27) body -> LCHAV . stms RCHAV
    (28) stms -> . stm
    (29) stms -> . stm stms
    (30) stm -> . expression SEMICOLON
    (31) stm -> . WHILE LPAREN expression RPAREN bodyorstm
    (32) stm -> . DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON
    (33) stm -> . FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm
    (34) stm -> . IF LPAREN expression RPAREN bodyorstm
    (35) stm -> . IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm
    (36) stm -> . IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm
    (37) stm -> . SEMICOLON
    (38) stm -> . atributemodifier type ID SEMICOLON
    (39) stm -> . atributemodifier type ID EQUAL expression SEMICOLON
    (40) stm -> . RETURN expression SEMICOLON
    (41) stm -> . RETURN SEMICOLON
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (19) atributemodifier -> .
    (20) atributemodifier -> . STATIC
    (21) atributemodifier -> . FINAL
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    WHILE           shift and go to state 49
    DO              shift and go to state 50
    FOR             shift and go to state 51
    IF              shift and go to state 52
    SEMICOLON       shift and go to state 48
    RETURN          shift and go to state 55
    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    TYPE_INT        reduce using rule 19 (atributemodifier -> .)
    TYPE_FLOAT      reduce using rule 19 (atributemodifier -> .)
    TYPE_DOUBLE     reduce using rule 19 (atributemodifier -> .)
    TYPE_BYTE       reduce using rule 19 (atributemodifier -> .)
    TYPE_BOOLEAN    reduce using rule 19 (atributemodifier -> .)
    TYPE_CHAR       reduce using rule 19 (atributemodifier -> .)
    TYPE_STRING     reduce using rule 19 (atributemodifier -> .)
    TYPE_LONG       reduce using rule 19 (atributemodifier -> .)
    TYPE_VOID       reduce using rule 19 (atributemodifier -> .)
    STATIC          shift and go to state 26
    FINAL           shift and go to state 27
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    stms                           shift and go to state 45
    stm                            shift and go to state 46
    expression                     shift and go to state 47
    atributemodifier               shift and go to state 53
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 32

    (4) class -> visibility classmodifier CLASS ID IMPLEMENTS LCHAV membros . RCHAV

    RCHAV           shift and go to state 69


state 33

    (2) class -> visibility classmodifier CLASS ID EXTENDS ID LCHAV membros . RCHAV

    RCHAV           shift and go to state 70


state 34

    (17) atribute -> visibility atributemodifier type . ID SEMICOLON
    (18) atribute -> visibility atributemodifier type . ID EQUAL expression SEMICOLON
    (23) signature -> visibility atributemodifier type . ID LPAREN sigparams RPAREN
    (24) signature -> visibility atributemodifier type . brackets_expression ID LPAREN sigparams RPAREN
    (95) brackets_expression -> . LBRACKET RBRACKET
    (96) brackets_expression -> . LBRACKET INT_NUMBER RBRACKET
    (97) brackets_expression -> . LBRACKET ID RBRACKET

    ID              shift and go to state 71
    LBRACKET        shift and go to state 73

    brackets_expression            shift and go to state 72

state 35

    (98) type -> primitivetypes .

    ID              reduce using rule 98 (type -> primitivetypes .)
    LBRACKET        reduce using rule 98 (type -> primitivetypes .)
    LPAREN          reduce using rule 98 (type -> primitivetypes .)


state 36

    (99) primitivetypes -> TYPE_INT .

    ID              reduce using rule 99 (primitivetypes -> TYPE_INT .)
    LBRACKET        reduce using rule 99 (primitivetypes -> TYPE_INT .)
    LPAREN          reduce using rule 99 (primitivetypes -> TYPE_INT .)


state 37

    (100) primitivetypes -> TYPE_FLOAT .

    ID              reduce using rule 100 (primitivetypes -> TYPE_FLOAT .)
    LBRACKET        reduce using rule 100 (primitivetypes -> TYPE_FLOAT .)
    LPAREN          reduce using rule 100 (primitivetypes -> TYPE_FLOAT .)


state 38

    (101) primitivetypes -> TYPE_DOUBLE .

    ID              reduce using rule 101 (primitivetypes -> TYPE_DOUBLE .)
    LBRACKET        reduce using rule 101 (primitivetypes -> TYPE_DOUBLE .)
    LPAREN          reduce using rule 101 (primitivetypes -> TYPE_DOUBLE .)


state 39

    (102) primitivetypes -> TYPE_BYTE .

    ID              reduce using rule 102 (primitivetypes -> TYPE_BYTE .)
    LBRACKET        reduce using rule 102 (primitivetypes -> TYPE_BYTE .)
    LPAREN          reduce using rule 102 (primitivetypes -> TYPE_BYTE .)


state 40

    (103) primitivetypes -> TYPE_BOOLEAN .

    ID              reduce using rule 103 (primitivetypes -> TYPE_BOOLEAN .)
    LBRACKET        reduce using rule 103 (primitivetypes -> TYPE_BOOLEAN .)
    LPAREN          reduce using rule 103 (primitivetypes -> TYPE_BOOLEAN .)


state 41

    (104) primitivetypes -> TYPE_CHAR .

    ID              reduce using rule 104 (primitivetypes -> TYPE_CHAR .)
    LBRACKET        reduce using rule 104 (primitivetypes -> TYPE_CHAR .)
    LPAREN          reduce using rule 104 (primitivetypes -> TYPE_CHAR .)


state 42

    (105) primitivetypes -> TYPE_STRING .

    ID              reduce using rule 105 (primitivetypes -> TYPE_STRING .)
    LBRACKET        reduce using rule 105 (primitivetypes -> TYPE_STRING .)
    LPAREN          reduce using rule 105 (primitivetypes -> TYPE_STRING .)


state 43

    (106) primitivetypes -> TYPE_LONG .

    ID              reduce using rule 106 (primitivetypes -> TYPE_LONG .)
    LBRACKET        reduce using rule 106 (primitivetypes -> TYPE_LONG .)
    LPAREN          reduce using rule 106 (primitivetypes -> TYPE_LONG .)


state 44

    (107) primitivetypes -> TYPE_VOID .

    ID              reduce using rule 107 (primitivetypes -> TYPE_VOID .)
    LBRACKET        reduce using rule 107 (primitivetypes -> TYPE_VOID .)
    LPAREN          reduce using rule 107 (primitivetypes -> TYPE_VOID .)


state 45

    (27) body -> LCHAV stms . RCHAV

    RCHAV           shift and go to state 74


state 46

    (28) stms -> stm .
    (29) stms -> stm . stms
    (28) stms -> . stm
    (29) stms -> . stm stms
    (30) stm -> . expression SEMICOLON
    (31) stm -> . WHILE LPAREN expression RPAREN bodyorstm
    (32) stm -> . DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON
    (33) stm -> . FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm
    (34) stm -> . IF LPAREN expression RPAREN bodyorstm
    (35) stm -> . IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm
    (36) stm -> . IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm
    (37) stm -> . SEMICOLON
    (38) stm -> . atributemodifier type ID SEMICOLON
    (39) stm -> . atributemodifier type ID EQUAL expression SEMICOLON
    (40) stm -> . RETURN expression SEMICOLON
    (41) stm -> . RETURN SEMICOLON
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (19) atributemodifier -> .
    (20) atributemodifier -> . STATIC
    (21) atributemodifier -> . FINAL
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    RCHAV           reduce using rule 28 (stms -> stm .)
    WHILE           shift and go to state 49
    DO              shift and go to state 50
    FOR             shift and go to state 51
    IF              shift and go to state 52
    SEMICOLON       shift and go to state 48
    RETURN          shift and go to state 55
    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    TYPE_INT        reduce using rule 19 (atributemodifier -> .)
    TYPE_FLOAT      reduce using rule 19 (atributemodifier -> .)
    TYPE_DOUBLE     reduce using rule 19 (atributemodifier -> .)
    TYPE_BYTE       reduce using rule 19 (atributemodifier -> .)
    TYPE_BOOLEAN    reduce using rule 19 (atributemodifier -> .)
    TYPE_CHAR       reduce using rule 19 (atributemodifier -> .)
    TYPE_STRING     reduce using rule 19 (atributemodifier -> .)
    TYPE_LONG       reduce using rule 19 (atributemodifier -> .)
    TYPE_VOID       reduce using rule 19 (atributemodifier -> .)
    STATIC          shift and go to state 26
    FINAL           shift and go to state 27
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    stm                            shift and go to state 46
    stms                           shift and go to state 75
    expression                     shift and go to state 47
    atributemodifier               shift and go to state 53
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 47

    (30) stm -> expression . SEMICOLON
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       shift and go to state 76
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

    operatorbittobit               shift and go to state 93

state 48

    (37) stm -> SEMICOLON .

    WHILE           reduce using rule 37 (stm -> SEMICOLON .)
    DO              reduce using rule 37 (stm -> SEMICOLON .)
    FOR             reduce using rule 37 (stm -> SEMICOLON .)
    IF              reduce using rule 37 (stm -> SEMICOLON .)
    SEMICOLON       reduce using rule 37 (stm -> SEMICOLON .)
    RETURN          reduce using rule 37 (stm -> SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 37 (stm -> SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 37 (stm -> SEMICOLON .)
    INT_NUMBER      reduce using rule 37 (stm -> SEMICOLON .)
    STRING          reduce using rule 37 (stm -> SEMICOLON .)
    ID              reduce using rule 37 (stm -> SEMICOLON .)
    NEW             reduce using rule 37 (stm -> SEMICOLON .)
    STATIC          reduce using rule 37 (stm -> SEMICOLON .)
    FINAL           reduce using rule 37 (stm -> SEMICOLON .)
    INCREMENT       reduce using rule 37 (stm -> SEMICOLON .)
    DECREMENT       reduce using rule 37 (stm -> SEMICOLON .)
    MINUS           reduce using rule 37 (stm -> SEMICOLON .)
    PLUS            reduce using rule 37 (stm -> SEMICOLON .)
    NOT             reduce using rule 37 (stm -> SEMICOLON .)
    TYPE_INT        reduce using rule 37 (stm -> SEMICOLON .)
    TYPE_FLOAT      reduce using rule 37 (stm -> SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 37 (stm -> SEMICOLON .)
    TYPE_BYTE       reduce using rule 37 (stm -> SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 37 (stm -> SEMICOLON .)
    TYPE_CHAR       reduce using rule 37 (stm -> SEMICOLON .)
    TYPE_STRING     reduce using rule 37 (stm -> SEMICOLON .)
    TYPE_LONG       reduce using rule 37 (stm -> SEMICOLON .)
    TYPE_VOID       reduce using rule 37 (stm -> SEMICOLON .)
    RCHAV           reduce using rule 37 (stm -> SEMICOLON .)


state 49

    (31) stm -> WHILE . LPAREN expression RPAREN bodyorstm

    LPAREN          shift and go to state 97


state 50

    (32) stm -> DO . bodyorstm WHILE LPAREN expression RPAREN SEMICOLON
    (42) bodyorstm -> . body
    (27) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 31

    bodyorstm                      shift and go to state 98
    body                           shift and go to state 99

state 51

    (33) stm -> FOR . LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm

    LPAREN          shift and go to state 100


state 52

    (34) stm -> IF . LPAREN expression RPAREN bodyorstm
    (35) stm -> IF . LPAREN expression RPAREN bodyorstm ELSE bodyorstm
    (36) stm -> IF . LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm

    LPAREN          shift and go to state 101


state 53

    (38) stm -> atributemodifier . type ID SEMICOLON
    (39) stm -> atributemodifier . type ID EQUAL expression SEMICOLON
    (98) type -> . primitivetypes
    (99) primitivetypes -> . TYPE_INT
    (100) primitivetypes -> . TYPE_FLOAT
    (101) primitivetypes -> . TYPE_DOUBLE
    (102) primitivetypes -> . TYPE_BYTE
    (103) primitivetypes -> . TYPE_BOOLEAN
    (104) primitivetypes -> . TYPE_CHAR
    (105) primitivetypes -> . TYPE_STRING
    (106) primitivetypes -> . TYPE_LONG
    (107) primitivetypes -> . TYPE_VOID

    TYPE_INT        shift and go to state 36
    TYPE_FLOAT      shift and go to state 37
    TYPE_DOUBLE     shift and go to state 38
    TYPE_BYTE       shift and go to state 39
    TYPE_BOOLEAN    shift and go to state 40
    TYPE_CHAR       shift and go to state 41
    TYPE_STRING     shift and go to state 42
    TYPE_LONG       shift and go to state 43
    TYPE_VOID       shift and go to state 44

    type                           shift and go to state 102
    primitivetypes                 shift and go to state 35

state 54

    (51) expression -> ID .
    (59) operator -> ID . EQUAL expression
    (60) operator -> ID . MINUS_EQ expression
    (61) operator -> ID . TIMES_EQ expression
    (62) operator -> ID . PLUS_EQ expression
    (63) operator -> ID . DIVIDE_EQ expression
    (64) operator -> ID . MOD_EQ expression
    (65) operator -> ID . BITWISE_AND_EQ expression
    (66) operator -> ID . BITWISE_OR_EQ expression
    (67) operator -> ID . BITWISE_XOR_EQ expression
    (68) operator -> ID . URSHIFT_EQ expression
    (69) operator -> ID . LSHIFT_EQ expression
    (70) operator -> ID . RSHIFT_EQ expression
    (83) operator -> ID . unaryoperatorsufx
    (108) call -> ID . LPAREN params_call RPAREN
    (109) call -> ID . LPAREN RPAREN
    (90) unaryoperatorsufx -> . INCREMENT
    (91) unaryoperatorsufx -> . DECREMENT

    SEMICOLON       reduce using rule 51 (expression -> ID .)
    TIMES           reduce using rule 51 (expression -> ID .)
    DIVIDE          reduce using rule 51 (expression -> ID .)
    MODULE          reduce using rule 51 (expression -> ID .)
    PLUS            reduce using rule 51 (expression -> ID .)
    MINUS           reduce using rule 51 (expression -> ID .)
    LEQ             reduce using rule 51 (expression -> ID .)
    GEQ             reduce using rule 51 (expression -> ID .)
    LT              reduce using rule 51 (expression -> ID .)
    GT              reduce using rule 51 (expression -> ID .)
    NEQ             reduce using rule 51 (expression -> ID .)
    EQ              reduce using rule 51 (expression -> ID .)
    AND             reduce using rule 51 (expression -> ID .)
    OR              reduce using rule 51 (expression -> ID .)
    BITWISE_AND     reduce using rule 51 (expression -> ID .)
    BITWISE_OR      reduce using rule 51 (expression -> ID .)
    BITWISE_XOR     reduce using rule 51 (expression -> ID .)
    URSHIFT         reduce using rule 51 (expression -> ID .)
    LSHIFT          reduce using rule 51 (expression -> ID .)
    RSHIFT          reduce using rule 51 (expression -> ID .)
    RPAREN          reduce using rule 51 (expression -> ID .)
    COMMA           reduce using rule 51 (expression -> ID .)
    RBRACKET        reduce using rule 51 (expression -> ID .)
    EQUAL           shift and go to state 103
    MINUS_EQ        shift and go to state 104
    TIMES_EQ        shift and go to state 105
    PLUS_EQ         shift and go to state 106
    DIVIDE_EQ       shift and go to state 107
    MOD_EQ          shift and go to state 108
    BITWISE_AND_EQ  shift and go to state 109
    BITWISE_OR_EQ   shift and go to state 110
    BITWISE_XOR_EQ  shift and go to state 111
    URSHIFT_EQ      shift and go to state 112
    LSHIFT_EQ       shift and go to state 113
    RSHIFT_EQ       shift and go to state 114
    LPAREN          shift and go to state 116
    INCREMENT       shift and go to state 117
    DECREMENT       shift and go to state 118

    unaryoperatorsufx              shift and go to state 115

state 55

    (40) stm -> RETURN . expression SEMICOLON
    (41) stm -> RETURN . SEMICOLON
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    SEMICOLON       shift and go to state 120
    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 119
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 56

    (45) expression -> operator .

    SEMICOLON       reduce using rule 45 (expression -> operator .)
    TIMES           reduce using rule 45 (expression -> operator .)
    DIVIDE          reduce using rule 45 (expression -> operator .)
    MODULE          reduce using rule 45 (expression -> operator .)
    PLUS            reduce using rule 45 (expression -> operator .)
    MINUS           reduce using rule 45 (expression -> operator .)
    LEQ             reduce using rule 45 (expression -> operator .)
    GEQ             reduce using rule 45 (expression -> operator .)
    LT              reduce using rule 45 (expression -> operator .)
    GT              reduce using rule 45 (expression -> operator .)
    NEQ             reduce using rule 45 (expression -> operator .)
    EQ              reduce using rule 45 (expression -> operator .)
    AND             reduce using rule 45 (expression -> operator .)
    OR              reduce using rule 45 (expression -> operator .)
    BITWISE_AND     reduce using rule 45 (expression -> operator .)
    BITWISE_OR      reduce using rule 45 (expression -> operator .)
    BITWISE_XOR     reduce using rule 45 (expression -> operator .)
    URSHIFT         reduce using rule 45 (expression -> operator .)
    LSHIFT          reduce using rule 45 (expression -> operator .)
    RSHIFT          reduce using rule 45 (expression -> operator .)
    RPAREN          reduce using rule 45 (expression -> operator .)
    COMMA           reduce using rule 45 (expression -> operator .)
    RBRACKET        reduce using rule 45 (expression -> operator .)


state 57

    (46) expression -> call .

    SEMICOLON       reduce using rule 46 (expression -> call .)
    TIMES           reduce using rule 46 (expression -> call .)
    DIVIDE          reduce using rule 46 (expression -> call .)
    MODULE          reduce using rule 46 (expression -> call .)
    PLUS            reduce using rule 46 (expression -> call .)
    MINUS           reduce using rule 46 (expression -> call .)
    LEQ             reduce using rule 46 (expression -> call .)
    GEQ             reduce using rule 46 (expression -> call .)
    LT              reduce using rule 46 (expression -> call .)
    GT              reduce using rule 46 (expression -> call .)
    NEQ             reduce using rule 46 (expression -> call .)
    EQ              reduce using rule 46 (expression -> call .)
    AND             reduce using rule 46 (expression -> call .)
    OR              reduce using rule 46 (expression -> call .)
    BITWISE_AND     reduce using rule 46 (expression -> call .)
    BITWISE_OR      reduce using rule 46 (expression -> call .)
    BITWISE_XOR     reduce using rule 46 (expression -> call .)
    URSHIFT         reduce using rule 46 (expression -> call .)
    LSHIFT          reduce using rule 46 (expression -> call .)
    RSHIFT          reduce using rule 46 (expression -> call .)
    RPAREN          reduce using rule 46 (expression -> call .)
    COMMA           reduce using rule 46 (expression -> call .)
    RBRACKET        reduce using rule 46 (expression -> call .)


state 58

    (47) expression -> FLOAT_NUMBER .

    SEMICOLON       reduce using rule 47 (expression -> FLOAT_NUMBER .)
    TIMES           reduce using rule 47 (expression -> FLOAT_NUMBER .)
    DIVIDE          reduce using rule 47 (expression -> FLOAT_NUMBER .)
    MODULE          reduce using rule 47 (expression -> FLOAT_NUMBER .)
    PLUS            reduce using rule 47 (expression -> FLOAT_NUMBER .)
    MINUS           reduce using rule 47 (expression -> FLOAT_NUMBER .)
    LEQ             reduce using rule 47 (expression -> FLOAT_NUMBER .)
    GEQ             reduce using rule 47 (expression -> FLOAT_NUMBER .)
    LT              reduce using rule 47 (expression -> FLOAT_NUMBER .)
    GT              reduce using rule 47 (expression -> FLOAT_NUMBER .)
    NEQ             reduce using rule 47 (expression -> FLOAT_NUMBER .)
    EQ              reduce using rule 47 (expression -> FLOAT_NUMBER .)
    AND             reduce using rule 47 (expression -> FLOAT_NUMBER .)
    OR              reduce using rule 47 (expression -> FLOAT_NUMBER .)
    BITWISE_AND     reduce using rule 47 (expression -> FLOAT_NUMBER .)
    BITWISE_OR      reduce using rule 47 (expression -> FLOAT_NUMBER .)
    BITWISE_XOR     reduce using rule 47 (expression -> FLOAT_NUMBER .)
    URSHIFT         reduce using rule 47 (expression -> FLOAT_NUMBER .)
    LSHIFT          reduce using rule 47 (expression -> FLOAT_NUMBER .)
    RSHIFT          reduce using rule 47 (expression -> FLOAT_NUMBER .)
    RPAREN          reduce using rule 47 (expression -> FLOAT_NUMBER .)
    COMMA           reduce using rule 47 (expression -> FLOAT_NUMBER .)
    RBRACKET        reduce using rule 47 (expression -> FLOAT_NUMBER .)


state 59

    (48) expression -> DOUBLE_NUMBER .

    SEMICOLON       reduce using rule 48 (expression -> DOUBLE_NUMBER .)
    TIMES           reduce using rule 48 (expression -> DOUBLE_NUMBER .)
    DIVIDE          reduce using rule 48 (expression -> DOUBLE_NUMBER .)
    MODULE          reduce using rule 48 (expression -> DOUBLE_NUMBER .)
    PLUS            reduce using rule 48 (expression -> DOUBLE_NUMBER .)
    MINUS           reduce using rule 48 (expression -> DOUBLE_NUMBER .)
    LEQ             reduce using rule 48 (expression -> DOUBLE_NUMBER .)
    GEQ             reduce using rule 48 (expression -> DOUBLE_NUMBER .)
    LT              reduce using rule 48 (expression -> DOUBLE_NUMBER .)
    GT              reduce using rule 48 (expression -> DOUBLE_NUMBER .)
    NEQ             reduce using rule 48 (expression -> DOUBLE_NUMBER .)
    EQ              reduce using rule 48 (expression -> DOUBLE_NUMBER .)
    AND             reduce using rule 48 (expression -> DOUBLE_NUMBER .)
    OR              reduce using rule 48 (expression -> DOUBLE_NUMBER .)
    BITWISE_AND     reduce using rule 48 (expression -> DOUBLE_NUMBER .)
    BITWISE_OR      reduce using rule 48 (expression -> DOUBLE_NUMBER .)
    BITWISE_XOR     reduce using rule 48 (expression -> DOUBLE_NUMBER .)
    URSHIFT         reduce using rule 48 (expression -> DOUBLE_NUMBER .)
    LSHIFT          reduce using rule 48 (expression -> DOUBLE_NUMBER .)
    RSHIFT          reduce using rule 48 (expression -> DOUBLE_NUMBER .)
    RPAREN          reduce using rule 48 (expression -> DOUBLE_NUMBER .)
    COMMA           reduce using rule 48 (expression -> DOUBLE_NUMBER .)
    RBRACKET        reduce using rule 48 (expression -> DOUBLE_NUMBER .)


state 60

    (49) expression -> INT_NUMBER .

    SEMICOLON       reduce using rule 49 (expression -> INT_NUMBER .)
    TIMES           reduce using rule 49 (expression -> INT_NUMBER .)
    DIVIDE          reduce using rule 49 (expression -> INT_NUMBER .)
    MODULE          reduce using rule 49 (expression -> INT_NUMBER .)
    PLUS            reduce using rule 49 (expression -> INT_NUMBER .)
    MINUS           reduce using rule 49 (expression -> INT_NUMBER .)
    LEQ             reduce using rule 49 (expression -> INT_NUMBER .)
    GEQ             reduce using rule 49 (expression -> INT_NUMBER .)
    LT              reduce using rule 49 (expression -> INT_NUMBER .)
    GT              reduce using rule 49 (expression -> INT_NUMBER .)
    NEQ             reduce using rule 49 (expression -> INT_NUMBER .)
    EQ              reduce using rule 49 (expression -> INT_NUMBER .)
    AND             reduce using rule 49 (expression -> INT_NUMBER .)
    OR              reduce using rule 49 (expression -> INT_NUMBER .)
    BITWISE_AND     reduce using rule 49 (expression -> INT_NUMBER .)
    BITWISE_OR      reduce using rule 49 (expression -> INT_NUMBER .)
    BITWISE_XOR     reduce using rule 49 (expression -> INT_NUMBER .)
    URSHIFT         reduce using rule 49 (expression -> INT_NUMBER .)
    LSHIFT          reduce using rule 49 (expression -> INT_NUMBER .)
    RSHIFT          reduce using rule 49 (expression -> INT_NUMBER .)
    RPAREN          reduce using rule 49 (expression -> INT_NUMBER .)
    COMMA           reduce using rule 49 (expression -> INT_NUMBER .)
    RBRACKET        reduce using rule 49 (expression -> INT_NUMBER .)


state 61

    (50) expression -> STRING .

    SEMICOLON       reduce using rule 50 (expression -> STRING .)
    TIMES           reduce using rule 50 (expression -> STRING .)
    DIVIDE          reduce using rule 50 (expression -> STRING .)
    MODULE          reduce using rule 50 (expression -> STRING .)
    PLUS            reduce using rule 50 (expression -> STRING .)
    MINUS           reduce using rule 50 (expression -> STRING .)
    LEQ             reduce using rule 50 (expression -> STRING .)
    GEQ             reduce using rule 50 (expression -> STRING .)
    LT              reduce using rule 50 (expression -> STRING .)
    GT              reduce using rule 50 (expression -> STRING .)
    NEQ             reduce using rule 50 (expression -> STRING .)
    EQ              reduce using rule 50 (expression -> STRING .)
    AND             reduce using rule 50 (expression -> STRING .)
    OR              reduce using rule 50 (expression -> STRING .)
    BITWISE_AND     reduce using rule 50 (expression -> STRING .)
    BITWISE_OR      reduce using rule 50 (expression -> STRING .)
    BITWISE_XOR     reduce using rule 50 (expression -> STRING .)
    URSHIFT         reduce using rule 50 (expression -> STRING .)
    LSHIFT          reduce using rule 50 (expression -> STRING .)
    RSHIFT          reduce using rule 50 (expression -> STRING .)
    RPAREN          reduce using rule 50 (expression -> STRING .)
    COMMA           reduce using rule 50 (expression -> STRING .)
    RBRACKET        reduce using rule 50 (expression -> STRING .)


state 62

    (52) expression -> NEW . type LPAREN params_call RPAREN
    (53) expression -> NEW . type LBRACKET expression RBRACKET
    (98) type -> . primitivetypes
    (99) primitivetypes -> . TYPE_INT
    (100) primitivetypes -> . TYPE_FLOAT
    (101) primitivetypes -> . TYPE_DOUBLE
    (102) primitivetypes -> . TYPE_BYTE
    (103) primitivetypes -> . TYPE_BOOLEAN
    (104) primitivetypes -> . TYPE_CHAR
    (105) primitivetypes -> . TYPE_STRING
    (106) primitivetypes -> . TYPE_LONG
    (107) primitivetypes -> . TYPE_VOID

    TYPE_INT        shift and go to state 36
    TYPE_FLOAT      shift and go to state 37
    TYPE_DOUBLE     shift and go to state 38
    TYPE_BYTE       shift and go to state 39
    TYPE_BOOLEAN    shift and go to state 40
    TYPE_CHAR       shift and go to state 41
    TYPE_STRING     shift and go to state 42
    TYPE_LONG       shift and go to state 43
    TYPE_VOID       shift and go to state 44

    type                           shift and go to state 121
    primitivetypes                 shift and go to state 35

state 63

    (88) unaryoperatorprefx -> PLUS .

    ID              reduce using rule 88 (unaryoperatorprefx -> PLUS .)


state 64

    (87) unaryoperatorprefx -> MINUS .

    ID              reduce using rule 87 (unaryoperatorprefx -> MINUS .)


state 65

    (82) operator -> unaryoperatorprefx . ID

    ID              shift and go to state 122


state 66

    (85) unaryoperatorprefx -> INCREMENT .

    ID              reduce using rule 85 (unaryoperatorprefx -> INCREMENT .)


state 67

    (86) unaryoperatorprefx -> DECREMENT .

    ID              reduce using rule 86 (unaryoperatorprefx -> DECREMENT .)


state 68

    (89) unaryoperatorprefx -> NOT .

    ID              reduce using rule 89 (unaryoperatorprefx -> NOT .)


state 69

    (4) class -> visibility classmodifier CLASS ID IMPLEMENTS LCHAV membros RCHAV .

    $end            reduce using rule 4 (class -> visibility classmodifier CLASS ID IMPLEMENTS LCHAV membros RCHAV .)


state 70

    (2) class -> visibility classmodifier CLASS ID EXTENDS ID LCHAV membros RCHAV .

    $end            reduce using rule 2 (class -> visibility classmodifier CLASS ID EXTENDS ID LCHAV membros RCHAV .)


state 71

    (17) atribute -> visibility atributemodifier type ID . SEMICOLON
    (18) atribute -> visibility atributemodifier type ID . EQUAL expression SEMICOLON
    (23) signature -> visibility atributemodifier type ID . LPAREN sigparams RPAREN

    SEMICOLON       shift and go to state 123
    EQUAL           shift and go to state 124
    LPAREN          shift and go to state 125


state 72

    (24) signature -> visibility atributemodifier type brackets_expression . ID LPAREN sigparams RPAREN

    ID              shift and go to state 126


state 73

    (95) brackets_expression -> LBRACKET . RBRACKET
    (96) brackets_expression -> LBRACKET . INT_NUMBER RBRACKET
    (97) brackets_expression -> LBRACKET . ID RBRACKET

    RBRACKET        shift and go to state 127
    INT_NUMBER      shift and go to state 128
    ID              shift and go to state 129


state 74

    (27) body -> LCHAV stms RCHAV .

    PUBLIC          reduce using rule 27 (body -> LCHAV stms RCHAV .)
    PRIVATE         reduce using rule 27 (body -> LCHAV stms RCHAV .)
    PROTECTED       reduce using rule 27 (body -> LCHAV stms RCHAV .)
    STATIC          reduce using rule 27 (body -> LCHAV stms RCHAV .)
    FINAL           reduce using rule 27 (body -> LCHAV stms RCHAV .)
    TYPE_INT        reduce using rule 27 (body -> LCHAV stms RCHAV .)
    TYPE_FLOAT      reduce using rule 27 (body -> LCHAV stms RCHAV .)
    TYPE_DOUBLE     reduce using rule 27 (body -> LCHAV stms RCHAV .)
    TYPE_BYTE       reduce using rule 27 (body -> LCHAV stms RCHAV .)
    TYPE_BOOLEAN    reduce using rule 27 (body -> LCHAV stms RCHAV .)
    TYPE_CHAR       reduce using rule 27 (body -> LCHAV stms RCHAV .)
    TYPE_STRING     reduce using rule 27 (body -> LCHAV stms RCHAV .)
    TYPE_LONG       reduce using rule 27 (body -> LCHAV stms RCHAV .)
    TYPE_VOID       reduce using rule 27 (body -> LCHAV stms RCHAV .)
    RCHAV           reduce using rule 27 (body -> LCHAV stms RCHAV .)
    WHILE           reduce using rule 27 (body -> LCHAV stms RCHAV .)
    DO              reduce using rule 27 (body -> LCHAV stms RCHAV .)
    FOR             reduce using rule 27 (body -> LCHAV stms RCHAV .)
    IF              reduce using rule 27 (body -> LCHAV stms RCHAV .)
    SEMICOLON       reduce using rule 27 (body -> LCHAV stms RCHAV .)
    RETURN          reduce using rule 27 (body -> LCHAV stms RCHAV .)
    FLOAT_NUMBER    reduce using rule 27 (body -> LCHAV stms RCHAV .)
    DOUBLE_NUMBER   reduce using rule 27 (body -> LCHAV stms RCHAV .)
    INT_NUMBER      reduce using rule 27 (body -> LCHAV stms RCHAV .)
    STRING          reduce using rule 27 (body -> LCHAV stms RCHAV .)
    ID              reduce using rule 27 (body -> LCHAV stms RCHAV .)
    NEW             reduce using rule 27 (body -> LCHAV stms RCHAV .)
    INCREMENT       reduce using rule 27 (body -> LCHAV stms RCHAV .)
    DECREMENT       reduce using rule 27 (body -> LCHAV stms RCHAV .)
    MINUS           reduce using rule 27 (body -> LCHAV stms RCHAV .)
    PLUS            reduce using rule 27 (body -> LCHAV stms RCHAV .)
    NOT             reduce using rule 27 (body -> LCHAV stms RCHAV .)
    ELSE            reduce using rule 27 (body -> LCHAV stms RCHAV .)


state 75

    (29) stms -> stm stms .

    RCHAV           reduce using rule 29 (stms -> stm stms .)


state 76

    (30) stm -> expression SEMICOLON .

    WHILE           reduce using rule 30 (stm -> expression SEMICOLON .)
    DO              reduce using rule 30 (stm -> expression SEMICOLON .)
    FOR             reduce using rule 30 (stm -> expression SEMICOLON .)
    IF              reduce using rule 30 (stm -> expression SEMICOLON .)
    SEMICOLON       reduce using rule 30 (stm -> expression SEMICOLON .)
    RETURN          reduce using rule 30 (stm -> expression SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 30 (stm -> expression SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 30 (stm -> expression SEMICOLON .)
    INT_NUMBER      reduce using rule 30 (stm -> expression SEMICOLON .)
    STRING          reduce using rule 30 (stm -> expression SEMICOLON .)
    ID              reduce using rule 30 (stm -> expression SEMICOLON .)
    NEW             reduce using rule 30 (stm -> expression SEMICOLON .)
    STATIC          reduce using rule 30 (stm -> expression SEMICOLON .)
    FINAL           reduce using rule 30 (stm -> expression SEMICOLON .)
    INCREMENT       reduce using rule 30 (stm -> expression SEMICOLON .)
    DECREMENT       reduce using rule 30 (stm -> expression SEMICOLON .)
    MINUS           reduce using rule 30 (stm -> expression SEMICOLON .)
    PLUS            reduce using rule 30 (stm -> expression SEMICOLON .)
    NOT             reduce using rule 30 (stm -> expression SEMICOLON .)
    TYPE_INT        reduce using rule 30 (stm -> expression SEMICOLON .)
    TYPE_FLOAT      reduce using rule 30 (stm -> expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 30 (stm -> expression SEMICOLON .)
    TYPE_BYTE       reduce using rule 30 (stm -> expression SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 30 (stm -> expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 30 (stm -> expression SEMICOLON .)
    TYPE_STRING     reduce using rule 30 (stm -> expression SEMICOLON .)
    TYPE_LONG       reduce using rule 30 (stm -> expression SEMICOLON .)
    TYPE_VOID       reduce using rule 30 (stm -> expression SEMICOLON .)
    RCHAV           reduce using rule 30 (stm -> expression SEMICOLON .)


state 77

    (54) operator -> expression TIMES . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 130
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 78

    (55) operator -> expression DIVIDE . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 131
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 79

    (56) operator -> expression MODULE . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 132
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 80

    (57) operator -> expression PLUS . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 133
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 81

    (58) operator -> expression MINUS . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 134
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 82

    (71) operator -> expression LEQ . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 135
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 83

    (72) operator -> expression GEQ . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 136
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 84

    (73) operator -> expression LT . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 137
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 85

    (74) operator -> expression GT . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 138
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 86

    (75) operator -> expression NEQ . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 139
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 87

    (76) operator -> expression EQ . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 140
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 88

    (77) operator -> expression AND . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 141
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 89

    (78) operator -> expression OR . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 142
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 90

    (79) operator -> expression BITWISE_AND . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 143
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 91

    (80) operator -> expression BITWISE_OR . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 144
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 92

    (81) operator -> expression BITWISE_XOR . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 145
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 93

    (84) operator -> expression operatorbittobit .

    SEMICOLON       reduce using rule 84 (operator -> expression operatorbittobit .)
    TIMES           reduce using rule 84 (operator -> expression operatorbittobit .)
    DIVIDE          reduce using rule 84 (operator -> expression operatorbittobit .)
    MODULE          reduce using rule 84 (operator -> expression operatorbittobit .)
    PLUS            reduce using rule 84 (operator -> expression operatorbittobit .)
    MINUS           reduce using rule 84 (operator -> expression operatorbittobit .)
    LEQ             reduce using rule 84 (operator -> expression operatorbittobit .)
    GEQ             reduce using rule 84 (operator -> expression operatorbittobit .)
    LT              reduce using rule 84 (operator -> expression operatorbittobit .)
    GT              reduce using rule 84 (operator -> expression operatorbittobit .)
    NEQ             reduce using rule 84 (operator -> expression operatorbittobit .)
    EQ              reduce using rule 84 (operator -> expression operatorbittobit .)
    AND             reduce using rule 84 (operator -> expression operatorbittobit .)
    OR              reduce using rule 84 (operator -> expression operatorbittobit .)
    BITWISE_AND     reduce using rule 84 (operator -> expression operatorbittobit .)
    BITWISE_OR      reduce using rule 84 (operator -> expression operatorbittobit .)
    BITWISE_XOR     reduce using rule 84 (operator -> expression operatorbittobit .)
    URSHIFT         reduce using rule 84 (operator -> expression operatorbittobit .)
    LSHIFT          reduce using rule 84 (operator -> expression operatorbittobit .)
    RSHIFT          reduce using rule 84 (operator -> expression operatorbittobit .)
    RPAREN          reduce using rule 84 (operator -> expression operatorbittobit .)
    COMMA           reduce using rule 84 (operator -> expression operatorbittobit .)
    RBRACKET        reduce using rule 84 (operator -> expression operatorbittobit .)


state 94

    (92) operatorbittobit -> URSHIFT .

    SEMICOLON       reduce using rule 92 (operatorbittobit -> URSHIFT .)
    TIMES           reduce using rule 92 (operatorbittobit -> URSHIFT .)
    DIVIDE          reduce using rule 92 (operatorbittobit -> URSHIFT .)
    MODULE          reduce using rule 92 (operatorbittobit -> URSHIFT .)
    PLUS            reduce using rule 92 (operatorbittobit -> URSHIFT .)
    MINUS           reduce using rule 92 (operatorbittobit -> URSHIFT .)
    LEQ             reduce using rule 92 (operatorbittobit -> URSHIFT .)
    GEQ             reduce using rule 92 (operatorbittobit -> URSHIFT .)
    LT              reduce using rule 92 (operatorbittobit -> URSHIFT .)
    GT              reduce using rule 92 (operatorbittobit -> URSHIFT .)
    NEQ             reduce using rule 92 (operatorbittobit -> URSHIFT .)
    EQ              reduce using rule 92 (operatorbittobit -> URSHIFT .)
    AND             reduce using rule 92 (operatorbittobit -> URSHIFT .)
    OR              reduce using rule 92 (operatorbittobit -> URSHIFT .)
    BITWISE_AND     reduce using rule 92 (operatorbittobit -> URSHIFT .)
    BITWISE_OR      reduce using rule 92 (operatorbittobit -> URSHIFT .)
    BITWISE_XOR     reduce using rule 92 (operatorbittobit -> URSHIFT .)
    URSHIFT         reduce using rule 92 (operatorbittobit -> URSHIFT .)
    LSHIFT          reduce using rule 92 (operatorbittobit -> URSHIFT .)
    RSHIFT          reduce using rule 92 (operatorbittobit -> URSHIFT .)
    RPAREN          reduce using rule 92 (operatorbittobit -> URSHIFT .)
    COMMA           reduce using rule 92 (operatorbittobit -> URSHIFT .)
    RBRACKET        reduce using rule 92 (operatorbittobit -> URSHIFT .)


state 95

    (93) operatorbittobit -> LSHIFT .

    SEMICOLON       reduce using rule 93 (operatorbittobit -> LSHIFT .)
    TIMES           reduce using rule 93 (operatorbittobit -> LSHIFT .)
    DIVIDE          reduce using rule 93 (operatorbittobit -> LSHIFT .)
    MODULE          reduce using rule 93 (operatorbittobit -> LSHIFT .)
    PLUS            reduce using rule 93 (operatorbittobit -> LSHIFT .)
    MINUS           reduce using rule 93 (operatorbittobit -> LSHIFT .)
    LEQ             reduce using rule 93 (operatorbittobit -> LSHIFT .)
    GEQ             reduce using rule 93 (operatorbittobit -> LSHIFT .)
    LT              reduce using rule 93 (operatorbittobit -> LSHIFT .)
    GT              reduce using rule 93 (operatorbittobit -> LSHIFT .)
    NEQ             reduce using rule 93 (operatorbittobit -> LSHIFT .)
    EQ              reduce using rule 93 (operatorbittobit -> LSHIFT .)
    AND             reduce using rule 93 (operatorbittobit -> LSHIFT .)
    OR              reduce using rule 93 (operatorbittobit -> LSHIFT .)
    BITWISE_AND     reduce using rule 93 (operatorbittobit -> LSHIFT .)
    BITWISE_OR      reduce using rule 93 (operatorbittobit -> LSHIFT .)
    BITWISE_XOR     reduce using rule 93 (operatorbittobit -> LSHIFT .)
    URSHIFT         reduce using rule 93 (operatorbittobit -> LSHIFT .)
    LSHIFT          reduce using rule 93 (operatorbittobit -> LSHIFT .)
    RSHIFT          reduce using rule 93 (operatorbittobit -> LSHIFT .)
    RPAREN          reduce using rule 93 (operatorbittobit -> LSHIFT .)
    COMMA           reduce using rule 93 (operatorbittobit -> LSHIFT .)
    RBRACKET        reduce using rule 93 (operatorbittobit -> LSHIFT .)


state 96

    (94) operatorbittobit -> RSHIFT .

    SEMICOLON       reduce using rule 94 (operatorbittobit -> RSHIFT .)
    TIMES           reduce using rule 94 (operatorbittobit -> RSHIFT .)
    DIVIDE          reduce using rule 94 (operatorbittobit -> RSHIFT .)
    MODULE          reduce using rule 94 (operatorbittobit -> RSHIFT .)
    PLUS            reduce using rule 94 (operatorbittobit -> RSHIFT .)
    MINUS           reduce using rule 94 (operatorbittobit -> RSHIFT .)
    LEQ             reduce using rule 94 (operatorbittobit -> RSHIFT .)
    GEQ             reduce using rule 94 (operatorbittobit -> RSHIFT .)
    LT              reduce using rule 94 (operatorbittobit -> RSHIFT .)
    GT              reduce using rule 94 (operatorbittobit -> RSHIFT .)
    NEQ             reduce using rule 94 (operatorbittobit -> RSHIFT .)
    EQ              reduce using rule 94 (operatorbittobit -> RSHIFT .)
    AND             reduce using rule 94 (operatorbittobit -> RSHIFT .)
    OR              reduce using rule 94 (operatorbittobit -> RSHIFT .)
    BITWISE_AND     reduce using rule 94 (operatorbittobit -> RSHIFT .)
    BITWISE_OR      reduce using rule 94 (operatorbittobit -> RSHIFT .)
    BITWISE_XOR     reduce using rule 94 (operatorbittobit -> RSHIFT .)
    URSHIFT         reduce using rule 94 (operatorbittobit -> RSHIFT .)
    LSHIFT          reduce using rule 94 (operatorbittobit -> RSHIFT .)
    RSHIFT          reduce using rule 94 (operatorbittobit -> RSHIFT .)
    RPAREN          reduce using rule 94 (operatorbittobit -> RSHIFT .)
    COMMA           reduce using rule 94 (operatorbittobit -> RSHIFT .)
    RBRACKET        reduce using rule 94 (operatorbittobit -> RSHIFT .)


state 97

    (31) stm -> WHILE LPAREN . expression RPAREN bodyorstm
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 146
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 98

    (32) stm -> DO bodyorstm . WHILE LPAREN expression RPAREN SEMICOLON

    WHILE           shift and go to state 147


state 99

    (42) bodyorstm -> body .

    WHILE           reduce using rule 42 (bodyorstm -> body .)
    DO              reduce using rule 42 (bodyorstm -> body .)
    FOR             reduce using rule 42 (bodyorstm -> body .)
    IF              reduce using rule 42 (bodyorstm -> body .)
    SEMICOLON       reduce using rule 42 (bodyorstm -> body .)
    RETURN          reduce using rule 42 (bodyorstm -> body .)
    FLOAT_NUMBER    reduce using rule 42 (bodyorstm -> body .)
    DOUBLE_NUMBER   reduce using rule 42 (bodyorstm -> body .)
    INT_NUMBER      reduce using rule 42 (bodyorstm -> body .)
    STRING          reduce using rule 42 (bodyorstm -> body .)
    ID              reduce using rule 42 (bodyorstm -> body .)
    NEW             reduce using rule 42 (bodyorstm -> body .)
    STATIC          reduce using rule 42 (bodyorstm -> body .)
    FINAL           reduce using rule 42 (bodyorstm -> body .)
    INCREMENT       reduce using rule 42 (bodyorstm -> body .)
    DECREMENT       reduce using rule 42 (bodyorstm -> body .)
    MINUS           reduce using rule 42 (bodyorstm -> body .)
    PLUS            reduce using rule 42 (bodyorstm -> body .)
    NOT             reduce using rule 42 (bodyorstm -> body .)
    TYPE_INT        reduce using rule 42 (bodyorstm -> body .)
    TYPE_FLOAT      reduce using rule 42 (bodyorstm -> body .)
    TYPE_DOUBLE     reduce using rule 42 (bodyorstm -> body .)
    TYPE_BYTE       reduce using rule 42 (bodyorstm -> body .)
    TYPE_BOOLEAN    reduce using rule 42 (bodyorstm -> body .)
    TYPE_CHAR       reduce using rule 42 (bodyorstm -> body .)
    TYPE_STRING     reduce using rule 42 (bodyorstm -> body .)
    TYPE_LONG       reduce using rule 42 (bodyorstm -> body .)
    TYPE_VOID       reduce using rule 42 (bodyorstm -> body .)
    RCHAV           reduce using rule 42 (bodyorstm -> body .)
    ELSE            reduce using rule 42 (bodyorstm -> body .)


state 100

    (33) stm -> FOR LPAREN . expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm
    (43) expression_for -> . type ID EQUAL expression
    (44) expression_for -> . ID EQUAL expression
    (98) type -> . primitivetypes
    (99) primitivetypes -> . TYPE_INT
    (100) primitivetypes -> . TYPE_FLOAT
    (101) primitivetypes -> . TYPE_DOUBLE
    (102) primitivetypes -> . TYPE_BYTE
    (103) primitivetypes -> . TYPE_BOOLEAN
    (104) primitivetypes -> . TYPE_CHAR
    (105) primitivetypes -> . TYPE_STRING
    (106) primitivetypes -> . TYPE_LONG
    (107) primitivetypes -> . TYPE_VOID

    ID              shift and go to state 150
    TYPE_INT        shift and go to state 36
    TYPE_FLOAT      shift and go to state 37
    TYPE_DOUBLE     shift and go to state 38
    TYPE_BYTE       shift and go to state 39
    TYPE_BOOLEAN    shift and go to state 40
    TYPE_CHAR       shift and go to state 41
    TYPE_STRING     shift and go to state 42
    TYPE_LONG       shift and go to state 43
    TYPE_VOID       shift and go to state 44

    expression_for                 shift and go to state 148
    type                           shift and go to state 149
    primitivetypes                 shift and go to state 35

state 101

    (34) stm -> IF LPAREN . expression RPAREN bodyorstm
    (35) stm -> IF LPAREN . expression RPAREN bodyorstm ELSE bodyorstm
    (36) stm -> IF LPAREN . expression RPAREN bodyorstm ELSE IF bodyorstm
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 151
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 102

    (38) stm -> atributemodifier type . ID SEMICOLON
    (39) stm -> atributemodifier type . ID EQUAL expression SEMICOLON

    ID              shift and go to state 152


state 103

    (59) operator -> ID EQUAL . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 153
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 104

    (60) operator -> ID MINUS_EQ . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 154
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 105

    (61) operator -> ID TIMES_EQ . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 155
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 106

    (62) operator -> ID PLUS_EQ . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 156
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 107

    (63) operator -> ID DIVIDE_EQ . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 157
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 108

    (64) operator -> ID MOD_EQ . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 158
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 109

    (65) operator -> ID BITWISE_AND_EQ . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 159
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 110

    (66) operator -> ID BITWISE_OR_EQ . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 160
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 111

    (67) operator -> ID BITWISE_XOR_EQ . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 161
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 112

    (68) operator -> ID URSHIFT_EQ . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 162
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 113

    (69) operator -> ID LSHIFT_EQ . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 163
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 114

    (70) operator -> ID RSHIFT_EQ . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 164
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 115

    (83) operator -> ID unaryoperatorsufx .

    SEMICOLON       reduce using rule 83 (operator -> ID unaryoperatorsufx .)
    TIMES           reduce using rule 83 (operator -> ID unaryoperatorsufx .)
    DIVIDE          reduce using rule 83 (operator -> ID unaryoperatorsufx .)
    MODULE          reduce using rule 83 (operator -> ID unaryoperatorsufx .)
    PLUS            reduce using rule 83 (operator -> ID unaryoperatorsufx .)
    MINUS           reduce using rule 83 (operator -> ID unaryoperatorsufx .)
    LEQ             reduce using rule 83 (operator -> ID unaryoperatorsufx .)
    GEQ             reduce using rule 83 (operator -> ID unaryoperatorsufx .)
    LT              reduce using rule 83 (operator -> ID unaryoperatorsufx .)
    GT              reduce using rule 83 (operator -> ID unaryoperatorsufx .)
    NEQ             reduce using rule 83 (operator -> ID unaryoperatorsufx .)
    EQ              reduce using rule 83 (operator -> ID unaryoperatorsufx .)
    AND             reduce using rule 83 (operator -> ID unaryoperatorsufx .)
    OR              reduce using rule 83 (operator -> ID unaryoperatorsufx .)
    BITWISE_AND     reduce using rule 83 (operator -> ID unaryoperatorsufx .)
    BITWISE_OR      reduce using rule 83 (operator -> ID unaryoperatorsufx .)
    BITWISE_XOR     reduce using rule 83 (operator -> ID unaryoperatorsufx .)
    URSHIFT         reduce using rule 83 (operator -> ID unaryoperatorsufx .)
    LSHIFT          reduce using rule 83 (operator -> ID unaryoperatorsufx .)
    RSHIFT          reduce using rule 83 (operator -> ID unaryoperatorsufx .)
    RPAREN          reduce using rule 83 (operator -> ID unaryoperatorsufx .)
    COMMA           reduce using rule 83 (operator -> ID unaryoperatorsufx .)
    RBRACKET        reduce using rule 83 (operator -> ID unaryoperatorsufx .)


state 116

    (108) call -> ID LPAREN . params_call RPAREN
    (109) call -> ID LPAREN . RPAREN
    (110) params_call -> . expression COMMA params_call
    (111) params_call -> . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    RPAREN          shift and go to state 166
    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    params_call                    shift and go to state 165
    expression                     shift and go to state 167
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 117

    (90) unaryoperatorsufx -> INCREMENT .

    SEMICOLON       reduce using rule 90 (unaryoperatorsufx -> INCREMENT .)
    TIMES           reduce using rule 90 (unaryoperatorsufx -> INCREMENT .)
    DIVIDE          reduce using rule 90 (unaryoperatorsufx -> INCREMENT .)
    MODULE          reduce using rule 90 (unaryoperatorsufx -> INCREMENT .)
    PLUS            reduce using rule 90 (unaryoperatorsufx -> INCREMENT .)
    MINUS           reduce using rule 90 (unaryoperatorsufx -> INCREMENT .)
    LEQ             reduce using rule 90 (unaryoperatorsufx -> INCREMENT .)
    GEQ             reduce using rule 90 (unaryoperatorsufx -> INCREMENT .)
    LT              reduce using rule 90 (unaryoperatorsufx -> INCREMENT .)
    GT              reduce using rule 90 (unaryoperatorsufx -> INCREMENT .)
    NEQ             reduce using rule 90 (unaryoperatorsufx -> INCREMENT .)
    EQ              reduce using rule 90 (unaryoperatorsufx -> INCREMENT .)
    AND             reduce using rule 90 (unaryoperatorsufx -> INCREMENT .)
    OR              reduce using rule 90 (unaryoperatorsufx -> INCREMENT .)
    BITWISE_AND     reduce using rule 90 (unaryoperatorsufx -> INCREMENT .)
    BITWISE_OR      reduce using rule 90 (unaryoperatorsufx -> INCREMENT .)
    BITWISE_XOR     reduce using rule 90 (unaryoperatorsufx -> INCREMENT .)
    URSHIFT         reduce using rule 90 (unaryoperatorsufx -> INCREMENT .)
    LSHIFT          reduce using rule 90 (unaryoperatorsufx -> INCREMENT .)
    RSHIFT          reduce using rule 90 (unaryoperatorsufx -> INCREMENT .)
    RPAREN          reduce using rule 90 (unaryoperatorsufx -> INCREMENT .)
    COMMA           reduce using rule 90 (unaryoperatorsufx -> INCREMENT .)
    RBRACKET        reduce using rule 90 (unaryoperatorsufx -> INCREMENT .)


state 118

    (91) unaryoperatorsufx -> DECREMENT .

    SEMICOLON       reduce using rule 91 (unaryoperatorsufx -> DECREMENT .)
    TIMES           reduce using rule 91 (unaryoperatorsufx -> DECREMENT .)
    DIVIDE          reduce using rule 91 (unaryoperatorsufx -> DECREMENT .)
    MODULE          reduce using rule 91 (unaryoperatorsufx -> DECREMENT .)
    PLUS            reduce using rule 91 (unaryoperatorsufx -> DECREMENT .)
    MINUS           reduce using rule 91 (unaryoperatorsufx -> DECREMENT .)
    LEQ             reduce using rule 91 (unaryoperatorsufx -> DECREMENT .)
    GEQ             reduce using rule 91 (unaryoperatorsufx -> DECREMENT .)
    LT              reduce using rule 91 (unaryoperatorsufx -> DECREMENT .)
    GT              reduce using rule 91 (unaryoperatorsufx -> DECREMENT .)
    NEQ             reduce using rule 91 (unaryoperatorsufx -> DECREMENT .)
    EQ              reduce using rule 91 (unaryoperatorsufx -> DECREMENT .)
    AND             reduce using rule 91 (unaryoperatorsufx -> DECREMENT .)
    OR              reduce using rule 91 (unaryoperatorsufx -> DECREMENT .)
    BITWISE_AND     reduce using rule 91 (unaryoperatorsufx -> DECREMENT .)
    BITWISE_OR      reduce using rule 91 (unaryoperatorsufx -> DECREMENT .)
    BITWISE_XOR     reduce using rule 91 (unaryoperatorsufx -> DECREMENT .)
    URSHIFT         reduce using rule 91 (unaryoperatorsufx -> DECREMENT .)
    LSHIFT          reduce using rule 91 (unaryoperatorsufx -> DECREMENT .)
    RSHIFT          reduce using rule 91 (unaryoperatorsufx -> DECREMENT .)
    RPAREN          reduce using rule 91 (unaryoperatorsufx -> DECREMENT .)
    COMMA           reduce using rule 91 (unaryoperatorsufx -> DECREMENT .)
    RBRACKET        reduce using rule 91 (unaryoperatorsufx -> DECREMENT .)


state 119

    (40) stm -> RETURN expression . SEMICOLON
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       shift and go to state 168
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

    operatorbittobit               shift and go to state 93

state 120

    (41) stm -> RETURN SEMICOLON .

    WHILE           reduce using rule 41 (stm -> RETURN SEMICOLON .)
    DO              reduce using rule 41 (stm -> RETURN SEMICOLON .)
    FOR             reduce using rule 41 (stm -> RETURN SEMICOLON .)
    IF              reduce using rule 41 (stm -> RETURN SEMICOLON .)
    SEMICOLON       reduce using rule 41 (stm -> RETURN SEMICOLON .)
    RETURN          reduce using rule 41 (stm -> RETURN SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 41 (stm -> RETURN SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 41 (stm -> RETURN SEMICOLON .)
    INT_NUMBER      reduce using rule 41 (stm -> RETURN SEMICOLON .)
    STRING          reduce using rule 41 (stm -> RETURN SEMICOLON .)
    ID              reduce using rule 41 (stm -> RETURN SEMICOLON .)
    NEW             reduce using rule 41 (stm -> RETURN SEMICOLON .)
    STATIC          reduce using rule 41 (stm -> RETURN SEMICOLON .)
    FINAL           reduce using rule 41 (stm -> RETURN SEMICOLON .)
    INCREMENT       reduce using rule 41 (stm -> RETURN SEMICOLON .)
    DECREMENT       reduce using rule 41 (stm -> RETURN SEMICOLON .)
    MINUS           reduce using rule 41 (stm -> RETURN SEMICOLON .)
    PLUS            reduce using rule 41 (stm -> RETURN SEMICOLON .)
    NOT             reduce using rule 41 (stm -> RETURN SEMICOLON .)
    TYPE_INT        reduce using rule 41 (stm -> RETURN SEMICOLON .)
    TYPE_FLOAT      reduce using rule 41 (stm -> RETURN SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 41 (stm -> RETURN SEMICOLON .)
    TYPE_BYTE       reduce using rule 41 (stm -> RETURN SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 41 (stm -> RETURN SEMICOLON .)
    TYPE_CHAR       reduce using rule 41 (stm -> RETURN SEMICOLON .)
    TYPE_STRING     reduce using rule 41 (stm -> RETURN SEMICOLON .)
    TYPE_LONG       reduce using rule 41 (stm -> RETURN SEMICOLON .)
    TYPE_VOID       reduce using rule 41 (stm -> RETURN SEMICOLON .)
    RCHAV           reduce using rule 41 (stm -> RETURN SEMICOLON .)


state 121

    (52) expression -> NEW type . LPAREN params_call RPAREN
    (53) expression -> NEW type . LBRACKET expression RBRACKET

    LPAREN          shift and go to state 169
    LBRACKET        shift and go to state 170


state 122

    (82) operator -> unaryoperatorprefx ID .

    SEMICOLON       reduce using rule 82 (operator -> unaryoperatorprefx ID .)
    TIMES           reduce using rule 82 (operator -> unaryoperatorprefx ID .)
    DIVIDE          reduce using rule 82 (operator -> unaryoperatorprefx ID .)
    MODULE          reduce using rule 82 (operator -> unaryoperatorprefx ID .)
    PLUS            reduce using rule 82 (operator -> unaryoperatorprefx ID .)
    MINUS           reduce using rule 82 (operator -> unaryoperatorprefx ID .)
    LEQ             reduce using rule 82 (operator -> unaryoperatorprefx ID .)
    GEQ             reduce using rule 82 (operator -> unaryoperatorprefx ID .)
    LT              reduce using rule 82 (operator -> unaryoperatorprefx ID .)
    GT              reduce using rule 82 (operator -> unaryoperatorprefx ID .)
    NEQ             reduce using rule 82 (operator -> unaryoperatorprefx ID .)
    EQ              reduce using rule 82 (operator -> unaryoperatorprefx ID .)
    AND             reduce using rule 82 (operator -> unaryoperatorprefx ID .)
    OR              reduce using rule 82 (operator -> unaryoperatorprefx ID .)
    BITWISE_AND     reduce using rule 82 (operator -> unaryoperatorprefx ID .)
    BITWISE_OR      reduce using rule 82 (operator -> unaryoperatorprefx ID .)
    BITWISE_XOR     reduce using rule 82 (operator -> unaryoperatorprefx ID .)
    URSHIFT         reduce using rule 82 (operator -> unaryoperatorprefx ID .)
    LSHIFT          reduce using rule 82 (operator -> unaryoperatorprefx ID .)
    RSHIFT          reduce using rule 82 (operator -> unaryoperatorprefx ID .)
    RPAREN          reduce using rule 82 (operator -> unaryoperatorprefx ID .)
    COMMA           reduce using rule 82 (operator -> unaryoperatorprefx ID .)
    RBRACKET        reduce using rule 82 (operator -> unaryoperatorprefx ID .)


state 123

    (17) atribute -> visibility atributemodifier type ID SEMICOLON .

    PUBLIC          reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    PRIVATE         reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    PROTECTED       reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    STATIC          reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    FINAL           reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_INT        reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_FLOAT      reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_BYTE       reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_CHAR       reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_STRING     reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_LONG       reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    TYPE_VOID       reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)
    RCHAV           reduce using rule 17 (atribute -> visibility atributemodifier type ID SEMICOLON .)


state 124

    (18) atribute -> visibility atributemodifier type ID EQUAL . expression SEMICOLON
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 171
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 125

    (23) signature -> visibility atributemodifier type ID LPAREN . sigparams RPAREN
    (25) sigparams -> . type ID
    (26) sigparams -> . type ID COMMA sigparams
    (98) type -> . primitivetypes
    (99) primitivetypes -> . TYPE_INT
    (100) primitivetypes -> . TYPE_FLOAT
    (101) primitivetypes -> . TYPE_DOUBLE
    (102) primitivetypes -> . TYPE_BYTE
    (103) primitivetypes -> . TYPE_BOOLEAN
    (104) primitivetypes -> . TYPE_CHAR
    (105) primitivetypes -> . TYPE_STRING
    (106) primitivetypes -> . TYPE_LONG
    (107) primitivetypes -> . TYPE_VOID

    TYPE_INT        shift and go to state 36
    TYPE_FLOAT      shift and go to state 37
    TYPE_DOUBLE     shift and go to state 38
    TYPE_BYTE       shift and go to state 39
    TYPE_BOOLEAN    shift and go to state 40
    TYPE_CHAR       shift and go to state 41
    TYPE_STRING     shift and go to state 42
    TYPE_LONG       shift and go to state 43
    TYPE_VOID       shift and go to state 44

    type                           shift and go to state 172
    sigparams                      shift and go to state 173
    primitivetypes                 shift and go to state 35

state 126

    (24) signature -> visibility atributemodifier type brackets_expression ID . LPAREN sigparams RPAREN

    LPAREN          shift and go to state 174


state 127

    (95) brackets_expression -> LBRACKET RBRACKET .

    ID              reduce using rule 95 (brackets_expression -> LBRACKET RBRACKET .)


state 128

    (96) brackets_expression -> LBRACKET INT_NUMBER . RBRACKET

    RBRACKET        shift and go to state 175


state 129

    (97) brackets_expression -> LBRACKET ID . RBRACKET

    RBRACKET        shift and go to state 176


state 130

    (54) operator -> expression TIMES expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 54 (operator -> expression TIMES expression .)
    TIMES           reduce using rule 54 (operator -> expression TIMES expression .)
    DIVIDE          reduce using rule 54 (operator -> expression TIMES expression .)
    MODULE          reduce using rule 54 (operator -> expression TIMES expression .)
    PLUS            reduce using rule 54 (operator -> expression TIMES expression .)
    MINUS           reduce using rule 54 (operator -> expression TIMES expression .)
    LEQ             reduce using rule 54 (operator -> expression TIMES expression .)
    GEQ             reduce using rule 54 (operator -> expression TIMES expression .)
    LT              reduce using rule 54 (operator -> expression TIMES expression .)
    GT              reduce using rule 54 (operator -> expression TIMES expression .)
    NEQ             reduce using rule 54 (operator -> expression TIMES expression .)
    EQ              reduce using rule 54 (operator -> expression TIMES expression .)
    AND             reduce using rule 54 (operator -> expression TIMES expression .)
    OR              reduce using rule 54 (operator -> expression TIMES expression .)
    BITWISE_AND     reduce using rule 54 (operator -> expression TIMES expression .)
    BITWISE_OR      reduce using rule 54 (operator -> expression TIMES expression .)
    BITWISE_XOR     reduce using rule 54 (operator -> expression TIMES expression .)
    URSHIFT         reduce using rule 54 (operator -> expression TIMES expression .)
    LSHIFT          reduce using rule 54 (operator -> expression TIMES expression .)
    RSHIFT          reduce using rule 54 (operator -> expression TIMES expression .)
    RPAREN          reduce using rule 54 (operator -> expression TIMES expression .)
    COMMA           reduce using rule 54 (operator -> expression TIMES expression .)
    RBRACKET        reduce using rule 54 (operator -> expression TIMES expression .)

  ! TIMES           [ shift and go to state 77 ]
  ! DIVIDE          [ shift and go to state 78 ]
  ! MODULE          [ shift and go to state 79 ]
  ! PLUS            [ shift and go to state 80 ]
  ! MINUS           [ shift and go to state 81 ]
  ! LEQ             [ shift and go to state 82 ]
  ! GEQ             [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! GT              [ shift and go to state 85 ]
  ! NEQ             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 87 ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]
  ! BITWISE_XOR     [ shift and go to state 92 ]
  ! URSHIFT         [ shift and go to state 94 ]
  ! LSHIFT          [ shift and go to state 95 ]
  ! RSHIFT          [ shift and go to state 96 ]

    operatorbittobit               shift and go to state 93

state 131

    (55) operator -> expression DIVIDE expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 55 (operator -> expression DIVIDE expression .)
    TIMES           reduce using rule 55 (operator -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 55 (operator -> expression DIVIDE expression .)
    MODULE          reduce using rule 55 (operator -> expression DIVIDE expression .)
    PLUS            reduce using rule 55 (operator -> expression DIVIDE expression .)
    MINUS           reduce using rule 55 (operator -> expression DIVIDE expression .)
    LEQ             reduce using rule 55 (operator -> expression DIVIDE expression .)
    GEQ             reduce using rule 55 (operator -> expression DIVIDE expression .)
    LT              reduce using rule 55 (operator -> expression DIVIDE expression .)
    GT              reduce using rule 55 (operator -> expression DIVIDE expression .)
    NEQ             reduce using rule 55 (operator -> expression DIVIDE expression .)
    EQ              reduce using rule 55 (operator -> expression DIVIDE expression .)
    AND             reduce using rule 55 (operator -> expression DIVIDE expression .)
    OR              reduce using rule 55 (operator -> expression DIVIDE expression .)
    BITWISE_AND     reduce using rule 55 (operator -> expression DIVIDE expression .)
    BITWISE_OR      reduce using rule 55 (operator -> expression DIVIDE expression .)
    BITWISE_XOR     reduce using rule 55 (operator -> expression DIVIDE expression .)
    URSHIFT         reduce using rule 55 (operator -> expression DIVIDE expression .)
    LSHIFT          reduce using rule 55 (operator -> expression DIVIDE expression .)
    RSHIFT          reduce using rule 55 (operator -> expression DIVIDE expression .)
    RPAREN          reduce using rule 55 (operator -> expression DIVIDE expression .)
    COMMA           reduce using rule 55 (operator -> expression DIVIDE expression .)
    RBRACKET        reduce using rule 55 (operator -> expression DIVIDE expression .)

  ! TIMES           [ shift and go to state 77 ]
  ! DIVIDE          [ shift and go to state 78 ]
  ! MODULE          [ shift and go to state 79 ]
  ! PLUS            [ shift and go to state 80 ]
  ! MINUS           [ shift and go to state 81 ]
  ! LEQ             [ shift and go to state 82 ]
  ! GEQ             [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! GT              [ shift and go to state 85 ]
  ! NEQ             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 87 ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]
  ! BITWISE_XOR     [ shift and go to state 92 ]
  ! URSHIFT         [ shift and go to state 94 ]
  ! LSHIFT          [ shift and go to state 95 ]
  ! RSHIFT          [ shift and go to state 96 ]

    operatorbittobit               shift and go to state 93

state 132

    (56) operator -> expression MODULE expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 56 (operator -> expression MODULE expression .)
    TIMES           reduce using rule 56 (operator -> expression MODULE expression .)
    DIVIDE          reduce using rule 56 (operator -> expression MODULE expression .)
    MODULE          reduce using rule 56 (operator -> expression MODULE expression .)
    PLUS            reduce using rule 56 (operator -> expression MODULE expression .)
    MINUS           reduce using rule 56 (operator -> expression MODULE expression .)
    LEQ             reduce using rule 56 (operator -> expression MODULE expression .)
    GEQ             reduce using rule 56 (operator -> expression MODULE expression .)
    LT              reduce using rule 56 (operator -> expression MODULE expression .)
    GT              reduce using rule 56 (operator -> expression MODULE expression .)
    NEQ             reduce using rule 56 (operator -> expression MODULE expression .)
    EQ              reduce using rule 56 (operator -> expression MODULE expression .)
    AND             reduce using rule 56 (operator -> expression MODULE expression .)
    OR              reduce using rule 56 (operator -> expression MODULE expression .)
    BITWISE_AND     reduce using rule 56 (operator -> expression MODULE expression .)
    BITWISE_OR      reduce using rule 56 (operator -> expression MODULE expression .)
    BITWISE_XOR     reduce using rule 56 (operator -> expression MODULE expression .)
    URSHIFT         reduce using rule 56 (operator -> expression MODULE expression .)
    LSHIFT          reduce using rule 56 (operator -> expression MODULE expression .)
    RSHIFT          reduce using rule 56 (operator -> expression MODULE expression .)
    RPAREN          reduce using rule 56 (operator -> expression MODULE expression .)
    COMMA           reduce using rule 56 (operator -> expression MODULE expression .)
    RBRACKET        reduce using rule 56 (operator -> expression MODULE expression .)

  ! TIMES           [ shift and go to state 77 ]
  ! DIVIDE          [ shift and go to state 78 ]
  ! MODULE          [ shift and go to state 79 ]
  ! PLUS            [ shift and go to state 80 ]
  ! MINUS           [ shift and go to state 81 ]
  ! LEQ             [ shift and go to state 82 ]
  ! GEQ             [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! GT              [ shift and go to state 85 ]
  ! NEQ             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 87 ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]
  ! BITWISE_XOR     [ shift and go to state 92 ]
  ! URSHIFT         [ shift and go to state 94 ]
  ! LSHIFT          [ shift and go to state 95 ]
  ! RSHIFT          [ shift and go to state 96 ]

    operatorbittobit               shift and go to state 93

state 133

    (57) operator -> expression PLUS expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 57 (operator -> expression PLUS expression .)
    PLUS            reduce using rule 57 (operator -> expression PLUS expression .)
    MINUS           reduce using rule 57 (operator -> expression PLUS expression .)
    LEQ             reduce using rule 57 (operator -> expression PLUS expression .)
    GEQ             reduce using rule 57 (operator -> expression PLUS expression .)
    LT              reduce using rule 57 (operator -> expression PLUS expression .)
    GT              reduce using rule 57 (operator -> expression PLUS expression .)
    NEQ             reduce using rule 57 (operator -> expression PLUS expression .)
    EQ              reduce using rule 57 (operator -> expression PLUS expression .)
    AND             reduce using rule 57 (operator -> expression PLUS expression .)
    OR              reduce using rule 57 (operator -> expression PLUS expression .)
    BITWISE_AND     reduce using rule 57 (operator -> expression PLUS expression .)
    BITWISE_OR      reduce using rule 57 (operator -> expression PLUS expression .)
    BITWISE_XOR     reduce using rule 57 (operator -> expression PLUS expression .)
    URSHIFT         reduce using rule 57 (operator -> expression PLUS expression .)
    LSHIFT          reduce using rule 57 (operator -> expression PLUS expression .)
    RSHIFT          reduce using rule 57 (operator -> expression PLUS expression .)
    RPAREN          reduce using rule 57 (operator -> expression PLUS expression .)
    COMMA           reduce using rule 57 (operator -> expression PLUS expression .)
    RBRACKET        reduce using rule 57 (operator -> expression PLUS expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79

  ! TIMES           [ reduce using rule 57 (operator -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 57 (operator -> expression PLUS expression .) ]
  ! MODULE          [ reduce using rule 57 (operator -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 80 ]
  ! MINUS           [ shift and go to state 81 ]
  ! LEQ             [ shift and go to state 82 ]
  ! GEQ             [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! GT              [ shift and go to state 85 ]
  ! NEQ             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 87 ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]
  ! BITWISE_XOR     [ shift and go to state 92 ]
  ! URSHIFT         [ shift and go to state 94 ]
  ! LSHIFT          [ shift and go to state 95 ]
  ! RSHIFT          [ shift and go to state 96 ]

    operatorbittobit               shift and go to state 93

state 134

    (58) operator -> expression MINUS expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 58 (operator -> expression MINUS expression .)
    PLUS            reduce using rule 58 (operator -> expression MINUS expression .)
    MINUS           reduce using rule 58 (operator -> expression MINUS expression .)
    LEQ             reduce using rule 58 (operator -> expression MINUS expression .)
    GEQ             reduce using rule 58 (operator -> expression MINUS expression .)
    LT              reduce using rule 58 (operator -> expression MINUS expression .)
    GT              reduce using rule 58 (operator -> expression MINUS expression .)
    NEQ             reduce using rule 58 (operator -> expression MINUS expression .)
    EQ              reduce using rule 58 (operator -> expression MINUS expression .)
    AND             reduce using rule 58 (operator -> expression MINUS expression .)
    OR              reduce using rule 58 (operator -> expression MINUS expression .)
    BITWISE_AND     reduce using rule 58 (operator -> expression MINUS expression .)
    BITWISE_OR      reduce using rule 58 (operator -> expression MINUS expression .)
    BITWISE_XOR     reduce using rule 58 (operator -> expression MINUS expression .)
    URSHIFT         reduce using rule 58 (operator -> expression MINUS expression .)
    LSHIFT          reduce using rule 58 (operator -> expression MINUS expression .)
    RSHIFT          reduce using rule 58 (operator -> expression MINUS expression .)
    RPAREN          reduce using rule 58 (operator -> expression MINUS expression .)
    COMMA           reduce using rule 58 (operator -> expression MINUS expression .)
    RBRACKET        reduce using rule 58 (operator -> expression MINUS expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79

  ! TIMES           [ reduce using rule 58 (operator -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 58 (operator -> expression MINUS expression .) ]
  ! MODULE          [ reduce using rule 58 (operator -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 80 ]
  ! MINUS           [ shift and go to state 81 ]
  ! LEQ             [ shift and go to state 82 ]
  ! GEQ             [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! GT              [ shift and go to state 85 ]
  ! NEQ             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 87 ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]
  ! BITWISE_XOR     [ shift and go to state 92 ]
  ! URSHIFT         [ shift and go to state 94 ]
  ! LSHIFT          [ shift and go to state 95 ]
  ! RSHIFT          [ shift and go to state 96 ]

    operatorbittobit               shift and go to state 93

state 135

    (71) operator -> expression LEQ expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 71 (operator -> expression LEQ expression .)
    LEQ             reduce using rule 71 (operator -> expression LEQ expression .)
    GEQ             reduce using rule 71 (operator -> expression LEQ expression .)
    LT              reduce using rule 71 (operator -> expression LEQ expression .)
    GT              reduce using rule 71 (operator -> expression LEQ expression .)
    NEQ             reduce using rule 71 (operator -> expression LEQ expression .)
    EQ              reduce using rule 71 (operator -> expression LEQ expression .)
    AND             reduce using rule 71 (operator -> expression LEQ expression .)
    OR              reduce using rule 71 (operator -> expression LEQ expression .)
    BITWISE_AND     reduce using rule 71 (operator -> expression LEQ expression .)
    BITWISE_OR      reduce using rule 71 (operator -> expression LEQ expression .)
    BITWISE_XOR     reduce using rule 71 (operator -> expression LEQ expression .)
    RPAREN          reduce using rule 71 (operator -> expression LEQ expression .)
    COMMA           reduce using rule 71 (operator -> expression LEQ expression .)
    RBRACKET        reduce using rule 71 (operator -> expression LEQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 71 (operator -> expression LEQ expression .) ]
  ! DIVIDE          [ reduce using rule 71 (operator -> expression LEQ expression .) ]
  ! MODULE          [ reduce using rule 71 (operator -> expression LEQ expression .) ]
  ! PLUS            [ reduce using rule 71 (operator -> expression LEQ expression .) ]
  ! MINUS           [ reduce using rule 71 (operator -> expression LEQ expression .) ]
  ! URSHIFT         [ reduce using rule 71 (operator -> expression LEQ expression .) ]
  ! LSHIFT          [ reduce using rule 71 (operator -> expression LEQ expression .) ]
  ! RSHIFT          [ reduce using rule 71 (operator -> expression LEQ expression .) ]
  ! LEQ             [ shift and go to state 82 ]
  ! GEQ             [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! GT              [ shift and go to state 85 ]
  ! NEQ             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 87 ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]
  ! BITWISE_XOR     [ shift and go to state 92 ]

    operatorbittobit               shift and go to state 93

state 136

    (72) operator -> expression GEQ expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 72 (operator -> expression GEQ expression .)
    LEQ             reduce using rule 72 (operator -> expression GEQ expression .)
    GEQ             reduce using rule 72 (operator -> expression GEQ expression .)
    LT              reduce using rule 72 (operator -> expression GEQ expression .)
    GT              reduce using rule 72 (operator -> expression GEQ expression .)
    NEQ             reduce using rule 72 (operator -> expression GEQ expression .)
    EQ              reduce using rule 72 (operator -> expression GEQ expression .)
    AND             reduce using rule 72 (operator -> expression GEQ expression .)
    OR              reduce using rule 72 (operator -> expression GEQ expression .)
    BITWISE_AND     reduce using rule 72 (operator -> expression GEQ expression .)
    BITWISE_OR      reduce using rule 72 (operator -> expression GEQ expression .)
    BITWISE_XOR     reduce using rule 72 (operator -> expression GEQ expression .)
    RPAREN          reduce using rule 72 (operator -> expression GEQ expression .)
    COMMA           reduce using rule 72 (operator -> expression GEQ expression .)
    RBRACKET        reduce using rule 72 (operator -> expression GEQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 72 (operator -> expression GEQ expression .) ]
  ! DIVIDE          [ reduce using rule 72 (operator -> expression GEQ expression .) ]
  ! MODULE          [ reduce using rule 72 (operator -> expression GEQ expression .) ]
  ! PLUS            [ reduce using rule 72 (operator -> expression GEQ expression .) ]
  ! MINUS           [ reduce using rule 72 (operator -> expression GEQ expression .) ]
  ! URSHIFT         [ reduce using rule 72 (operator -> expression GEQ expression .) ]
  ! LSHIFT          [ reduce using rule 72 (operator -> expression GEQ expression .) ]
  ! RSHIFT          [ reduce using rule 72 (operator -> expression GEQ expression .) ]
  ! LEQ             [ shift and go to state 82 ]
  ! GEQ             [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! GT              [ shift and go to state 85 ]
  ! NEQ             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 87 ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]
  ! BITWISE_XOR     [ shift and go to state 92 ]

    operatorbittobit               shift and go to state 93

state 137

    (73) operator -> expression LT expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 73 (operator -> expression LT expression .)
    LEQ             reduce using rule 73 (operator -> expression LT expression .)
    GEQ             reduce using rule 73 (operator -> expression LT expression .)
    LT              reduce using rule 73 (operator -> expression LT expression .)
    GT              reduce using rule 73 (operator -> expression LT expression .)
    NEQ             reduce using rule 73 (operator -> expression LT expression .)
    EQ              reduce using rule 73 (operator -> expression LT expression .)
    AND             reduce using rule 73 (operator -> expression LT expression .)
    OR              reduce using rule 73 (operator -> expression LT expression .)
    BITWISE_AND     reduce using rule 73 (operator -> expression LT expression .)
    BITWISE_OR      reduce using rule 73 (operator -> expression LT expression .)
    BITWISE_XOR     reduce using rule 73 (operator -> expression LT expression .)
    RPAREN          reduce using rule 73 (operator -> expression LT expression .)
    COMMA           reduce using rule 73 (operator -> expression LT expression .)
    RBRACKET        reduce using rule 73 (operator -> expression LT expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 73 (operator -> expression LT expression .) ]
  ! DIVIDE          [ reduce using rule 73 (operator -> expression LT expression .) ]
  ! MODULE          [ reduce using rule 73 (operator -> expression LT expression .) ]
  ! PLUS            [ reduce using rule 73 (operator -> expression LT expression .) ]
  ! MINUS           [ reduce using rule 73 (operator -> expression LT expression .) ]
  ! URSHIFT         [ reduce using rule 73 (operator -> expression LT expression .) ]
  ! LSHIFT          [ reduce using rule 73 (operator -> expression LT expression .) ]
  ! RSHIFT          [ reduce using rule 73 (operator -> expression LT expression .) ]
  ! LEQ             [ shift and go to state 82 ]
  ! GEQ             [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! GT              [ shift and go to state 85 ]
  ! NEQ             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 87 ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]
  ! BITWISE_XOR     [ shift and go to state 92 ]

    operatorbittobit               shift and go to state 93

state 138

    (74) operator -> expression GT expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 74 (operator -> expression GT expression .)
    LEQ             reduce using rule 74 (operator -> expression GT expression .)
    GEQ             reduce using rule 74 (operator -> expression GT expression .)
    LT              reduce using rule 74 (operator -> expression GT expression .)
    GT              reduce using rule 74 (operator -> expression GT expression .)
    NEQ             reduce using rule 74 (operator -> expression GT expression .)
    EQ              reduce using rule 74 (operator -> expression GT expression .)
    AND             reduce using rule 74 (operator -> expression GT expression .)
    OR              reduce using rule 74 (operator -> expression GT expression .)
    BITWISE_AND     reduce using rule 74 (operator -> expression GT expression .)
    BITWISE_OR      reduce using rule 74 (operator -> expression GT expression .)
    BITWISE_XOR     reduce using rule 74 (operator -> expression GT expression .)
    RPAREN          reduce using rule 74 (operator -> expression GT expression .)
    COMMA           reduce using rule 74 (operator -> expression GT expression .)
    RBRACKET        reduce using rule 74 (operator -> expression GT expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 74 (operator -> expression GT expression .) ]
  ! DIVIDE          [ reduce using rule 74 (operator -> expression GT expression .) ]
  ! MODULE          [ reduce using rule 74 (operator -> expression GT expression .) ]
  ! PLUS            [ reduce using rule 74 (operator -> expression GT expression .) ]
  ! MINUS           [ reduce using rule 74 (operator -> expression GT expression .) ]
  ! URSHIFT         [ reduce using rule 74 (operator -> expression GT expression .) ]
  ! LSHIFT          [ reduce using rule 74 (operator -> expression GT expression .) ]
  ! RSHIFT          [ reduce using rule 74 (operator -> expression GT expression .) ]
  ! LEQ             [ shift and go to state 82 ]
  ! GEQ             [ shift and go to state 83 ]
  ! LT              [ shift and go to state 84 ]
  ! GT              [ shift and go to state 85 ]
  ! NEQ             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 87 ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]
  ! BITWISE_XOR     [ shift and go to state 92 ]

    operatorbittobit               shift and go to state 93

state 139

    (75) operator -> expression NEQ expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 75 (operator -> expression NEQ expression .)
    NEQ             reduce using rule 75 (operator -> expression NEQ expression .)
    EQ              reduce using rule 75 (operator -> expression NEQ expression .)
    AND             reduce using rule 75 (operator -> expression NEQ expression .)
    OR              reduce using rule 75 (operator -> expression NEQ expression .)
    BITWISE_AND     reduce using rule 75 (operator -> expression NEQ expression .)
    BITWISE_OR      reduce using rule 75 (operator -> expression NEQ expression .)
    BITWISE_XOR     reduce using rule 75 (operator -> expression NEQ expression .)
    RPAREN          reduce using rule 75 (operator -> expression NEQ expression .)
    COMMA           reduce using rule 75 (operator -> expression NEQ expression .)
    RBRACKET        reduce using rule 75 (operator -> expression NEQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 75 (operator -> expression NEQ expression .) ]
  ! DIVIDE          [ reduce using rule 75 (operator -> expression NEQ expression .) ]
  ! MODULE          [ reduce using rule 75 (operator -> expression NEQ expression .) ]
  ! PLUS            [ reduce using rule 75 (operator -> expression NEQ expression .) ]
  ! MINUS           [ reduce using rule 75 (operator -> expression NEQ expression .) ]
  ! LEQ             [ reduce using rule 75 (operator -> expression NEQ expression .) ]
  ! GEQ             [ reduce using rule 75 (operator -> expression NEQ expression .) ]
  ! LT              [ reduce using rule 75 (operator -> expression NEQ expression .) ]
  ! GT              [ reduce using rule 75 (operator -> expression NEQ expression .) ]
  ! URSHIFT         [ reduce using rule 75 (operator -> expression NEQ expression .) ]
  ! LSHIFT          [ reduce using rule 75 (operator -> expression NEQ expression .) ]
  ! RSHIFT          [ reduce using rule 75 (operator -> expression NEQ expression .) ]
  ! NEQ             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 87 ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]
  ! BITWISE_XOR     [ shift and go to state 92 ]

    operatorbittobit               shift and go to state 93

state 140

    (76) operator -> expression EQ expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 76 (operator -> expression EQ expression .)
    NEQ             reduce using rule 76 (operator -> expression EQ expression .)
    EQ              reduce using rule 76 (operator -> expression EQ expression .)
    AND             reduce using rule 76 (operator -> expression EQ expression .)
    OR              reduce using rule 76 (operator -> expression EQ expression .)
    BITWISE_AND     reduce using rule 76 (operator -> expression EQ expression .)
    BITWISE_OR      reduce using rule 76 (operator -> expression EQ expression .)
    BITWISE_XOR     reduce using rule 76 (operator -> expression EQ expression .)
    RPAREN          reduce using rule 76 (operator -> expression EQ expression .)
    COMMA           reduce using rule 76 (operator -> expression EQ expression .)
    RBRACKET        reduce using rule 76 (operator -> expression EQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 76 (operator -> expression EQ expression .) ]
  ! DIVIDE          [ reduce using rule 76 (operator -> expression EQ expression .) ]
  ! MODULE          [ reduce using rule 76 (operator -> expression EQ expression .) ]
  ! PLUS            [ reduce using rule 76 (operator -> expression EQ expression .) ]
  ! MINUS           [ reduce using rule 76 (operator -> expression EQ expression .) ]
  ! LEQ             [ reduce using rule 76 (operator -> expression EQ expression .) ]
  ! GEQ             [ reduce using rule 76 (operator -> expression EQ expression .) ]
  ! LT              [ reduce using rule 76 (operator -> expression EQ expression .) ]
  ! GT              [ reduce using rule 76 (operator -> expression EQ expression .) ]
  ! URSHIFT         [ reduce using rule 76 (operator -> expression EQ expression .) ]
  ! LSHIFT          [ reduce using rule 76 (operator -> expression EQ expression .) ]
  ! RSHIFT          [ reduce using rule 76 (operator -> expression EQ expression .) ]
  ! NEQ             [ shift and go to state 86 ]
  ! EQ              [ shift and go to state 87 ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]
  ! BITWISE_XOR     [ shift and go to state 92 ]

    operatorbittobit               shift and go to state 93

state 141

    (77) operator -> expression AND expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 77 (operator -> expression AND expression .)
    AND             reduce using rule 77 (operator -> expression AND expression .)
    OR              reduce using rule 77 (operator -> expression AND expression .)
    RPAREN          reduce using rule 77 (operator -> expression AND expression .)
    COMMA           reduce using rule 77 (operator -> expression AND expression .)
    RBRACKET        reduce using rule 77 (operator -> expression AND expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 77 (operator -> expression AND expression .) ]
  ! DIVIDE          [ reduce using rule 77 (operator -> expression AND expression .) ]
  ! MODULE          [ reduce using rule 77 (operator -> expression AND expression .) ]
  ! PLUS            [ reduce using rule 77 (operator -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 77 (operator -> expression AND expression .) ]
  ! LEQ             [ reduce using rule 77 (operator -> expression AND expression .) ]
  ! GEQ             [ reduce using rule 77 (operator -> expression AND expression .) ]
  ! LT              [ reduce using rule 77 (operator -> expression AND expression .) ]
  ! GT              [ reduce using rule 77 (operator -> expression AND expression .) ]
  ! NEQ             [ reduce using rule 77 (operator -> expression AND expression .) ]
  ! EQ              [ reduce using rule 77 (operator -> expression AND expression .) ]
  ! BITWISE_AND     [ reduce using rule 77 (operator -> expression AND expression .) ]
  ! BITWISE_OR      [ reduce using rule 77 (operator -> expression AND expression .) ]
  ! BITWISE_XOR     [ reduce using rule 77 (operator -> expression AND expression .) ]
  ! URSHIFT         [ reduce using rule 77 (operator -> expression AND expression .) ]
  ! LSHIFT          [ reduce using rule 77 (operator -> expression AND expression .) ]
  ! RSHIFT          [ reduce using rule 77 (operator -> expression AND expression .) ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]

    operatorbittobit               shift and go to state 93

state 142

    (78) operator -> expression OR expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 78 (operator -> expression OR expression .)
    OR              reduce using rule 78 (operator -> expression OR expression .)
    RPAREN          reduce using rule 78 (operator -> expression OR expression .)
    COMMA           reduce using rule 78 (operator -> expression OR expression .)
    RBRACKET        reduce using rule 78 (operator -> expression OR expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 78 (operator -> expression OR expression .) ]
  ! DIVIDE          [ reduce using rule 78 (operator -> expression OR expression .) ]
  ! MODULE          [ reduce using rule 78 (operator -> expression OR expression .) ]
  ! PLUS            [ reduce using rule 78 (operator -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 78 (operator -> expression OR expression .) ]
  ! LEQ             [ reduce using rule 78 (operator -> expression OR expression .) ]
  ! GEQ             [ reduce using rule 78 (operator -> expression OR expression .) ]
  ! LT              [ reduce using rule 78 (operator -> expression OR expression .) ]
  ! GT              [ reduce using rule 78 (operator -> expression OR expression .) ]
  ! NEQ             [ reduce using rule 78 (operator -> expression OR expression .) ]
  ! EQ              [ reduce using rule 78 (operator -> expression OR expression .) ]
  ! AND             [ reduce using rule 78 (operator -> expression OR expression .) ]
  ! BITWISE_AND     [ reduce using rule 78 (operator -> expression OR expression .) ]
  ! BITWISE_OR      [ reduce using rule 78 (operator -> expression OR expression .) ]
  ! BITWISE_XOR     [ reduce using rule 78 (operator -> expression OR expression .) ]
  ! URSHIFT         [ reduce using rule 78 (operator -> expression OR expression .) ]
  ! LSHIFT          [ reduce using rule 78 (operator -> expression OR expression .) ]
  ! RSHIFT          [ reduce using rule 78 (operator -> expression OR expression .) ]
  ! OR              [ shift and go to state 89 ]

    operatorbittobit               shift and go to state 93

state 143

    (79) operator -> expression BITWISE_AND expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 79 (operator -> expression BITWISE_AND expression .)
    AND             reduce using rule 79 (operator -> expression BITWISE_AND expression .)
    OR              reduce using rule 79 (operator -> expression BITWISE_AND expression .)
    BITWISE_AND     reduce using rule 79 (operator -> expression BITWISE_AND expression .)
    BITWISE_OR      reduce using rule 79 (operator -> expression BITWISE_AND expression .)
    BITWISE_XOR     reduce using rule 79 (operator -> expression BITWISE_AND expression .)
    RPAREN          reduce using rule 79 (operator -> expression BITWISE_AND expression .)
    COMMA           reduce using rule 79 (operator -> expression BITWISE_AND expression .)
    RBRACKET        reduce using rule 79 (operator -> expression BITWISE_AND expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 79 (operator -> expression BITWISE_AND expression .) ]
  ! DIVIDE          [ reduce using rule 79 (operator -> expression BITWISE_AND expression .) ]
  ! MODULE          [ reduce using rule 79 (operator -> expression BITWISE_AND expression .) ]
  ! PLUS            [ reduce using rule 79 (operator -> expression BITWISE_AND expression .) ]
  ! MINUS           [ reduce using rule 79 (operator -> expression BITWISE_AND expression .) ]
  ! LEQ             [ reduce using rule 79 (operator -> expression BITWISE_AND expression .) ]
  ! GEQ             [ reduce using rule 79 (operator -> expression BITWISE_AND expression .) ]
  ! LT              [ reduce using rule 79 (operator -> expression BITWISE_AND expression .) ]
  ! GT              [ reduce using rule 79 (operator -> expression BITWISE_AND expression .) ]
  ! NEQ             [ reduce using rule 79 (operator -> expression BITWISE_AND expression .) ]
  ! EQ              [ reduce using rule 79 (operator -> expression BITWISE_AND expression .) ]
  ! URSHIFT         [ reduce using rule 79 (operator -> expression BITWISE_AND expression .) ]
  ! LSHIFT          [ reduce using rule 79 (operator -> expression BITWISE_AND expression .) ]
  ! RSHIFT          [ reduce using rule 79 (operator -> expression BITWISE_AND expression .) ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! BITWISE_AND     [ shift and go to state 90 ]
  ! BITWISE_OR      [ shift and go to state 91 ]
  ! BITWISE_XOR     [ shift and go to state 92 ]

    operatorbittobit               shift and go to state 93

state 144

    (80) operator -> expression BITWISE_OR expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 80 (operator -> expression BITWISE_OR expression .)
    AND             reduce using rule 80 (operator -> expression BITWISE_OR expression .)
    OR              reduce using rule 80 (operator -> expression BITWISE_OR expression .)
    BITWISE_OR      reduce using rule 80 (operator -> expression BITWISE_OR expression .)
    RPAREN          reduce using rule 80 (operator -> expression BITWISE_OR expression .)
    COMMA           reduce using rule 80 (operator -> expression BITWISE_OR expression .)
    RBRACKET        reduce using rule 80 (operator -> expression BITWISE_OR expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    BITWISE_AND     shift and go to state 90
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 80 (operator -> expression BITWISE_OR expression .) ]
  ! DIVIDE          [ reduce using rule 80 (operator -> expression BITWISE_OR expression .) ]
  ! MODULE          [ reduce using rule 80 (operator -> expression BITWISE_OR expression .) ]
  ! PLUS            [ reduce using rule 80 (operator -> expression BITWISE_OR expression .) ]
  ! MINUS           [ reduce using rule 80 (operator -> expression BITWISE_OR expression .) ]
  ! LEQ             [ reduce using rule 80 (operator -> expression BITWISE_OR expression .) ]
  ! GEQ             [ reduce using rule 80 (operator -> expression BITWISE_OR expression .) ]
  ! LT              [ reduce using rule 80 (operator -> expression BITWISE_OR expression .) ]
  ! GT              [ reduce using rule 80 (operator -> expression BITWISE_OR expression .) ]
  ! NEQ             [ reduce using rule 80 (operator -> expression BITWISE_OR expression .) ]
  ! EQ              [ reduce using rule 80 (operator -> expression BITWISE_OR expression .) ]
  ! BITWISE_AND     [ reduce using rule 80 (operator -> expression BITWISE_OR expression .) ]
  ! BITWISE_XOR     [ reduce using rule 80 (operator -> expression BITWISE_OR expression .) ]
  ! URSHIFT         [ reduce using rule 80 (operator -> expression BITWISE_OR expression .) ]
  ! LSHIFT          [ reduce using rule 80 (operator -> expression BITWISE_OR expression .) ]
  ! RSHIFT          [ reduce using rule 80 (operator -> expression BITWISE_OR expression .) ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! BITWISE_OR      [ shift and go to state 91 ]

    operatorbittobit               shift and go to state 93

state 145

    (81) operator -> expression BITWISE_XOR expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 81 (operator -> expression BITWISE_XOR expression .)
    AND             reduce using rule 81 (operator -> expression BITWISE_XOR expression .)
    OR              reduce using rule 81 (operator -> expression BITWISE_XOR expression .)
    BITWISE_OR      reduce using rule 81 (operator -> expression BITWISE_XOR expression .)
    BITWISE_XOR     reduce using rule 81 (operator -> expression BITWISE_XOR expression .)
    RPAREN          reduce using rule 81 (operator -> expression BITWISE_XOR expression .)
    COMMA           reduce using rule 81 (operator -> expression BITWISE_XOR expression .)
    RBRACKET        reduce using rule 81 (operator -> expression BITWISE_XOR expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    BITWISE_AND     shift and go to state 90
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 81 (operator -> expression BITWISE_XOR expression .) ]
  ! DIVIDE          [ reduce using rule 81 (operator -> expression BITWISE_XOR expression .) ]
  ! MODULE          [ reduce using rule 81 (operator -> expression BITWISE_XOR expression .) ]
  ! PLUS            [ reduce using rule 81 (operator -> expression BITWISE_XOR expression .) ]
  ! MINUS           [ reduce using rule 81 (operator -> expression BITWISE_XOR expression .) ]
  ! LEQ             [ reduce using rule 81 (operator -> expression BITWISE_XOR expression .) ]
  ! GEQ             [ reduce using rule 81 (operator -> expression BITWISE_XOR expression .) ]
  ! LT              [ reduce using rule 81 (operator -> expression BITWISE_XOR expression .) ]
  ! GT              [ reduce using rule 81 (operator -> expression BITWISE_XOR expression .) ]
  ! NEQ             [ reduce using rule 81 (operator -> expression BITWISE_XOR expression .) ]
  ! EQ              [ reduce using rule 81 (operator -> expression BITWISE_XOR expression .) ]
  ! BITWISE_AND     [ reduce using rule 81 (operator -> expression BITWISE_XOR expression .) ]
  ! URSHIFT         [ reduce using rule 81 (operator -> expression BITWISE_XOR expression .) ]
  ! LSHIFT          [ reduce using rule 81 (operator -> expression BITWISE_XOR expression .) ]
  ! RSHIFT          [ reduce using rule 81 (operator -> expression BITWISE_XOR expression .) ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! BITWISE_OR      [ shift and go to state 91 ]
  ! BITWISE_XOR     [ shift and go to state 92 ]

    operatorbittobit               shift and go to state 93

state 146

    (31) stm -> WHILE LPAREN expression . RPAREN bodyorstm
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    RPAREN          shift and go to state 177
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

    operatorbittobit               shift and go to state 93

state 147

    (32) stm -> DO bodyorstm WHILE . LPAREN expression RPAREN SEMICOLON

    LPAREN          shift and go to state 178


state 148

    (33) stm -> FOR LPAREN expression_for . SEMICOLON expression SEMICOLON expression RPAREN bodyorstm

    SEMICOLON       shift and go to state 179


state 149

    (43) expression_for -> type . ID EQUAL expression

    ID              shift and go to state 180


state 150

    (44) expression_for -> ID . EQUAL expression

    EQUAL           shift and go to state 181


state 151

    (34) stm -> IF LPAREN expression . RPAREN bodyorstm
    (35) stm -> IF LPAREN expression . RPAREN bodyorstm ELSE bodyorstm
    (36) stm -> IF LPAREN expression . RPAREN bodyorstm ELSE IF bodyorstm
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    RPAREN          shift and go to state 182
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

    operatorbittobit               shift and go to state 93

state 152

    (38) stm -> atributemodifier type ID . SEMICOLON
    (39) stm -> atributemodifier type ID . EQUAL expression SEMICOLON

    SEMICOLON       shift and go to state 183
    EQUAL           shift and go to state 184


state 153

    (59) operator -> ID EQUAL expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 59 (operator -> ID EQUAL expression .)
    RPAREN          reduce using rule 59 (operator -> ID EQUAL expression .)
    COMMA           reduce using rule 59 (operator -> ID EQUAL expression .)
    RBRACKET        reduce using rule 59 (operator -> ID EQUAL expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 59 (operator -> ID EQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 59 (operator -> ID EQUAL expression .) ]
  ! MODULE          [ reduce using rule 59 (operator -> ID EQUAL expression .) ]
  ! PLUS            [ reduce using rule 59 (operator -> ID EQUAL expression .) ]
  ! MINUS           [ reduce using rule 59 (operator -> ID EQUAL expression .) ]
  ! LEQ             [ reduce using rule 59 (operator -> ID EQUAL expression .) ]
  ! GEQ             [ reduce using rule 59 (operator -> ID EQUAL expression .) ]
  ! LT              [ reduce using rule 59 (operator -> ID EQUAL expression .) ]
  ! GT              [ reduce using rule 59 (operator -> ID EQUAL expression .) ]
  ! NEQ             [ reduce using rule 59 (operator -> ID EQUAL expression .) ]
  ! EQ              [ reduce using rule 59 (operator -> ID EQUAL expression .) ]
  ! AND             [ reduce using rule 59 (operator -> ID EQUAL expression .) ]
  ! OR              [ reduce using rule 59 (operator -> ID EQUAL expression .) ]
  ! BITWISE_AND     [ reduce using rule 59 (operator -> ID EQUAL expression .) ]
  ! BITWISE_OR      [ reduce using rule 59 (operator -> ID EQUAL expression .) ]
  ! BITWISE_XOR     [ reduce using rule 59 (operator -> ID EQUAL expression .) ]
  ! URSHIFT         [ reduce using rule 59 (operator -> ID EQUAL expression .) ]
  ! LSHIFT          [ reduce using rule 59 (operator -> ID EQUAL expression .) ]
  ! RSHIFT          [ reduce using rule 59 (operator -> ID EQUAL expression .) ]

    operatorbittobit               shift and go to state 93

state 154

    (60) operator -> ID MINUS_EQ expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 60 (operator -> ID MINUS_EQ expression .)
    RPAREN          reduce using rule 60 (operator -> ID MINUS_EQ expression .)
    COMMA           reduce using rule 60 (operator -> ID MINUS_EQ expression .)
    RBRACKET        reduce using rule 60 (operator -> ID MINUS_EQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 60 (operator -> ID MINUS_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 60 (operator -> ID MINUS_EQ expression .) ]
  ! MODULE          [ reduce using rule 60 (operator -> ID MINUS_EQ expression .) ]
  ! PLUS            [ reduce using rule 60 (operator -> ID MINUS_EQ expression .) ]
  ! MINUS           [ reduce using rule 60 (operator -> ID MINUS_EQ expression .) ]
  ! LEQ             [ reduce using rule 60 (operator -> ID MINUS_EQ expression .) ]
  ! GEQ             [ reduce using rule 60 (operator -> ID MINUS_EQ expression .) ]
  ! LT              [ reduce using rule 60 (operator -> ID MINUS_EQ expression .) ]
  ! GT              [ reduce using rule 60 (operator -> ID MINUS_EQ expression .) ]
  ! NEQ             [ reduce using rule 60 (operator -> ID MINUS_EQ expression .) ]
  ! EQ              [ reduce using rule 60 (operator -> ID MINUS_EQ expression .) ]
  ! AND             [ reduce using rule 60 (operator -> ID MINUS_EQ expression .) ]
  ! OR              [ reduce using rule 60 (operator -> ID MINUS_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 60 (operator -> ID MINUS_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 60 (operator -> ID MINUS_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 60 (operator -> ID MINUS_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 60 (operator -> ID MINUS_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 60 (operator -> ID MINUS_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 60 (operator -> ID MINUS_EQ expression .) ]

    operatorbittobit               shift and go to state 93

state 155

    (61) operator -> ID TIMES_EQ expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 61 (operator -> ID TIMES_EQ expression .)
    RPAREN          reduce using rule 61 (operator -> ID TIMES_EQ expression .)
    COMMA           reduce using rule 61 (operator -> ID TIMES_EQ expression .)
    RBRACKET        reduce using rule 61 (operator -> ID TIMES_EQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 61 (operator -> ID TIMES_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 61 (operator -> ID TIMES_EQ expression .) ]
  ! MODULE          [ reduce using rule 61 (operator -> ID TIMES_EQ expression .) ]
  ! PLUS            [ reduce using rule 61 (operator -> ID TIMES_EQ expression .) ]
  ! MINUS           [ reduce using rule 61 (operator -> ID TIMES_EQ expression .) ]
  ! LEQ             [ reduce using rule 61 (operator -> ID TIMES_EQ expression .) ]
  ! GEQ             [ reduce using rule 61 (operator -> ID TIMES_EQ expression .) ]
  ! LT              [ reduce using rule 61 (operator -> ID TIMES_EQ expression .) ]
  ! GT              [ reduce using rule 61 (operator -> ID TIMES_EQ expression .) ]
  ! NEQ             [ reduce using rule 61 (operator -> ID TIMES_EQ expression .) ]
  ! EQ              [ reduce using rule 61 (operator -> ID TIMES_EQ expression .) ]
  ! AND             [ reduce using rule 61 (operator -> ID TIMES_EQ expression .) ]
  ! OR              [ reduce using rule 61 (operator -> ID TIMES_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 61 (operator -> ID TIMES_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 61 (operator -> ID TIMES_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 61 (operator -> ID TIMES_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 61 (operator -> ID TIMES_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 61 (operator -> ID TIMES_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 61 (operator -> ID TIMES_EQ expression .) ]

    operatorbittobit               shift and go to state 93

state 156

    (62) operator -> ID PLUS_EQ expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 62 (operator -> ID PLUS_EQ expression .)
    RPAREN          reduce using rule 62 (operator -> ID PLUS_EQ expression .)
    COMMA           reduce using rule 62 (operator -> ID PLUS_EQ expression .)
    RBRACKET        reduce using rule 62 (operator -> ID PLUS_EQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 62 (operator -> ID PLUS_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 62 (operator -> ID PLUS_EQ expression .) ]
  ! MODULE          [ reduce using rule 62 (operator -> ID PLUS_EQ expression .) ]
  ! PLUS            [ reduce using rule 62 (operator -> ID PLUS_EQ expression .) ]
  ! MINUS           [ reduce using rule 62 (operator -> ID PLUS_EQ expression .) ]
  ! LEQ             [ reduce using rule 62 (operator -> ID PLUS_EQ expression .) ]
  ! GEQ             [ reduce using rule 62 (operator -> ID PLUS_EQ expression .) ]
  ! LT              [ reduce using rule 62 (operator -> ID PLUS_EQ expression .) ]
  ! GT              [ reduce using rule 62 (operator -> ID PLUS_EQ expression .) ]
  ! NEQ             [ reduce using rule 62 (operator -> ID PLUS_EQ expression .) ]
  ! EQ              [ reduce using rule 62 (operator -> ID PLUS_EQ expression .) ]
  ! AND             [ reduce using rule 62 (operator -> ID PLUS_EQ expression .) ]
  ! OR              [ reduce using rule 62 (operator -> ID PLUS_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 62 (operator -> ID PLUS_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 62 (operator -> ID PLUS_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 62 (operator -> ID PLUS_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 62 (operator -> ID PLUS_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 62 (operator -> ID PLUS_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 62 (operator -> ID PLUS_EQ expression .) ]

    operatorbittobit               shift and go to state 93

state 157

    (63) operator -> ID DIVIDE_EQ expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 63 (operator -> ID DIVIDE_EQ expression .)
    RPAREN          reduce using rule 63 (operator -> ID DIVIDE_EQ expression .)
    COMMA           reduce using rule 63 (operator -> ID DIVIDE_EQ expression .)
    RBRACKET        reduce using rule 63 (operator -> ID DIVIDE_EQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 63 (operator -> ID DIVIDE_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 63 (operator -> ID DIVIDE_EQ expression .) ]
  ! MODULE          [ reduce using rule 63 (operator -> ID DIVIDE_EQ expression .) ]
  ! PLUS            [ reduce using rule 63 (operator -> ID DIVIDE_EQ expression .) ]
  ! MINUS           [ reduce using rule 63 (operator -> ID DIVIDE_EQ expression .) ]
  ! LEQ             [ reduce using rule 63 (operator -> ID DIVIDE_EQ expression .) ]
  ! GEQ             [ reduce using rule 63 (operator -> ID DIVIDE_EQ expression .) ]
  ! LT              [ reduce using rule 63 (operator -> ID DIVIDE_EQ expression .) ]
  ! GT              [ reduce using rule 63 (operator -> ID DIVIDE_EQ expression .) ]
  ! NEQ             [ reduce using rule 63 (operator -> ID DIVIDE_EQ expression .) ]
  ! EQ              [ reduce using rule 63 (operator -> ID DIVIDE_EQ expression .) ]
  ! AND             [ reduce using rule 63 (operator -> ID DIVIDE_EQ expression .) ]
  ! OR              [ reduce using rule 63 (operator -> ID DIVIDE_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 63 (operator -> ID DIVIDE_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 63 (operator -> ID DIVIDE_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 63 (operator -> ID DIVIDE_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 63 (operator -> ID DIVIDE_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 63 (operator -> ID DIVIDE_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 63 (operator -> ID DIVIDE_EQ expression .) ]

    operatorbittobit               shift and go to state 93

state 158

    (64) operator -> ID MOD_EQ expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 64 (operator -> ID MOD_EQ expression .)
    RPAREN          reduce using rule 64 (operator -> ID MOD_EQ expression .)
    COMMA           reduce using rule 64 (operator -> ID MOD_EQ expression .)
    RBRACKET        reduce using rule 64 (operator -> ID MOD_EQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 64 (operator -> ID MOD_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 64 (operator -> ID MOD_EQ expression .) ]
  ! MODULE          [ reduce using rule 64 (operator -> ID MOD_EQ expression .) ]
  ! PLUS            [ reduce using rule 64 (operator -> ID MOD_EQ expression .) ]
  ! MINUS           [ reduce using rule 64 (operator -> ID MOD_EQ expression .) ]
  ! LEQ             [ reduce using rule 64 (operator -> ID MOD_EQ expression .) ]
  ! GEQ             [ reduce using rule 64 (operator -> ID MOD_EQ expression .) ]
  ! LT              [ reduce using rule 64 (operator -> ID MOD_EQ expression .) ]
  ! GT              [ reduce using rule 64 (operator -> ID MOD_EQ expression .) ]
  ! NEQ             [ reduce using rule 64 (operator -> ID MOD_EQ expression .) ]
  ! EQ              [ reduce using rule 64 (operator -> ID MOD_EQ expression .) ]
  ! AND             [ reduce using rule 64 (operator -> ID MOD_EQ expression .) ]
  ! OR              [ reduce using rule 64 (operator -> ID MOD_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 64 (operator -> ID MOD_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 64 (operator -> ID MOD_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 64 (operator -> ID MOD_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 64 (operator -> ID MOD_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 64 (operator -> ID MOD_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 64 (operator -> ID MOD_EQ expression .) ]

    operatorbittobit               shift and go to state 93

state 159

    (65) operator -> ID BITWISE_AND_EQ expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 65 (operator -> ID BITWISE_AND_EQ expression .)
    RPAREN          reduce using rule 65 (operator -> ID BITWISE_AND_EQ expression .)
    COMMA           reduce using rule 65 (operator -> ID BITWISE_AND_EQ expression .)
    RBRACKET        reduce using rule 65 (operator -> ID BITWISE_AND_EQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 65 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 65 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! MODULE          [ reduce using rule 65 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! PLUS            [ reduce using rule 65 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! MINUS           [ reduce using rule 65 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! LEQ             [ reduce using rule 65 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! GEQ             [ reduce using rule 65 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! LT              [ reduce using rule 65 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! GT              [ reduce using rule 65 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! NEQ             [ reduce using rule 65 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! EQ              [ reduce using rule 65 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! AND             [ reduce using rule 65 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! OR              [ reduce using rule 65 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 65 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 65 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 65 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 65 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 65 (operator -> ID BITWISE_AND_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 65 (operator -> ID BITWISE_AND_EQ expression .) ]

    operatorbittobit               shift and go to state 93

state 160

    (66) operator -> ID BITWISE_OR_EQ expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 66 (operator -> ID BITWISE_OR_EQ expression .)
    RPAREN          reduce using rule 66 (operator -> ID BITWISE_OR_EQ expression .)
    COMMA           reduce using rule 66 (operator -> ID BITWISE_OR_EQ expression .)
    RBRACKET        reduce using rule 66 (operator -> ID BITWISE_OR_EQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 66 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 66 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! MODULE          [ reduce using rule 66 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! PLUS            [ reduce using rule 66 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! MINUS           [ reduce using rule 66 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! LEQ             [ reduce using rule 66 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! GEQ             [ reduce using rule 66 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! LT              [ reduce using rule 66 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! GT              [ reduce using rule 66 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! NEQ             [ reduce using rule 66 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! EQ              [ reduce using rule 66 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! AND             [ reduce using rule 66 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! OR              [ reduce using rule 66 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 66 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 66 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 66 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 66 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 66 (operator -> ID BITWISE_OR_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 66 (operator -> ID BITWISE_OR_EQ expression .) ]

    operatorbittobit               shift and go to state 93

state 161

    (67) operator -> ID BITWISE_XOR_EQ expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 67 (operator -> ID BITWISE_XOR_EQ expression .)
    RPAREN          reduce using rule 67 (operator -> ID BITWISE_XOR_EQ expression .)
    COMMA           reduce using rule 67 (operator -> ID BITWISE_XOR_EQ expression .)
    RBRACKET        reduce using rule 67 (operator -> ID BITWISE_XOR_EQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 67 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 67 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! MODULE          [ reduce using rule 67 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! PLUS            [ reduce using rule 67 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! MINUS           [ reduce using rule 67 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! LEQ             [ reduce using rule 67 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! GEQ             [ reduce using rule 67 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! LT              [ reduce using rule 67 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! GT              [ reduce using rule 67 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! NEQ             [ reduce using rule 67 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! EQ              [ reduce using rule 67 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! AND             [ reduce using rule 67 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! OR              [ reduce using rule 67 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 67 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 67 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 67 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 67 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 67 (operator -> ID BITWISE_XOR_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 67 (operator -> ID BITWISE_XOR_EQ expression .) ]

    operatorbittobit               shift and go to state 93

state 162

    (68) operator -> ID URSHIFT_EQ expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 68 (operator -> ID URSHIFT_EQ expression .)
    RPAREN          reduce using rule 68 (operator -> ID URSHIFT_EQ expression .)
    COMMA           reduce using rule 68 (operator -> ID URSHIFT_EQ expression .)
    RBRACKET        reduce using rule 68 (operator -> ID URSHIFT_EQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 68 (operator -> ID URSHIFT_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 68 (operator -> ID URSHIFT_EQ expression .) ]
  ! MODULE          [ reduce using rule 68 (operator -> ID URSHIFT_EQ expression .) ]
  ! PLUS            [ reduce using rule 68 (operator -> ID URSHIFT_EQ expression .) ]
  ! MINUS           [ reduce using rule 68 (operator -> ID URSHIFT_EQ expression .) ]
  ! LEQ             [ reduce using rule 68 (operator -> ID URSHIFT_EQ expression .) ]
  ! GEQ             [ reduce using rule 68 (operator -> ID URSHIFT_EQ expression .) ]
  ! LT              [ reduce using rule 68 (operator -> ID URSHIFT_EQ expression .) ]
  ! GT              [ reduce using rule 68 (operator -> ID URSHIFT_EQ expression .) ]
  ! NEQ             [ reduce using rule 68 (operator -> ID URSHIFT_EQ expression .) ]
  ! EQ              [ reduce using rule 68 (operator -> ID URSHIFT_EQ expression .) ]
  ! AND             [ reduce using rule 68 (operator -> ID URSHIFT_EQ expression .) ]
  ! OR              [ reduce using rule 68 (operator -> ID URSHIFT_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 68 (operator -> ID URSHIFT_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 68 (operator -> ID URSHIFT_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 68 (operator -> ID URSHIFT_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 68 (operator -> ID URSHIFT_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 68 (operator -> ID URSHIFT_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 68 (operator -> ID URSHIFT_EQ expression .) ]

    operatorbittobit               shift and go to state 93

state 163

    (69) operator -> ID LSHIFT_EQ expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 69 (operator -> ID LSHIFT_EQ expression .)
    RPAREN          reduce using rule 69 (operator -> ID LSHIFT_EQ expression .)
    COMMA           reduce using rule 69 (operator -> ID LSHIFT_EQ expression .)
    RBRACKET        reduce using rule 69 (operator -> ID LSHIFT_EQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 69 (operator -> ID LSHIFT_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 69 (operator -> ID LSHIFT_EQ expression .) ]
  ! MODULE          [ reduce using rule 69 (operator -> ID LSHIFT_EQ expression .) ]
  ! PLUS            [ reduce using rule 69 (operator -> ID LSHIFT_EQ expression .) ]
  ! MINUS           [ reduce using rule 69 (operator -> ID LSHIFT_EQ expression .) ]
  ! LEQ             [ reduce using rule 69 (operator -> ID LSHIFT_EQ expression .) ]
  ! GEQ             [ reduce using rule 69 (operator -> ID LSHIFT_EQ expression .) ]
  ! LT              [ reduce using rule 69 (operator -> ID LSHIFT_EQ expression .) ]
  ! GT              [ reduce using rule 69 (operator -> ID LSHIFT_EQ expression .) ]
  ! NEQ             [ reduce using rule 69 (operator -> ID LSHIFT_EQ expression .) ]
  ! EQ              [ reduce using rule 69 (operator -> ID LSHIFT_EQ expression .) ]
  ! AND             [ reduce using rule 69 (operator -> ID LSHIFT_EQ expression .) ]
  ! OR              [ reduce using rule 69 (operator -> ID LSHIFT_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 69 (operator -> ID LSHIFT_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 69 (operator -> ID LSHIFT_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 69 (operator -> ID LSHIFT_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 69 (operator -> ID LSHIFT_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 69 (operator -> ID LSHIFT_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 69 (operator -> ID LSHIFT_EQ expression .) ]

    operatorbittobit               shift and go to state 93

state 164

    (70) operator -> ID RSHIFT_EQ expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 70 (operator -> ID RSHIFT_EQ expression .)
    RPAREN          reduce using rule 70 (operator -> ID RSHIFT_EQ expression .)
    COMMA           reduce using rule 70 (operator -> ID RSHIFT_EQ expression .)
    RBRACKET        reduce using rule 70 (operator -> ID RSHIFT_EQ expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

  ! TIMES           [ reduce using rule 70 (operator -> ID RSHIFT_EQ expression .) ]
  ! DIVIDE          [ reduce using rule 70 (operator -> ID RSHIFT_EQ expression .) ]
  ! MODULE          [ reduce using rule 70 (operator -> ID RSHIFT_EQ expression .) ]
  ! PLUS            [ reduce using rule 70 (operator -> ID RSHIFT_EQ expression .) ]
  ! MINUS           [ reduce using rule 70 (operator -> ID RSHIFT_EQ expression .) ]
  ! LEQ             [ reduce using rule 70 (operator -> ID RSHIFT_EQ expression .) ]
  ! GEQ             [ reduce using rule 70 (operator -> ID RSHIFT_EQ expression .) ]
  ! LT              [ reduce using rule 70 (operator -> ID RSHIFT_EQ expression .) ]
  ! GT              [ reduce using rule 70 (operator -> ID RSHIFT_EQ expression .) ]
  ! NEQ             [ reduce using rule 70 (operator -> ID RSHIFT_EQ expression .) ]
  ! EQ              [ reduce using rule 70 (operator -> ID RSHIFT_EQ expression .) ]
  ! AND             [ reduce using rule 70 (operator -> ID RSHIFT_EQ expression .) ]
  ! OR              [ reduce using rule 70 (operator -> ID RSHIFT_EQ expression .) ]
  ! BITWISE_AND     [ reduce using rule 70 (operator -> ID RSHIFT_EQ expression .) ]
  ! BITWISE_OR      [ reduce using rule 70 (operator -> ID RSHIFT_EQ expression .) ]
  ! BITWISE_XOR     [ reduce using rule 70 (operator -> ID RSHIFT_EQ expression .) ]
  ! URSHIFT         [ reduce using rule 70 (operator -> ID RSHIFT_EQ expression .) ]
  ! LSHIFT          [ reduce using rule 70 (operator -> ID RSHIFT_EQ expression .) ]
  ! RSHIFT          [ reduce using rule 70 (operator -> ID RSHIFT_EQ expression .) ]

    operatorbittobit               shift and go to state 93

state 165

    (108) call -> ID LPAREN params_call . RPAREN

    RPAREN          shift and go to state 185


state 166

    (109) call -> ID LPAREN RPAREN .

    SEMICOLON       reduce using rule 109 (call -> ID LPAREN RPAREN .)
    TIMES           reduce using rule 109 (call -> ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 109 (call -> ID LPAREN RPAREN .)
    MODULE          reduce using rule 109 (call -> ID LPAREN RPAREN .)
    PLUS            reduce using rule 109 (call -> ID LPAREN RPAREN .)
    MINUS           reduce using rule 109 (call -> ID LPAREN RPAREN .)
    LEQ             reduce using rule 109 (call -> ID LPAREN RPAREN .)
    GEQ             reduce using rule 109 (call -> ID LPAREN RPAREN .)
    LT              reduce using rule 109 (call -> ID LPAREN RPAREN .)
    GT              reduce using rule 109 (call -> ID LPAREN RPAREN .)
    NEQ             reduce using rule 109 (call -> ID LPAREN RPAREN .)
    EQ              reduce using rule 109 (call -> ID LPAREN RPAREN .)
    AND             reduce using rule 109 (call -> ID LPAREN RPAREN .)
    OR              reduce using rule 109 (call -> ID LPAREN RPAREN .)
    BITWISE_AND     reduce using rule 109 (call -> ID LPAREN RPAREN .)
    BITWISE_OR      reduce using rule 109 (call -> ID LPAREN RPAREN .)
    BITWISE_XOR     reduce using rule 109 (call -> ID LPAREN RPAREN .)
    URSHIFT         reduce using rule 109 (call -> ID LPAREN RPAREN .)
    LSHIFT          reduce using rule 109 (call -> ID LPAREN RPAREN .)
    RSHIFT          reduce using rule 109 (call -> ID LPAREN RPAREN .)
    RPAREN          reduce using rule 109 (call -> ID LPAREN RPAREN .)
    COMMA           reduce using rule 109 (call -> ID LPAREN RPAREN .)
    RBRACKET        reduce using rule 109 (call -> ID LPAREN RPAREN .)


state 167

    (110) params_call -> expression . COMMA params_call
    (111) params_call -> expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    COMMA           shift and go to state 186
    RPAREN          reduce using rule 111 (params_call -> expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

    operatorbittobit               shift and go to state 93

state 168

    (40) stm -> RETURN expression SEMICOLON .

    WHILE           reduce using rule 40 (stm -> RETURN expression SEMICOLON .)
    DO              reduce using rule 40 (stm -> RETURN expression SEMICOLON .)
    FOR             reduce using rule 40 (stm -> RETURN expression SEMICOLON .)
    IF              reduce using rule 40 (stm -> RETURN expression SEMICOLON .)
    SEMICOLON       reduce using rule 40 (stm -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 40 (stm -> RETURN expression SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 40 (stm -> RETURN expression SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 40 (stm -> RETURN expression SEMICOLON .)
    INT_NUMBER      reduce using rule 40 (stm -> RETURN expression SEMICOLON .)
    STRING          reduce using rule 40 (stm -> RETURN expression SEMICOLON .)
    ID              reduce using rule 40 (stm -> RETURN expression SEMICOLON .)
    NEW             reduce using rule 40 (stm -> RETURN expression SEMICOLON .)
    STATIC          reduce using rule 40 (stm -> RETURN expression SEMICOLON .)
    FINAL           reduce using rule 40 (stm -> RETURN expression SEMICOLON .)
    INCREMENT       reduce using rule 40 (stm -> RETURN expression SEMICOLON .)
    DECREMENT       reduce using rule 40 (stm -> RETURN expression SEMICOLON .)
    MINUS           reduce using rule 40 (stm -> RETURN expression SEMICOLON .)
    PLUS            reduce using rule 40 (stm -> RETURN expression SEMICOLON .)
    NOT             reduce using rule 40 (stm -> RETURN expression SEMICOLON .)
    TYPE_INT        reduce using rule 40 (stm -> RETURN expression SEMICOLON .)
    TYPE_FLOAT      reduce using rule 40 (stm -> RETURN expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 40 (stm -> RETURN expression SEMICOLON .)
    TYPE_BYTE       reduce using rule 40 (stm -> RETURN expression SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 40 (stm -> RETURN expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 40 (stm -> RETURN expression SEMICOLON .)
    TYPE_STRING     reduce using rule 40 (stm -> RETURN expression SEMICOLON .)
    TYPE_LONG       reduce using rule 40 (stm -> RETURN expression SEMICOLON .)
    TYPE_VOID       reduce using rule 40 (stm -> RETURN expression SEMICOLON .)
    RCHAV           reduce using rule 40 (stm -> RETURN expression SEMICOLON .)


state 169

    (52) expression -> NEW type LPAREN . params_call RPAREN
    (110) params_call -> . expression COMMA params_call
    (111) params_call -> . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    params_call                    shift and go to state 187
    expression                     shift and go to state 167
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 170

    (53) expression -> NEW type LBRACKET . expression RBRACKET
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 188
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 171

    (18) atribute -> visibility atributemodifier type ID EQUAL expression . SEMICOLON
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       shift and go to state 189
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

    operatorbittobit               shift and go to state 93

state 172

    (25) sigparams -> type . ID
    (26) sigparams -> type . ID COMMA sigparams

    ID              shift and go to state 190


state 173

    (23) signature -> visibility atributemodifier type ID LPAREN sigparams . RPAREN

    RPAREN          shift and go to state 191


state 174

    (24) signature -> visibility atributemodifier type brackets_expression ID LPAREN . sigparams RPAREN
    (25) sigparams -> . type ID
    (26) sigparams -> . type ID COMMA sigparams
    (98) type -> . primitivetypes
    (99) primitivetypes -> . TYPE_INT
    (100) primitivetypes -> . TYPE_FLOAT
    (101) primitivetypes -> . TYPE_DOUBLE
    (102) primitivetypes -> . TYPE_BYTE
    (103) primitivetypes -> . TYPE_BOOLEAN
    (104) primitivetypes -> . TYPE_CHAR
    (105) primitivetypes -> . TYPE_STRING
    (106) primitivetypes -> . TYPE_LONG
    (107) primitivetypes -> . TYPE_VOID

    TYPE_INT        shift and go to state 36
    TYPE_FLOAT      shift and go to state 37
    TYPE_DOUBLE     shift and go to state 38
    TYPE_BYTE       shift and go to state 39
    TYPE_BOOLEAN    shift and go to state 40
    TYPE_CHAR       shift and go to state 41
    TYPE_STRING     shift and go to state 42
    TYPE_LONG       shift and go to state 43
    TYPE_VOID       shift and go to state 44

    type                           shift and go to state 172
    sigparams                      shift and go to state 192
    primitivetypes                 shift and go to state 35

state 175

    (96) brackets_expression -> LBRACKET INT_NUMBER RBRACKET .

    ID              reduce using rule 96 (brackets_expression -> LBRACKET INT_NUMBER RBRACKET .)


state 176

    (97) brackets_expression -> LBRACKET ID RBRACKET .

    ID              reduce using rule 97 (brackets_expression -> LBRACKET ID RBRACKET .)


state 177

    (31) stm -> WHILE LPAREN expression RPAREN . bodyorstm
    (42) bodyorstm -> . body
    (27) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 31

    bodyorstm                      shift and go to state 193
    body                           shift and go to state 99

state 178

    (32) stm -> DO bodyorstm WHILE LPAREN . expression RPAREN SEMICOLON
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 194
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 179

    (33) stm -> FOR LPAREN expression_for SEMICOLON . expression SEMICOLON expression RPAREN bodyorstm
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 195
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 180

    (43) expression_for -> type ID . EQUAL expression

    EQUAL           shift and go to state 196


state 181

    (44) expression_for -> ID EQUAL . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 197
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 182

    (34) stm -> IF LPAREN expression RPAREN . bodyorstm
    (35) stm -> IF LPAREN expression RPAREN . bodyorstm ELSE bodyorstm
    (36) stm -> IF LPAREN expression RPAREN . bodyorstm ELSE IF bodyorstm
    (42) bodyorstm -> . body
    (27) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 31

    bodyorstm                      shift and go to state 198
    body                           shift and go to state 99

state 183

    (38) stm -> atributemodifier type ID SEMICOLON .

    WHILE           reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    DO              reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    FOR             reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    IF              reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    SEMICOLON       reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    RETURN          reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    INT_NUMBER      reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    STRING          reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    ID              reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    NEW             reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    STATIC          reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    FINAL           reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    INCREMENT       reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    DECREMENT       reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    MINUS           reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    PLUS            reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    NOT             reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    TYPE_INT        reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    TYPE_FLOAT      reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    TYPE_BYTE       reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    TYPE_CHAR       reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    TYPE_STRING     reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    TYPE_LONG       reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    TYPE_VOID       reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)
    RCHAV           reduce using rule 38 (stm -> atributemodifier type ID SEMICOLON .)


state 184

    (39) stm -> atributemodifier type ID EQUAL . expression SEMICOLON
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 199
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 185

    (108) call -> ID LPAREN params_call RPAREN .

    SEMICOLON       reduce using rule 108 (call -> ID LPAREN params_call RPAREN .)
    TIMES           reduce using rule 108 (call -> ID LPAREN params_call RPAREN .)
    DIVIDE          reduce using rule 108 (call -> ID LPAREN params_call RPAREN .)
    MODULE          reduce using rule 108 (call -> ID LPAREN params_call RPAREN .)
    PLUS            reduce using rule 108 (call -> ID LPAREN params_call RPAREN .)
    MINUS           reduce using rule 108 (call -> ID LPAREN params_call RPAREN .)
    LEQ             reduce using rule 108 (call -> ID LPAREN params_call RPAREN .)
    GEQ             reduce using rule 108 (call -> ID LPAREN params_call RPAREN .)
    LT              reduce using rule 108 (call -> ID LPAREN params_call RPAREN .)
    GT              reduce using rule 108 (call -> ID LPAREN params_call RPAREN .)
    NEQ             reduce using rule 108 (call -> ID LPAREN params_call RPAREN .)
    EQ              reduce using rule 108 (call -> ID LPAREN params_call RPAREN .)
    AND             reduce using rule 108 (call -> ID LPAREN params_call RPAREN .)
    OR              reduce using rule 108 (call -> ID LPAREN params_call RPAREN .)
    BITWISE_AND     reduce using rule 108 (call -> ID LPAREN params_call RPAREN .)
    BITWISE_OR      reduce using rule 108 (call -> ID LPAREN params_call RPAREN .)
    BITWISE_XOR     reduce using rule 108 (call -> ID LPAREN params_call RPAREN .)
    URSHIFT         reduce using rule 108 (call -> ID LPAREN params_call RPAREN .)
    LSHIFT          reduce using rule 108 (call -> ID LPAREN params_call RPAREN .)
    RSHIFT          reduce using rule 108 (call -> ID LPAREN params_call RPAREN .)
    RPAREN          reduce using rule 108 (call -> ID LPAREN params_call RPAREN .)
    COMMA           reduce using rule 108 (call -> ID LPAREN params_call RPAREN .)
    RBRACKET        reduce using rule 108 (call -> ID LPAREN params_call RPAREN .)


state 186

    (110) params_call -> expression COMMA . params_call
    (110) params_call -> . expression COMMA params_call
    (111) params_call -> . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 167
    params_call                    shift and go to state 200
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 187

    (52) expression -> NEW type LPAREN params_call . RPAREN

    RPAREN          shift and go to state 201


state 188

    (53) expression -> NEW type LBRACKET expression . RBRACKET
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    RBRACKET        shift and go to state 202
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

    operatorbittobit               shift and go to state 93

state 189

    (18) atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .

    PUBLIC          reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    PRIVATE         reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    PROTECTED       reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    STATIC          reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    FINAL           reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_INT        reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_FLOAT      reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_BYTE       reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_STRING     reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_LONG       reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_VOID       reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)
    RCHAV           reduce using rule 18 (atribute -> visibility atributemodifier type ID EQUAL expression SEMICOLON .)


state 190

    (25) sigparams -> type ID .
    (26) sigparams -> type ID . COMMA sigparams

    RPAREN          reduce using rule 25 (sigparams -> type ID .)
    COMMA           shift and go to state 203


state 191

    (23) signature -> visibility atributemodifier type ID LPAREN sigparams RPAREN .

    LCHAV           reduce using rule 23 (signature -> visibility atributemodifier type ID LPAREN sigparams RPAREN .)


state 192

    (24) signature -> visibility atributemodifier type brackets_expression ID LPAREN sigparams . RPAREN

    RPAREN          shift and go to state 204


state 193

    (31) stm -> WHILE LPAREN expression RPAREN bodyorstm .

    WHILE           reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    DO              reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    FOR             reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    IF              reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    SEMICOLON       reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    RETURN          reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    FLOAT_NUMBER    reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    DOUBLE_NUMBER   reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    INT_NUMBER      reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    STRING          reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    ID              reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    NEW             reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    STATIC          reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    FINAL           reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    INCREMENT       reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    DECREMENT       reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    MINUS           reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    PLUS            reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    NOT             reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    TYPE_INT        reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    TYPE_FLOAT      reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    TYPE_DOUBLE     reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    TYPE_BYTE       reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    TYPE_BOOLEAN    reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    TYPE_CHAR       reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    TYPE_STRING     reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    TYPE_LONG       reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    TYPE_VOID       reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    RCHAV           reduce using rule 31 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)


state 194

    (32) stm -> DO bodyorstm WHILE LPAREN expression . RPAREN SEMICOLON
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    RPAREN          shift and go to state 205
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

    operatorbittobit               shift and go to state 93

state 195

    (33) stm -> FOR LPAREN expression_for SEMICOLON expression . SEMICOLON expression RPAREN bodyorstm
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       shift and go to state 206
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

    operatorbittobit               shift and go to state 93

state 196

    (43) expression_for -> type ID EQUAL . expression
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 207
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 197

    (44) expression_for -> ID EQUAL expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 44 (expression_for -> ID EQUAL expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

    operatorbittobit               shift and go to state 93

state 198

    (34) stm -> IF LPAREN expression RPAREN bodyorstm .
    (35) stm -> IF LPAREN expression RPAREN bodyorstm . ELSE bodyorstm
    (36) stm -> IF LPAREN expression RPAREN bodyorstm . ELSE IF bodyorstm

    WHILE           reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    DO              reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    FOR             reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    IF              reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    SEMICOLON       reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    RETURN          reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    FLOAT_NUMBER    reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    DOUBLE_NUMBER   reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    INT_NUMBER      reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    STRING          reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    ID              reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    NEW             reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    STATIC          reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    FINAL           reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    INCREMENT       reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    DECREMENT       reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    MINUS           reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    PLUS            reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    NOT             reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    TYPE_INT        reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    TYPE_FLOAT      reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    TYPE_DOUBLE     reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    TYPE_BYTE       reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    TYPE_BOOLEAN    reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    TYPE_CHAR       reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    TYPE_STRING     reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    TYPE_LONG       reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    TYPE_VOID       reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    RCHAV           reduce using rule 34 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    ELSE            shift and go to state 208


state 199

    (39) stm -> atributemodifier type ID EQUAL expression . SEMICOLON
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       shift and go to state 209
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

    operatorbittobit               shift and go to state 93

state 200

    (110) params_call -> expression COMMA params_call .

    RPAREN          reduce using rule 110 (params_call -> expression COMMA params_call .)


state 201

    (52) expression -> NEW type LPAREN params_call RPAREN .

    SEMICOLON       reduce using rule 52 (expression -> NEW type LPAREN params_call RPAREN .)
    TIMES           reduce using rule 52 (expression -> NEW type LPAREN params_call RPAREN .)
    DIVIDE          reduce using rule 52 (expression -> NEW type LPAREN params_call RPAREN .)
    MODULE          reduce using rule 52 (expression -> NEW type LPAREN params_call RPAREN .)
    PLUS            reduce using rule 52 (expression -> NEW type LPAREN params_call RPAREN .)
    MINUS           reduce using rule 52 (expression -> NEW type LPAREN params_call RPAREN .)
    LEQ             reduce using rule 52 (expression -> NEW type LPAREN params_call RPAREN .)
    GEQ             reduce using rule 52 (expression -> NEW type LPAREN params_call RPAREN .)
    LT              reduce using rule 52 (expression -> NEW type LPAREN params_call RPAREN .)
    GT              reduce using rule 52 (expression -> NEW type LPAREN params_call RPAREN .)
    NEQ             reduce using rule 52 (expression -> NEW type LPAREN params_call RPAREN .)
    EQ              reduce using rule 52 (expression -> NEW type LPAREN params_call RPAREN .)
    AND             reduce using rule 52 (expression -> NEW type LPAREN params_call RPAREN .)
    OR              reduce using rule 52 (expression -> NEW type LPAREN params_call RPAREN .)
    BITWISE_AND     reduce using rule 52 (expression -> NEW type LPAREN params_call RPAREN .)
    BITWISE_OR      reduce using rule 52 (expression -> NEW type LPAREN params_call RPAREN .)
    BITWISE_XOR     reduce using rule 52 (expression -> NEW type LPAREN params_call RPAREN .)
    URSHIFT         reduce using rule 52 (expression -> NEW type LPAREN params_call RPAREN .)
    LSHIFT          reduce using rule 52 (expression -> NEW type LPAREN params_call RPAREN .)
    RSHIFT          reduce using rule 52 (expression -> NEW type LPAREN params_call RPAREN .)
    RPAREN          reduce using rule 52 (expression -> NEW type LPAREN params_call RPAREN .)
    COMMA           reduce using rule 52 (expression -> NEW type LPAREN params_call RPAREN .)
    RBRACKET        reduce using rule 52 (expression -> NEW type LPAREN params_call RPAREN .)


state 202

    (53) expression -> NEW type LBRACKET expression RBRACKET .

    SEMICOLON       reduce using rule 53 (expression -> NEW type LBRACKET expression RBRACKET .)
    TIMES           reduce using rule 53 (expression -> NEW type LBRACKET expression RBRACKET .)
    DIVIDE          reduce using rule 53 (expression -> NEW type LBRACKET expression RBRACKET .)
    MODULE          reduce using rule 53 (expression -> NEW type LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 53 (expression -> NEW type LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 53 (expression -> NEW type LBRACKET expression RBRACKET .)
    LEQ             reduce using rule 53 (expression -> NEW type LBRACKET expression RBRACKET .)
    GEQ             reduce using rule 53 (expression -> NEW type LBRACKET expression RBRACKET .)
    LT              reduce using rule 53 (expression -> NEW type LBRACKET expression RBRACKET .)
    GT              reduce using rule 53 (expression -> NEW type LBRACKET expression RBRACKET .)
    NEQ             reduce using rule 53 (expression -> NEW type LBRACKET expression RBRACKET .)
    EQ              reduce using rule 53 (expression -> NEW type LBRACKET expression RBRACKET .)
    AND             reduce using rule 53 (expression -> NEW type LBRACKET expression RBRACKET .)
    OR              reduce using rule 53 (expression -> NEW type LBRACKET expression RBRACKET .)
    BITWISE_AND     reduce using rule 53 (expression -> NEW type LBRACKET expression RBRACKET .)
    BITWISE_OR      reduce using rule 53 (expression -> NEW type LBRACKET expression RBRACKET .)
    BITWISE_XOR     reduce using rule 53 (expression -> NEW type LBRACKET expression RBRACKET .)
    URSHIFT         reduce using rule 53 (expression -> NEW type LBRACKET expression RBRACKET .)
    LSHIFT          reduce using rule 53 (expression -> NEW type LBRACKET expression RBRACKET .)
    RSHIFT          reduce using rule 53 (expression -> NEW type LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 53 (expression -> NEW type LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 53 (expression -> NEW type LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 53 (expression -> NEW type LBRACKET expression RBRACKET .)


state 203

    (26) sigparams -> type ID COMMA . sigparams
    (25) sigparams -> . type ID
    (26) sigparams -> . type ID COMMA sigparams
    (98) type -> . primitivetypes
    (99) primitivetypes -> . TYPE_INT
    (100) primitivetypes -> . TYPE_FLOAT
    (101) primitivetypes -> . TYPE_DOUBLE
    (102) primitivetypes -> . TYPE_BYTE
    (103) primitivetypes -> . TYPE_BOOLEAN
    (104) primitivetypes -> . TYPE_CHAR
    (105) primitivetypes -> . TYPE_STRING
    (106) primitivetypes -> . TYPE_LONG
    (107) primitivetypes -> . TYPE_VOID

    TYPE_INT        shift and go to state 36
    TYPE_FLOAT      shift and go to state 37
    TYPE_DOUBLE     shift and go to state 38
    TYPE_BYTE       shift and go to state 39
    TYPE_BOOLEAN    shift and go to state 40
    TYPE_CHAR       shift and go to state 41
    TYPE_STRING     shift and go to state 42
    TYPE_LONG       shift and go to state 43
    TYPE_VOID       shift and go to state 44

    type                           shift and go to state 172
    sigparams                      shift and go to state 210
    primitivetypes                 shift and go to state 35

state 204

    (24) signature -> visibility atributemodifier type brackets_expression ID LPAREN sigparams RPAREN .

    LCHAV           reduce using rule 24 (signature -> visibility atributemodifier type brackets_expression ID LPAREN sigparams RPAREN .)


state 205

    (32) stm -> DO bodyorstm WHILE LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 211


state 206

    (33) stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON . expression RPAREN bodyorstm
    (45) expression -> . operator
    (46) expression -> . call
    (47) expression -> . FLOAT_NUMBER
    (48) expression -> . DOUBLE_NUMBER
    (49) expression -> . INT_NUMBER
    (50) expression -> . STRING
    (51) expression -> . ID
    (52) expression -> . NEW type LPAREN params_call RPAREN
    (53) expression -> . NEW type LBRACKET expression RBRACKET
    (54) operator -> . expression TIMES expression
    (55) operator -> . expression DIVIDE expression
    (56) operator -> . expression MODULE expression
    (57) operator -> . expression PLUS expression
    (58) operator -> . expression MINUS expression
    (59) operator -> . ID EQUAL expression
    (60) operator -> . ID MINUS_EQ expression
    (61) operator -> . ID TIMES_EQ expression
    (62) operator -> . ID PLUS_EQ expression
    (63) operator -> . ID DIVIDE_EQ expression
    (64) operator -> . ID MOD_EQ expression
    (65) operator -> . ID BITWISE_AND_EQ expression
    (66) operator -> . ID BITWISE_OR_EQ expression
    (67) operator -> . ID BITWISE_XOR_EQ expression
    (68) operator -> . ID URSHIFT_EQ expression
    (69) operator -> . ID LSHIFT_EQ expression
    (70) operator -> . ID RSHIFT_EQ expression
    (71) operator -> . expression LEQ expression
    (72) operator -> . expression GEQ expression
    (73) operator -> . expression LT expression
    (74) operator -> . expression GT expression
    (75) operator -> . expression NEQ expression
    (76) operator -> . expression EQ expression
    (77) operator -> . expression AND expression
    (78) operator -> . expression OR expression
    (79) operator -> . expression BITWISE_AND expression
    (80) operator -> . expression BITWISE_OR expression
    (81) operator -> . expression BITWISE_XOR expression
    (82) operator -> . unaryoperatorprefx ID
    (83) operator -> . ID unaryoperatorsufx
    (84) operator -> . expression operatorbittobit
    (108) call -> . ID LPAREN params_call RPAREN
    (109) call -> . ID LPAREN RPAREN
    (85) unaryoperatorprefx -> . INCREMENT
    (86) unaryoperatorprefx -> . DECREMENT
    (87) unaryoperatorprefx -> . MINUS
    (88) unaryoperatorprefx -> . PLUS
    (89) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 58
    DOUBLE_NUMBER   shift and go to state 59
    INT_NUMBER      shift and go to state 60
    STRING          shift and go to state 61
    ID              shift and go to state 54
    NEW             shift and go to state 62
    INCREMENT       shift and go to state 66
    DECREMENT       shift and go to state 67
    MINUS           shift and go to state 64
    PLUS            shift and go to state 63
    NOT             shift and go to state 68

    expression                     shift and go to state 212
    operator                       shift and go to state 56
    call                           shift and go to state 57
    unaryoperatorprefx             shift and go to state 65

state 207

    (43) expression_for -> type ID EQUAL expression .
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    SEMICOLON       reduce using rule 43 (expression_for -> type ID EQUAL expression .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

    operatorbittobit               shift and go to state 93

state 208

    (35) stm -> IF LPAREN expression RPAREN bodyorstm ELSE . bodyorstm
    (36) stm -> IF LPAREN expression RPAREN bodyorstm ELSE . IF bodyorstm
    (42) bodyorstm -> . body
    (27) body -> . LCHAV stms RCHAV

    IF              shift and go to state 213
    LCHAV           shift and go to state 31

    bodyorstm                      shift and go to state 214
    body                           shift and go to state 99

state 209

    (39) stm -> atributemodifier type ID EQUAL expression SEMICOLON .

    WHILE           reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    DO              reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    FOR             reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    IF              reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    SEMICOLON       reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    RETURN          reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    INT_NUMBER      reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    STRING          reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    ID              reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    NEW             reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    STATIC          reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    FINAL           reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    INCREMENT       reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    DECREMENT       reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    MINUS           reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    PLUS            reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    NOT             reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_INT        reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_FLOAT      reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_BYTE       reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_STRING     reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_LONG       reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    TYPE_VOID       reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)
    RCHAV           reduce using rule 39 (stm -> atributemodifier type ID EQUAL expression SEMICOLON .)


state 210

    (26) sigparams -> type ID COMMA sigparams .

    RPAREN          reduce using rule 26 (sigparams -> type ID COMMA sigparams .)


state 211

    (32) stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .

    WHILE           reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    DO              reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    FOR             reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    IF              reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    RETURN          reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    DOUBLE_NUMBER   reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    INT_NUMBER      reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    STRING          reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    ID              reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    NEW             reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    STATIC          reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    FINAL           reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    DECREMENT       reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    MINUS           reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    PLUS            reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    NOT             reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    TYPE_INT        reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    TYPE_FLOAT      reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    TYPE_BYTE       reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    TYPE_BOOLEAN    reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    TYPE_CHAR       reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    TYPE_STRING     reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    TYPE_LONG       reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    TYPE_VOID       reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    RCHAV           reduce using rule 32 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)


state 212

    (33) stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression . RPAREN bodyorstm
    (54) operator -> expression . TIMES expression
    (55) operator -> expression . DIVIDE expression
    (56) operator -> expression . MODULE expression
    (57) operator -> expression . PLUS expression
    (58) operator -> expression . MINUS expression
    (71) operator -> expression . LEQ expression
    (72) operator -> expression . GEQ expression
    (73) operator -> expression . LT expression
    (74) operator -> expression . GT expression
    (75) operator -> expression . NEQ expression
    (76) operator -> expression . EQ expression
    (77) operator -> expression . AND expression
    (78) operator -> expression . OR expression
    (79) operator -> expression . BITWISE_AND expression
    (80) operator -> expression . BITWISE_OR expression
    (81) operator -> expression . BITWISE_XOR expression
    (84) operator -> expression . operatorbittobit
    (92) operatorbittobit -> . URSHIFT
    (93) operatorbittobit -> . LSHIFT
    (94) operatorbittobit -> . RSHIFT

    RPAREN          shift and go to state 215
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    MODULE          shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    LEQ             shift and go to state 82
    GEQ             shift and go to state 83
    LT              shift and go to state 84
    GT              shift and go to state 85
    NEQ             shift and go to state 86
    EQ              shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BITWISE_AND     shift and go to state 90
    BITWISE_OR      shift and go to state 91
    BITWISE_XOR     shift and go to state 92
    URSHIFT         shift and go to state 94
    LSHIFT          shift and go to state 95
    RSHIFT          shift and go to state 96

    operatorbittobit               shift and go to state 93

state 213

    (36) stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF . bodyorstm
    (42) bodyorstm -> . body
    (27) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 31

    bodyorstm                      shift and go to state 216
    body                           shift and go to state 99

state 214

    (35) stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .

    WHILE           reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    DO              reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    FOR             reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    IF              reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    SEMICOLON       reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    RETURN          reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    FLOAT_NUMBER    reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    DOUBLE_NUMBER   reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    INT_NUMBER      reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    STRING          reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    ID              reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    NEW             reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    STATIC          reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    FINAL           reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    INCREMENT       reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    DECREMENT       reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    MINUS           reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    PLUS            reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    NOT             reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    TYPE_INT        reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    TYPE_FLOAT      reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    TYPE_DOUBLE     reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    TYPE_BYTE       reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    TYPE_BOOLEAN    reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    TYPE_CHAR       reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    TYPE_STRING     reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    TYPE_LONG       reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    TYPE_VOID       reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    RCHAV           reduce using rule 35 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)


state 215

    (33) stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN . bodyorstm
    (42) bodyorstm -> . body
    (27) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 31

    bodyorstm                      shift and go to state 217
    body                           shift and go to state 99

state 216

    (36) stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .

    WHILE           reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    DO              reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    FOR             reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    IF              reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    SEMICOLON       reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    RETURN          reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    FLOAT_NUMBER    reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    DOUBLE_NUMBER   reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    INT_NUMBER      reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    STRING          reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    ID              reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    NEW             reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    STATIC          reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    FINAL           reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    INCREMENT       reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    DECREMENT       reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    MINUS           reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    PLUS            reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    NOT             reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    TYPE_INT        reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    TYPE_FLOAT      reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    TYPE_DOUBLE     reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    TYPE_BYTE       reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    TYPE_BOOLEAN    reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    TYPE_CHAR       reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    TYPE_STRING     reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    TYPE_LONG       reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    TYPE_VOID       reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    RCHAV           reduce using rule 36 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)


state 217

    (33) stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .

    WHILE           reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    DO              reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    FOR             reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    IF              reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    SEMICOLON       reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    RETURN          reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    FLOAT_NUMBER    reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    DOUBLE_NUMBER   reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    INT_NUMBER      reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    STRING          reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    ID              reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    NEW             reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    STATIC          reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    FINAL           reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    INCREMENT       reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    DECREMENT       reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    MINUS           reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    PLUS            reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    NOT             reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    TYPE_INT        reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    TYPE_FLOAT      reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    TYPE_DOUBLE     reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    TYPE_BYTE       reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    TYPE_BOOLEAN    reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    TYPE_CHAR       reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    TYPE_STRING     reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    TYPE_LONG       reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    TYPE_VOID       reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)
    RCHAV           reduce using rule 33 (stm -> FOR LPAREN expression_for SEMICOLON expression SEMICOLON expression RPAREN bodyorstm .)

