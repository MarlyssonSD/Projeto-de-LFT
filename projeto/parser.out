Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ASSERT
    BIN_NUMBER
    BITWISE_NOT
    BOOLEAN
    BREAK
    BYTE
    CASE
    CATCH
    CHAR
    CONST
    CONTINUE
    DEFAULT
    DOT
    DOUBLE_NUMBER
    ENUM
    FINALLY
    GOTO
    HEXA_NUMBER
    IMPORT
    INSTANCEOF
    INTERFACE
    LBRACKET
    LONG
    MULTICOMMENT
    NATIVE
    NEW
    OCTAL_NUMBER
    PACKAGE
    POT
    RBRACKET
    RETURN
    SHORT
    STRICTFP
    SUPER
    SWITCH
    SYNCHRONIZED
    TERNARY
    THIS
    THROW
    THROWS
    TRANSIENT
    TRY
    UNICOMMENT
    VOID
    VOLATILE

Grammar

Rule 0     S' -> program
Rule 1     program -> class
Rule 2     class -> visibility classmodifier CLASS ID EXTENDS ID LCHAV membros RCHAV
Rule 3     class -> visibility classmodifier CLASS ID LCHAV membros RCHAV
Rule 4     class -> visibility classmodifier CLASS ID IMPLEMENTS LCHAV membros RCHAV
Rule 5     visibility -> PUBLIC
Rule 6     visibility -> PRIVATE
Rule 7     visibility -> PROTECTED
Rule 8     visibility -> <empty>
Rule 9     classmodifier -> <empty>
Rule 10    classmodifier -> ABSTRACT
Rule 11    classmodifier -> FINAL
Rule 12    membros -> membro
Rule 13    membros -> membro membros
Rule 14    membro -> atribute
Rule 15    membro -> function
Rule 16    atribute -> visibility atributemodifier ID
Rule 17    atributemodifier -> <empty>
Rule 18    atributemodifier -> STATIC
Rule 19    atributemodifier -> FINAL
Rule 20    function -> signature body
Rule 21    signature -> visibility ID ID LPAREN sigparams RPAREN
Rule 22    sigparams -> ID
Rule 23    sigparams -> ID COMMA sigparams
Rule 24    body -> LCHAV stms RCHAV
Rule 25    stms -> stm
Rule 26    stms -> stm stms
Rule 27    stm -> expression SEMICOLON
Rule 28    stm -> WHILE LPAREN expression RPAREN bodyorstm
Rule 29    stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON
Rule 30    stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm
Rule 31    stm -> IF LPAREN expression RPAREN bodyorstm
Rule 32    stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm
Rule 33    stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm
Rule 34    stm -> SEMICOLON
Rule 35    bodyorstm -> body
Rule 36    expression -> operator
Rule 37    expression -> call
Rule 38    expression -> FLOAT_NUMBER
Rule 39    expression -> INT_NUMBER
Rule 40    expression -> STRING
Rule 41    expression -> ID
Rule 42    operator -> expression arithmetic expression
Rule 43    operator -> ID assign expression
Rule 44    operator -> expression operatorcomparator expression
Rule 45    operator -> unaryoperatorprefx ID
Rule 46    operator -> ID unaryoperatorsufx
Rule 47    operator -> expression operatorbittobit
Rule 48    arithmetic -> TIMES
Rule 49    arithmetic -> DIVIDE
Rule 50    arithmetic -> MODULE
Rule 51    arithmetic -> PLUS
Rule 52    arithmetic -> MINUS
Rule 53    assign -> EQUAL
Rule 54    assign -> PLUS_EQ
Rule 55    assign -> MINUS_EQ
Rule 56    assign -> TIMES_EQ
Rule 57    assign -> DIVIDE_EQ
Rule 58    assign -> MOD_EQ
Rule 59    assign -> BITWISE_AND_EQ
Rule 60    assign -> BITWISE_OR_EQ
Rule 61    assign -> BITWISE_XOR_EQ
Rule 62    assign -> URSHIFT_EQ
Rule 63    assign -> LSHIFT_EQ
Rule 64    assign -> RSHIFT_EQ
Rule 65    operatorcomparator -> LEQ
Rule 66    operatorcomparator -> GEQ
Rule 67    operatorcomparator -> LT
Rule 68    operatorcomparator -> GT
Rule 69    operatorcomparator -> NEQ
Rule 70    operatorcomparator -> EQ
Rule 71    operatorcomparator -> AND
Rule 72    operatorcomparator -> OR
Rule 73    operatorcomparator -> BITWISE_AND
Rule 74    operatorcomparator -> BITWISE_OR
Rule 75    operatorcomparator -> BITWISE_XOR
Rule 76    unaryoperatorprefx -> INCREMENT
Rule 77    unaryoperatorprefx -> DECREMENT
Rule 78    unaryoperatorprefx -> MINUS_EQ
Rule 79    unaryoperatorprefx -> PLUS
Rule 80    unaryoperatorprefx -> NOT
Rule 81    unaryoperatorsufx -> INCREMENT
Rule 82    unaryoperatorsufx -> DECREMENT
Rule 83    operatorbittobit -> URSHIFT
Rule 84    operatorbittobit -> LSHIFT
Rule 85    operatorbittobit -> RSHIFT
Rule 86    call -> ID LPAREN params RPAREN
Rule 87    call -> ID LPAREN RPAREN
Rule 88    params -> expression COMMA params
Rule 89    params -> expression

Terminals, with rules where they appear

ABSTRACT             : 10
AND                  : 71
ASSERT               : 
BIN_NUMBER           : 
BITWISE_AND          : 73
BITWISE_AND_EQ       : 59
BITWISE_NOT          : 
BITWISE_OR           : 74
BITWISE_OR_EQ        : 60
BITWISE_XOR          : 75
BITWISE_XOR_EQ       : 61
BOOLEAN              : 
BREAK                : 
BYTE                 : 
CASE                 : 
CATCH                : 
CHAR                 : 
CLASS                : 2 3 4
COMMA                : 23 88
CONST                : 
CONTINUE             : 
DECREMENT            : 77 82
DEFAULT              : 
DIVIDE               : 49
DIVIDE_EQ            : 57
DO                   : 29
DOT                  : 
DOUBLE_NUMBER        : 
ELSE                 : 32 33
ENUM                 : 
EQ                   : 70
EQUAL                : 53
EXTENDS              : 2
FINAL                : 11 19
FINALLY              : 
FLOAT_NUMBER         : 38
FOR                  : 30
GEQ                  : 66
GOTO                 : 
GT                   : 68
HEXA_NUMBER          : 
ID                   : 2 2 3 4 16 21 21 22 23 41 43 45 46 86 87
IF                   : 31 32 33 33
IMPLEMENTS           : 4
IMPORT               : 
INCREMENT            : 76 81
INSTANCEOF           : 
INTERFACE            : 
INT_NUMBER           : 39
LBRACKET             : 
LCHAV                : 2 3 4 24
LEQ                  : 65
LONG                 : 
LPAREN               : 21 28 29 30 31 32 33 86 87
LSHIFT               : 84
LSHIFT_EQ            : 63
LT                   : 67
MINUS                : 52
MINUS_EQ             : 55 78
MODULE               : 50
MOD_EQ               : 58
MULTICOMMENT         : 
NATIVE               : 
NEQ                  : 69
NEW                  : 
NOT                  : 80
OCTAL_NUMBER         : 
OR                   : 72
PACKAGE              : 
PLUS                 : 51 79
PLUS_EQ              : 54
POT                  : 
PRIVATE              : 6
PROTECTED            : 7
PUBLIC               : 5
RBRACKET             : 
RCHAV                : 2 3 4 24
RETURN               : 
RPAREN               : 21 28 29 30 31 32 33 86 87
RSHIFT               : 85
RSHIFT_EQ            : 64
SEMICOLON            : 27 29 30 30 30 34
SHORT                : 
STATIC               : 18
STRICTFP             : 
STRING               : 40
SUPER                : 
SWITCH               : 
SYNCHRONIZED         : 
TERNARY              : 
THIS                 : 
THROW                : 
THROWS               : 
TIMES                : 48
TIMES_EQ             : 56
TRANSIENT            : 
TRY                  : 
UNICOMMENT           : 
URSHIFT              : 83
URSHIFT_EQ           : 62
VOID                 : 
VOLATILE             : 
WHILE                : 28 29
error                : 

Nonterminals, with rules where they appear

arithmetic           : 42
assign               : 43
atribute             : 14
atributemodifier     : 16
body                 : 20 35
bodyorstm            : 28 29 30 31 32 32 33 33
call                 : 37
class                : 1
classmodifier        : 2 3 4
expression           : 27 28 29 30 30 30 31 32 33 42 42 43 44 44 47 88 89
function             : 15
membro               : 12 13
membros              : 2 3 4 13
operator             : 36
operatorbittobit     : 47
operatorcomparator   : 44
params               : 86 88
program              : 0
signature            : 20
sigparams            : 21 23
stm                  : 25 26
stms                 : 24 26
unaryoperatorprefx   : 45
unaryoperatorsufx    : 46
visibility           : 2 3 4 16 21

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . class
    (2) class -> . visibility classmodifier CLASS ID EXTENDS ID LCHAV membros RCHAV
    (3) class -> . visibility classmodifier CLASS ID LCHAV membros RCHAV
    (4) class -> . visibility classmodifier CLASS ID IMPLEMENTS LCHAV membros RCHAV
    (5) visibility -> . PUBLIC
    (6) visibility -> . PRIVATE
    (7) visibility -> . PROTECTED
    (8) visibility -> .

    PUBLIC          shift and go to state 4
    PRIVATE         shift and go to state 5
    PROTECTED       shift and go to state 6
    ABSTRACT        reduce using rule 8 (visibility -> .)
    FINAL           reduce using rule 8 (visibility -> .)
    CLASS           reduce using rule 8 (visibility -> .)

    program                        shift and go to state 1
    class                          shift and go to state 2
    visibility                     shift and go to state 3

state 1

    (0) S' -> program .



state 2

    (1) program -> class .

    $end            reduce using rule 1 (program -> class .)


state 3

    (2) class -> visibility . classmodifier CLASS ID EXTENDS ID LCHAV membros RCHAV
    (3) class -> visibility . classmodifier CLASS ID LCHAV membros RCHAV
    (4) class -> visibility . classmodifier CLASS ID IMPLEMENTS LCHAV membros RCHAV
    (9) classmodifier -> .
    (10) classmodifier -> . ABSTRACT
    (11) classmodifier -> . FINAL

    CLASS           reduce using rule 9 (classmodifier -> .)
    ABSTRACT        shift and go to state 8
    FINAL           shift and go to state 9

    classmodifier                  shift and go to state 7

state 4

    (5) visibility -> PUBLIC .

    ABSTRACT        reduce using rule 5 (visibility -> PUBLIC .)
    FINAL           reduce using rule 5 (visibility -> PUBLIC .)
    CLASS           reduce using rule 5 (visibility -> PUBLIC .)
    ID              reduce using rule 5 (visibility -> PUBLIC .)
    STATIC          reduce using rule 5 (visibility -> PUBLIC .)


state 5

    (6) visibility -> PRIVATE .

    ABSTRACT        reduce using rule 6 (visibility -> PRIVATE .)
    FINAL           reduce using rule 6 (visibility -> PRIVATE .)
    CLASS           reduce using rule 6 (visibility -> PRIVATE .)
    ID              reduce using rule 6 (visibility -> PRIVATE .)
    STATIC          reduce using rule 6 (visibility -> PRIVATE .)


state 6

    (7) visibility -> PROTECTED .

    ABSTRACT        reduce using rule 7 (visibility -> PROTECTED .)
    FINAL           reduce using rule 7 (visibility -> PROTECTED .)
    CLASS           reduce using rule 7 (visibility -> PROTECTED .)
    ID              reduce using rule 7 (visibility -> PROTECTED .)
    STATIC          reduce using rule 7 (visibility -> PROTECTED .)


state 7

    (2) class -> visibility classmodifier . CLASS ID EXTENDS ID LCHAV membros RCHAV
    (3) class -> visibility classmodifier . CLASS ID LCHAV membros RCHAV
    (4) class -> visibility classmodifier . CLASS ID IMPLEMENTS LCHAV membros RCHAV

    CLASS           shift and go to state 10


state 8

    (10) classmodifier -> ABSTRACT .

    CLASS           reduce using rule 10 (classmodifier -> ABSTRACT .)


state 9

    (11) classmodifier -> FINAL .

    CLASS           reduce using rule 11 (classmodifier -> FINAL .)


state 10

    (2) class -> visibility classmodifier CLASS . ID EXTENDS ID LCHAV membros RCHAV
    (3) class -> visibility classmodifier CLASS . ID LCHAV membros RCHAV
    (4) class -> visibility classmodifier CLASS . ID IMPLEMENTS LCHAV membros RCHAV

    ID              shift and go to state 11


state 11

    (2) class -> visibility classmodifier CLASS ID . EXTENDS ID LCHAV membros RCHAV
    (3) class -> visibility classmodifier CLASS ID . LCHAV membros RCHAV
    (4) class -> visibility classmodifier CLASS ID . IMPLEMENTS LCHAV membros RCHAV

    EXTENDS         shift and go to state 12
    LCHAV           shift and go to state 13
    IMPLEMENTS      shift and go to state 14


state 12

    (2) class -> visibility classmodifier CLASS ID EXTENDS . ID LCHAV membros RCHAV

    ID              shift and go to state 15


state 13

    (3) class -> visibility classmodifier CLASS ID LCHAV . membros RCHAV
    (12) membros -> . membro
    (13) membros -> . membro membros
    (14) membro -> . atribute
    (15) membro -> . function
    (16) atribute -> . visibility atributemodifier ID
    (20) function -> . signature body
    (5) visibility -> . PUBLIC
    (6) visibility -> . PRIVATE
    (7) visibility -> . PROTECTED
    (8) visibility -> .
    (21) signature -> . visibility ID ID LPAREN sigparams RPAREN

    PUBLIC          shift and go to state 4
    PRIVATE         shift and go to state 5
    PROTECTED       shift and go to state 6
    ID              reduce using rule 8 (visibility -> .)
    STATIC          reduce using rule 8 (visibility -> .)
    FINAL           reduce using rule 8 (visibility -> .)

    visibility                     shift and go to state 16
    membros                        shift and go to state 17
    membro                         shift and go to state 18
    atribute                       shift and go to state 19
    function                       shift and go to state 20
    signature                      shift and go to state 21

state 14

    (4) class -> visibility classmodifier CLASS ID IMPLEMENTS . LCHAV membros RCHAV

    LCHAV           shift and go to state 22


state 15

    (2) class -> visibility classmodifier CLASS ID EXTENDS ID . LCHAV membros RCHAV

    LCHAV           shift and go to state 23


state 16

    (16) atribute -> visibility . atributemodifier ID
    (21) signature -> visibility . ID ID LPAREN sigparams RPAREN
    (17) atributemodifier -> .
    (18) atributemodifier -> . STATIC
    (19) atributemodifier -> . FINAL

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 25
    STATIC          shift and go to state 26
    FINAL           shift and go to state 27

  ! ID              [ reduce using rule 17 (atributemodifier -> .) ]

    atributemodifier               shift and go to state 24

state 17

    (3) class -> visibility classmodifier CLASS ID LCHAV membros . RCHAV

    RCHAV           shift and go to state 28


state 18

    (12) membros -> membro .
    (13) membros -> membro . membros
    (12) membros -> . membro
    (13) membros -> . membro membros
    (14) membro -> . atribute
    (15) membro -> . function
    (16) atribute -> . visibility atributemodifier ID
    (20) function -> . signature body
    (5) visibility -> . PUBLIC
    (6) visibility -> . PRIVATE
    (7) visibility -> . PROTECTED
    (8) visibility -> .
    (21) signature -> . visibility ID ID LPAREN sigparams RPAREN

    RCHAV           reduce using rule 12 (membros -> membro .)
    PUBLIC          shift and go to state 4
    PRIVATE         shift and go to state 5
    PROTECTED       shift and go to state 6
    ID              reduce using rule 8 (visibility -> .)
    STATIC          reduce using rule 8 (visibility -> .)
    FINAL           reduce using rule 8 (visibility -> .)

    membro                         shift and go to state 18
    membros                        shift and go to state 29
    atribute                       shift and go to state 19
    function                       shift and go to state 20
    visibility                     shift and go to state 16
    signature                      shift and go to state 21

state 19

    (14) membro -> atribute .

    PUBLIC          reduce using rule 14 (membro -> atribute .)
    PRIVATE         reduce using rule 14 (membro -> atribute .)
    PROTECTED       reduce using rule 14 (membro -> atribute .)
    ID              reduce using rule 14 (membro -> atribute .)
    STATIC          reduce using rule 14 (membro -> atribute .)
    FINAL           reduce using rule 14 (membro -> atribute .)
    RCHAV           reduce using rule 14 (membro -> atribute .)


state 20

    (15) membro -> function .

    PUBLIC          reduce using rule 15 (membro -> function .)
    PRIVATE         reduce using rule 15 (membro -> function .)
    PROTECTED       reduce using rule 15 (membro -> function .)
    ID              reduce using rule 15 (membro -> function .)
    STATIC          reduce using rule 15 (membro -> function .)
    FINAL           reduce using rule 15 (membro -> function .)
    RCHAV           reduce using rule 15 (membro -> function .)


state 21

    (20) function -> signature . body
    (24) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 31

    body                           shift and go to state 30

state 22

    (4) class -> visibility classmodifier CLASS ID IMPLEMENTS LCHAV . membros RCHAV
    (12) membros -> . membro
    (13) membros -> . membro membros
    (14) membro -> . atribute
    (15) membro -> . function
    (16) atribute -> . visibility atributemodifier ID
    (20) function -> . signature body
    (5) visibility -> . PUBLIC
    (6) visibility -> . PRIVATE
    (7) visibility -> . PROTECTED
    (8) visibility -> .
    (21) signature -> . visibility ID ID LPAREN sigparams RPAREN

    PUBLIC          shift and go to state 4
    PRIVATE         shift and go to state 5
    PROTECTED       shift and go to state 6
    ID              reduce using rule 8 (visibility -> .)
    STATIC          reduce using rule 8 (visibility -> .)
    FINAL           reduce using rule 8 (visibility -> .)

    visibility                     shift and go to state 16
    membros                        shift and go to state 32
    membro                         shift and go to state 18
    atribute                       shift and go to state 19
    function                       shift and go to state 20
    signature                      shift and go to state 21

state 23

    (2) class -> visibility classmodifier CLASS ID EXTENDS ID LCHAV . membros RCHAV
    (12) membros -> . membro
    (13) membros -> . membro membros
    (14) membro -> . atribute
    (15) membro -> . function
    (16) atribute -> . visibility atributemodifier ID
    (20) function -> . signature body
    (5) visibility -> . PUBLIC
    (6) visibility -> . PRIVATE
    (7) visibility -> . PROTECTED
    (8) visibility -> .
    (21) signature -> . visibility ID ID LPAREN sigparams RPAREN

    PUBLIC          shift and go to state 4
    PRIVATE         shift and go to state 5
    PROTECTED       shift and go to state 6
    ID              reduce using rule 8 (visibility -> .)
    STATIC          reduce using rule 8 (visibility -> .)
    FINAL           reduce using rule 8 (visibility -> .)

    visibility                     shift and go to state 16
    membros                        shift and go to state 33
    membro                         shift and go to state 18
    atribute                       shift and go to state 19
    function                       shift and go to state 20
    signature                      shift and go to state 21

state 24

    (16) atribute -> visibility atributemodifier . ID

    ID              shift and go to state 34


state 25

    (21) signature -> visibility ID . ID LPAREN sigparams RPAREN

    ID              shift and go to state 35


state 26

    (18) atributemodifier -> STATIC .

    ID              reduce using rule 18 (atributemodifier -> STATIC .)


state 27

    (19) atributemodifier -> FINAL .

    ID              reduce using rule 19 (atributemodifier -> FINAL .)


state 28

    (3) class -> visibility classmodifier CLASS ID LCHAV membros RCHAV .

    $end            reduce using rule 3 (class -> visibility classmodifier CLASS ID LCHAV membros RCHAV .)


state 29

    (13) membros -> membro membros .

    RCHAV           reduce using rule 13 (membros -> membro membros .)


state 30

    (20) function -> signature body .

    PUBLIC          reduce using rule 20 (function -> signature body .)
    PRIVATE         reduce using rule 20 (function -> signature body .)
    PROTECTED       reduce using rule 20 (function -> signature body .)
    ID              reduce using rule 20 (function -> signature body .)
    STATIC          reduce using rule 20 (function -> signature body .)
    FINAL           reduce using rule 20 (function -> signature body .)
    RCHAV           reduce using rule 20 (function -> signature body .)


state 31

    (24) body -> LCHAV . stms RCHAV
    (25) stms -> . stm
    (26) stms -> . stm stms
    (27) stm -> . expression SEMICOLON
    (28) stm -> . WHILE LPAREN expression RPAREN bodyorstm
    (29) stm -> . DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON
    (30) stm -> . FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm
    (31) stm -> . IF LPAREN expression RPAREN bodyorstm
    (32) stm -> . IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm
    (33) stm -> . IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm
    (34) stm -> . SEMICOLON
    (36) expression -> . operator
    (37) expression -> . call
    (38) expression -> . FLOAT_NUMBER
    (39) expression -> . INT_NUMBER
    (40) expression -> . STRING
    (41) expression -> . ID
    (42) operator -> . expression arithmetic expression
    (43) operator -> . ID assign expression
    (44) operator -> . expression operatorcomparator expression
    (45) operator -> . unaryoperatorprefx ID
    (46) operator -> . ID unaryoperatorsufx
    (47) operator -> . expression operatorbittobit
    (86) call -> . ID LPAREN params RPAREN
    (87) call -> . ID LPAREN RPAREN
    (76) unaryoperatorprefx -> . INCREMENT
    (77) unaryoperatorprefx -> . DECREMENT
    (78) unaryoperatorprefx -> . MINUS_EQ
    (79) unaryoperatorprefx -> . PLUS
    (80) unaryoperatorprefx -> . NOT

    WHILE           shift and go to state 40
    DO              shift and go to state 41
    FOR             shift and go to state 42
    IF              shift and go to state 43
    SEMICOLON       shift and go to state 39
    FLOAT_NUMBER    shift and go to state 46
    INT_NUMBER      shift and go to state 47
    STRING          shift and go to state 48
    ID              shift and go to state 49
    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52
    MINUS_EQ        shift and go to state 53
    PLUS            shift and go to state 54
    NOT             shift and go to state 55

    stms                           shift and go to state 36
    stm                            shift and go to state 37
    expression                     shift and go to state 38
    operator                       shift and go to state 44
    call                           shift and go to state 45
    unaryoperatorprefx             shift and go to state 50

state 32

    (4) class -> visibility classmodifier CLASS ID IMPLEMENTS LCHAV membros . RCHAV

    RCHAV           shift and go to state 56


state 33

    (2) class -> visibility classmodifier CLASS ID EXTENDS ID LCHAV membros . RCHAV

    RCHAV           shift and go to state 57


state 34

    (16) atribute -> visibility atributemodifier ID .

    PUBLIC          reduce using rule 16 (atribute -> visibility atributemodifier ID .)
    PRIVATE         reduce using rule 16 (atribute -> visibility atributemodifier ID .)
    PROTECTED       reduce using rule 16 (atribute -> visibility atributemodifier ID .)
    ID              reduce using rule 16 (atribute -> visibility atributemodifier ID .)
    STATIC          reduce using rule 16 (atribute -> visibility atributemodifier ID .)
    FINAL           reduce using rule 16 (atribute -> visibility atributemodifier ID .)
    RCHAV           reduce using rule 16 (atribute -> visibility atributemodifier ID .)


state 35

    (21) signature -> visibility ID ID . LPAREN sigparams RPAREN

    LPAREN          shift and go to state 58


state 36

    (24) body -> LCHAV stms . RCHAV

    RCHAV           shift and go to state 59


state 37

    (25) stms -> stm .
    (26) stms -> stm . stms
    (25) stms -> . stm
    (26) stms -> . stm stms
    (27) stm -> . expression SEMICOLON
    (28) stm -> . WHILE LPAREN expression RPAREN bodyorstm
    (29) stm -> . DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON
    (30) stm -> . FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm
    (31) stm -> . IF LPAREN expression RPAREN bodyorstm
    (32) stm -> . IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm
    (33) stm -> . IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm
    (34) stm -> . SEMICOLON
    (36) expression -> . operator
    (37) expression -> . call
    (38) expression -> . FLOAT_NUMBER
    (39) expression -> . INT_NUMBER
    (40) expression -> . STRING
    (41) expression -> . ID
    (42) operator -> . expression arithmetic expression
    (43) operator -> . ID assign expression
    (44) operator -> . expression operatorcomparator expression
    (45) operator -> . unaryoperatorprefx ID
    (46) operator -> . ID unaryoperatorsufx
    (47) operator -> . expression operatorbittobit
    (86) call -> . ID LPAREN params RPAREN
    (87) call -> . ID LPAREN RPAREN
    (76) unaryoperatorprefx -> . INCREMENT
    (77) unaryoperatorprefx -> . DECREMENT
    (78) unaryoperatorprefx -> . MINUS_EQ
    (79) unaryoperatorprefx -> . PLUS
    (80) unaryoperatorprefx -> . NOT

    RCHAV           reduce using rule 25 (stms -> stm .)
    WHILE           shift and go to state 40
    DO              shift and go to state 41
    FOR             shift and go to state 42
    IF              shift and go to state 43
    SEMICOLON       shift and go to state 39
    FLOAT_NUMBER    shift and go to state 46
    INT_NUMBER      shift and go to state 47
    STRING          shift and go to state 48
    ID              shift and go to state 49
    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52
    MINUS_EQ        shift and go to state 53
    PLUS            shift and go to state 54
    NOT             shift and go to state 55

    stm                            shift and go to state 37
    stms                           shift and go to state 60
    expression                     shift and go to state 38
    operator                       shift and go to state 44
    call                           shift and go to state 45
    unaryoperatorprefx             shift and go to state 50

state 38

    (27) stm -> expression . SEMICOLON
    (42) operator -> expression . arithmetic expression
    (44) operator -> expression . operatorcomparator expression
    (47) operator -> expression . operatorbittobit
    (48) arithmetic -> . TIMES
    (49) arithmetic -> . DIVIDE
    (50) arithmetic -> . MODULE
    (51) arithmetic -> . PLUS
    (52) arithmetic -> . MINUS
    (65) operatorcomparator -> . LEQ
    (66) operatorcomparator -> . GEQ
    (67) operatorcomparator -> . LT
    (68) operatorcomparator -> . GT
    (69) operatorcomparator -> . NEQ
    (70) operatorcomparator -> . EQ
    (71) operatorcomparator -> . AND
    (72) operatorcomparator -> . OR
    (73) operatorcomparator -> . BITWISE_AND
    (74) operatorcomparator -> . BITWISE_OR
    (75) operatorcomparator -> . BITWISE_XOR
    (83) operatorbittobit -> . URSHIFT
    (84) operatorbittobit -> . LSHIFT
    (85) operatorbittobit -> . RSHIFT

    SEMICOLON       shift and go to state 61
    TIMES           shift and go to state 65
    DIVIDE          shift and go to state 66
    MODULE          shift and go to state 67
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    LEQ             shift and go to state 70
    GEQ             shift and go to state 71
    LT              shift and go to state 72
    GT              shift and go to state 73
    NEQ             shift and go to state 74
    EQ              shift and go to state 75
    AND             shift and go to state 76
    OR              shift and go to state 77
    BITWISE_AND     shift and go to state 78
    BITWISE_OR      shift and go to state 79
    BITWISE_XOR     shift and go to state 80
    URSHIFT         shift and go to state 81
    LSHIFT          shift and go to state 82
    RSHIFT          shift and go to state 83

    arithmetic                     shift and go to state 62
    operatorcomparator             shift and go to state 63
    operatorbittobit               shift and go to state 64

state 39

    (34) stm -> SEMICOLON .

    WHILE           reduce using rule 34 (stm -> SEMICOLON .)
    DO              reduce using rule 34 (stm -> SEMICOLON .)
    FOR             reduce using rule 34 (stm -> SEMICOLON .)
    IF              reduce using rule 34 (stm -> SEMICOLON .)
    SEMICOLON       reduce using rule 34 (stm -> SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 34 (stm -> SEMICOLON .)
    INT_NUMBER      reduce using rule 34 (stm -> SEMICOLON .)
    STRING          reduce using rule 34 (stm -> SEMICOLON .)
    ID              reduce using rule 34 (stm -> SEMICOLON .)
    INCREMENT       reduce using rule 34 (stm -> SEMICOLON .)
    DECREMENT       reduce using rule 34 (stm -> SEMICOLON .)
    MINUS_EQ        reduce using rule 34 (stm -> SEMICOLON .)
    PLUS            reduce using rule 34 (stm -> SEMICOLON .)
    NOT             reduce using rule 34 (stm -> SEMICOLON .)
    RCHAV           reduce using rule 34 (stm -> SEMICOLON .)


state 40

    (28) stm -> WHILE . LPAREN expression RPAREN bodyorstm

    LPAREN          shift and go to state 84


state 41

    (29) stm -> DO . bodyorstm WHILE LPAREN expression RPAREN SEMICOLON
    (35) bodyorstm -> . body
    (24) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 31

    bodyorstm                      shift and go to state 85
    body                           shift and go to state 86

state 42

    (30) stm -> FOR . LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm

    LPAREN          shift and go to state 87


state 43

    (31) stm -> IF . LPAREN expression RPAREN bodyorstm
    (32) stm -> IF . LPAREN expression RPAREN bodyorstm ELSE bodyorstm
    (33) stm -> IF . LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm

    LPAREN          shift and go to state 88


state 44

    (36) expression -> operator .

    SEMICOLON       reduce using rule 36 (expression -> operator .)
    TIMES           reduce using rule 36 (expression -> operator .)
    DIVIDE          reduce using rule 36 (expression -> operator .)
    MODULE          reduce using rule 36 (expression -> operator .)
    PLUS            reduce using rule 36 (expression -> operator .)
    MINUS           reduce using rule 36 (expression -> operator .)
    LEQ             reduce using rule 36 (expression -> operator .)
    GEQ             reduce using rule 36 (expression -> operator .)
    LT              reduce using rule 36 (expression -> operator .)
    GT              reduce using rule 36 (expression -> operator .)
    NEQ             reduce using rule 36 (expression -> operator .)
    EQ              reduce using rule 36 (expression -> operator .)
    AND             reduce using rule 36 (expression -> operator .)
    OR              reduce using rule 36 (expression -> operator .)
    BITWISE_AND     reduce using rule 36 (expression -> operator .)
    BITWISE_OR      reduce using rule 36 (expression -> operator .)
    BITWISE_XOR     reduce using rule 36 (expression -> operator .)
    URSHIFT         reduce using rule 36 (expression -> operator .)
    LSHIFT          reduce using rule 36 (expression -> operator .)
    RSHIFT          reduce using rule 36 (expression -> operator .)
    RPAREN          reduce using rule 36 (expression -> operator .)
    COMMA           reduce using rule 36 (expression -> operator .)


state 45

    (37) expression -> call .

    SEMICOLON       reduce using rule 37 (expression -> call .)
    TIMES           reduce using rule 37 (expression -> call .)
    DIVIDE          reduce using rule 37 (expression -> call .)
    MODULE          reduce using rule 37 (expression -> call .)
    PLUS            reduce using rule 37 (expression -> call .)
    MINUS           reduce using rule 37 (expression -> call .)
    LEQ             reduce using rule 37 (expression -> call .)
    GEQ             reduce using rule 37 (expression -> call .)
    LT              reduce using rule 37 (expression -> call .)
    GT              reduce using rule 37 (expression -> call .)
    NEQ             reduce using rule 37 (expression -> call .)
    EQ              reduce using rule 37 (expression -> call .)
    AND             reduce using rule 37 (expression -> call .)
    OR              reduce using rule 37 (expression -> call .)
    BITWISE_AND     reduce using rule 37 (expression -> call .)
    BITWISE_OR      reduce using rule 37 (expression -> call .)
    BITWISE_XOR     reduce using rule 37 (expression -> call .)
    URSHIFT         reduce using rule 37 (expression -> call .)
    LSHIFT          reduce using rule 37 (expression -> call .)
    RSHIFT          reduce using rule 37 (expression -> call .)
    RPAREN          reduce using rule 37 (expression -> call .)
    COMMA           reduce using rule 37 (expression -> call .)


state 46

    (38) expression -> FLOAT_NUMBER .

    SEMICOLON       reduce using rule 38 (expression -> FLOAT_NUMBER .)
    TIMES           reduce using rule 38 (expression -> FLOAT_NUMBER .)
    DIVIDE          reduce using rule 38 (expression -> FLOAT_NUMBER .)
    MODULE          reduce using rule 38 (expression -> FLOAT_NUMBER .)
    PLUS            reduce using rule 38 (expression -> FLOAT_NUMBER .)
    MINUS           reduce using rule 38 (expression -> FLOAT_NUMBER .)
    LEQ             reduce using rule 38 (expression -> FLOAT_NUMBER .)
    GEQ             reduce using rule 38 (expression -> FLOAT_NUMBER .)
    LT              reduce using rule 38 (expression -> FLOAT_NUMBER .)
    GT              reduce using rule 38 (expression -> FLOAT_NUMBER .)
    NEQ             reduce using rule 38 (expression -> FLOAT_NUMBER .)
    EQ              reduce using rule 38 (expression -> FLOAT_NUMBER .)
    AND             reduce using rule 38 (expression -> FLOAT_NUMBER .)
    OR              reduce using rule 38 (expression -> FLOAT_NUMBER .)
    BITWISE_AND     reduce using rule 38 (expression -> FLOAT_NUMBER .)
    BITWISE_OR      reduce using rule 38 (expression -> FLOAT_NUMBER .)
    BITWISE_XOR     reduce using rule 38 (expression -> FLOAT_NUMBER .)
    URSHIFT         reduce using rule 38 (expression -> FLOAT_NUMBER .)
    LSHIFT          reduce using rule 38 (expression -> FLOAT_NUMBER .)
    RSHIFT          reduce using rule 38 (expression -> FLOAT_NUMBER .)
    RPAREN          reduce using rule 38 (expression -> FLOAT_NUMBER .)
    COMMA           reduce using rule 38 (expression -> FLOAT_NUMBER .)


state 47

    (39) expression -> INT_NUMBER .

    SEMICOLON       reduce using rule 39 (expression -> INT_NUMBER .)
    TIMES           reduce using rule 39 (expression -> INT_NUMBER .)
    DIVIDE          reduce using rule 39 (expression -> INT_NUMBER .)
    MODULE          reduce using rule 39 (expression -> INT_NUMBER .)
    PLUS            reduce using rule 39 (expression -> INT_NUMBER .)
    MINUS           reduce using rule 39 (expression -> INT_NUMBER .)
    LEQ             reduce using rule 39 (expression -> INT_NUMBER .)
    GEQ             reduce using rule 39 (expression -> INT_NUMBER .)
    LT              reduce using rule 39 (expression -> INT_NUMBER .)
    GT              reduce using rule 39 (expression -> INT_NUMBER .)
    NEQ             reduce using rule 39 (expression -> INT_NUMBER .)
    EQ              reduce using rule 39 (expression -> INT_NUMBER .)
    AND             reduce using rule 39 (expression -> INT_NUMBER .)
    OR              reduce using rule 39 (expression -> INT_NUMBER .)
    BITWISE_AND     reduce using rule 39 (expression -> INT_NUMBER .)
    BITWISE_OR      reduce using rule 39 (expression -> INT_NUMBER .)
    BITWISE_XOR     reduce using rule 39 (expression -> INT_NUMBER .)
    URSHIFT         reduce using rule 39 (expression -> INT_NUMBER .)
    LSHIFT          reduce using rule 39 (expression -> INT_NUMBER .)
    RSHIFT          reduce using rule 39 (expression -> INT_NUMBER .)
    RPAREN          reduce using rule 39 (expression -> INT_NUMBER .)
    COMMA           reduce using rule 39 (expression -> INT_NUMBER .)


state 48

    (40) expression -> STRING .

    SEMICOLON       reduce using rule 40 (expression -> STRING .)
    TIMES           reduce using rule 40 (expression -> STRING .)
    DIVIDE          reduce using rule 40 (expression -> STRING .)
    MODULE          reduce using rule 40 (expression -> STRING .)
    PLUS            reduce using rule 40 (expression -> STRING .)
    MINUS           reduce using rule 40 (expression -> STRING .)
    LEQ             reduce using rule 40 (expression -> STRING .)
    GEQ             reduce using rule 40 (expression -> STRING .)
    LT              reduce using rule 40 (expression -> STRING .)
    GT              reduce using rule 40 (expression -> STRING .)
    NEQ             reduce using rule 40 (expression -> STRING .)
    EQ              reduce using rule 40 (expression -> STRING .)
    AND             reduce using rule 40 (expression -> STRING .)
    OR              reduce using rule 40 (expression -> STRING .)
    BITWISE_AND     reduce using rule 40 (expression -> STRING .)
    BITWISE_OR      reduce using rule 40 (expression -> STRING .)
    BITWISE_XOR     reduce using rule 40 (expression -> STRING .)
    URSHIFT         reduce using rule 40 (expression -> STRING .)
    LSHIFT          reduce using rule 40 (expression -> STRING .)
    RSHIFT          reduce using rule 40 (expression -> STRING .)
    RPAREN          reduce using rule 40 (expression -> STRING .)
    COMMA           reduce using rule 40 (expression -> STRING .)


state 49

    (41) expression -> ID .
    (43) operator -> ID . assign expression
    (46) operator -> ID . unaryoperatorsufx
    (86) call -> ID . LPAREN params RPAREN
    (87) call -> ID . LPAREN RPAREN
    (53) assign -> . EQUAL
    (54) assign -> . PLUS_EQ
    (55) assign -> . MINUS_EQ
    (56) assign -> . TIMES_EQ
    (57) assign -> . DIVIDE_EQ
    (58) assign -> . MOD_EQ
    (59) assign -> . BITWISE_AND_EQ
    (60) assign -> . BITWISE_OR_EQ
    (61) assign -> . BITWISE_XOR_EQ
    (62) assign -> . URSHIFT_EQ
    (63) assign -> . LSHIFT_EQ
    (64) assign -> . RSHIFT_EQ
    (81) unaryoperatorsufx -> . INCREMENT
    (82) unaryoperatorsufx -> . DECREMENT

    SEMICOLON       reduce using rule 41 (expression -> ID .)
    TIMES           reduce using rule 41 (expression -> ID .)
    DIVIDE          reduce using rule 41 (expression -> ID .)
    MODULE          reduce using rule 41 (expression -> ID .)
    PLUS            reduce using rule 41 (expression -> ID .)
    MINUS           reduce using rule 41 (expression -> ID .)
    LEQ             reduce using rule 41 (expression -> ID .)
    GEQ             reduce using rule 41 (expression -> ID .)
    LT              reduce using rule 41 (expression -> ID .)
    GT              reduce using rule 41 (expression -> ID .)
    NEQ             reduce using rule 41 (expression -> ID .)
    EQ              reduce using rule 41 (expression -> ID .)
    AND             reduce using rule 41 (expression -> ID .)
    OR              reduce using rule 41 (expression -> ID .)
    BITWISE_AND     reduce using rule 41 (expression -> ID .)
    BITWISE_OR      reduce using rule 41 (expression -> ID .)
    BITWISE_XOR     reduce using rule 41 (expression -> ID .)
    URSHIFT         reduce using rule 41 (expression -> ID .)
    LSHIFT          reduce using rule 41 (expression -> ID .)
    RSHIFT          reduce using rule 41 (expression -> ID .)
    RPAREN          reduce using rule 41 (expression -> ID .)
    COMMA           reduce using rule 41 (expression -> ID .)
    LPAREN          shift and go to state 91
    EQUAL           shift and go to state 92
    PLUS_EQ         shift and go to state 93
    MINUS_EQ        shift and go to state 94
    TIMES_EQ        shift and go to state 95
    DIVIDE_EQ       shift and go to state 96
    MOD_EQ          shift and go to state 97
    BITWISE_AND_EQ  shift and go to state 98
    BITWISE_OR_EQ   shift and go to state 99
    BITWISE_XOR_EQ  shift and go to state 100
    URSHIFT_EQ      shift and go to state 101
    LSHIFT_EQ       shift and go to state 102
    RSHIFT_EQ       shift and go to state 103
    INCREMENT       shift and go to state 104
    DECREMENT       shift and go to state 105

    assign                         shift and go to state 89
    unaryoperatorsufx              shift and go to state 90

state 50

    (45) operator -> unaryoperatorprefx . ID

    ID              shift and go to state 106


state 51

    (76) unaryoperatorprefx -> INCREMENT .

    ID              reduce using rule 76 (unaryoperatorprefx -> INCREMENT .)


state 52

    (77) unaryoperatorprefx -> DECREMENT .

    ID              reduce using rule 77 (unaryoperatorprefx -> DECREMENT .)


state 53

    (78) unaryoperatorprefx -> MINUS_EQ .

    ID              reduce using rule 78 (unaryoperatorprefx -> MINUS_EQ .)


state 54

    (79) unaryoperatorprefx -> PLUS .

    ID              reduce using rule 79 (unaryoperatorprefx -> PLUS .)


state 55

    (80) unaryoperatorprefx -> NOT .

    ID              reduce using rule 80 (unaryoperatorprefx -> NOT .)


state 56

    (4) class -> visibility classmodifier CLASS ID IMPLEMENTS LCHAV membros RCHAV .

    $end            reduce using rule 4 (class -> visibility classmodifier CLASS ID IMPLEMENTS LCHAV membros RCHAV .)


state 57

    (2) class -> visibility classmodifier CLASS ID EXTENDS ID LCHAV membros RCHAV .

    $end            reduce using rule 2 (class -> visibility classmodifier CLASS ID EXTENDS ID LCHAV membros RCHAV .)


state 58

    (21) signature -> visibility ID ID LPAREN . sigparams RPAREN
    (22) sigparams -> . ID
    (23) sigparams -> . ID COMMA sigparams

    ID              shift and go to state 107

    sigparams                      shift and go to state 108

state 59

    (24) body -> LCHAV stms RCHAV .

    PUBLIC          reduce using rule 24 (body -> LCHAV stms RCHAV .)
    PRIVATE         reduce using rule 24 (body -> LCHAV stms RCHAV .)
    PROTECTED       reduce using rule 24 (body -> LCHAV stms RCHAV .)
    ID              reduce using rule 24 (body -> LCHAV stms RCHAV .)
    STATIC          reduce using rule 24 (body -> LCHAV stms RCHAV .)
    FINAL           reduce using rule 24 (body -> LCHAV stms RCHAV .)
    RCHAV           reduce using rule 24 (body -> LCHAV stms RCHAV .)
    WHILE           reduce using rule 24 (body -> LCHAV stms RCHAV .)
    DO              reduce using rule 24 (body -> LCHAV stms RCHAV .)
    FOR             reduce using rule 24 (body -> LCHAV stms RCHAV .)
    IF              reduce using rule 24 (body -> LCHAV stms RCHAV .)
    SEMICOLON       reduce using rule 24 (body -> LCHAV stms RCHAV .)
    FLOAT_NUMBER    reduce using rule 24 (body -> LCHAV stms RCHAV .)
    INT_NUMBER      reduce using rule 24 (body -> LCHAV stms RCHAV .)
    STRING          reduce using rule 24 (body -> LCHAV stms RCHAV .)
    INCREMENT       reduce using rule 24 (body -> LCHAV stms RCHAV .)
    DECREMENT       reduce using rule 24 (body -> LCHAV stms RCHAV .)
    MINUS_EQ        reduce using rule 24 (body -> LCHAV stms RCHAV .)
    PLUS            reduce using rule 24 (body -> LCHAV stms RCHAV .)
    NOT             reduce using rule 24 (body -> LCHAV stms RCHAV .)
    ELSE            reduce using rule 24 (body -> LCHAV stms RCHAV .)


state 60

    (26) stms -> stm stms .

    RCHAV           reduce using rule 26 (stms -> stm stms .)


state 61

    (27) stm -> expression SEMICOLON .

    WHILE           reduce using rule 27 (stm -> expression SEMICOLON .)
    DO              reduce using rule 27 (stm -> expression SEMICOLON .)
    FOR             reduce using rule 27 (stm -> expression SEMICOLON .)
    IF              reduce using rule 27 (stm -> expression SEMICOLON .)
    SEMICOLON       reduce using rule 27 (stm -> expression SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 27 (stm -> expression SEMICOLON .)
    INT_NUMBER      reduce using rule 27 (stm -> expression SEMICOLON .)
    STRING          reduce using rule 27 (stm -> expression SEMICOLON .)
    ID              reduce using rule 27 (stm -> expression SEMICOLON .)
    INCREMENT       reduce using rule 27 (stm -> expression SEMICOLON .)
    DECREMENT       reduce using rule 27 (stm -> expression SEMICOLON .)
    MINUS_EQ        reduce using rule 27 (stm -> expression SEMICOLON .)
    PLUS            reduce using rule 27 (stm -> expression SEMICOLON .)
    NOT             reduce using rule 27 (stm -> expression SEMICOLON .)
    RCHAV           reduce using rule 27 (stm -> expression SEMICOLON .)


state 62

    (42) operator -> expression arithmetic . expression
    (36) expression -> . operator
    (37) expression -> . call
    (38) expression -> . FLOAT_NUMBER
    (39) expression -> . INT_NUMBER
    (40) expression -> . STRING
    (41) expression -> . ID
    (42) operator -> . expression arithmetic expression
    (43) operator -> . ID assign expression
    (44) operator -> . expression operatorcomparator expression
    (45) operator -> . unaryoperatorprefx ID
    (46) operator -> . ID unaryoperatorsufx
    (47) operator -> . expression operatorbittobit
    (86) call -> . ID LPAREN params RPAREN
    (87) call -> . ID LPAREN RPAREN
    (76) unaryoperatorprefx -> . INCREMENT
    (77) unaryoperatorprefx -> . DECREMENT
    (78) unaryoperatorprefx -> . MINUS_EQ
    (79) unaryoperatorprefx -> . PLUS
    (80) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 46
    INT_NUMBER      shift and go to state 47
    STRING          shift and go to state 48
    ID              shift and go to state 49
    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52
    MINUS_EQ        shift and go to state 53
    PLUS            shift and go to state 54
    NOT             shift and go to state 55

    expression                     shift and go to state 109
    operator                       shift and go to state 44
    call                           shift and go to state 45
    unaryoperatorprefx             shift and go to state 50

state 63

    (44) operator -> expression operatorcomparator . expression
    (36) expression -> . operator
    (37) expression -> . call
    (38) expression -> . FLOAT_NUMBER
    (39) expression -> . INT_NUMBER
    (40) expression -> . STRING
    (41) expression -> . ID
    (42) operator -> . expression arithmetic expression
    (43) operator -> . ID assign expression
    (44) operator -> . expression operatorcomparator expression
    (45) operator -> . unaryoperatorprefx ID
    (46) operator -> . ID unaryoperatorsufx
    (47) operator -> . expression operatorbittobit
    (86) call -> . ID LPAREN params RPAREN
    (87) call -> . ID LPAREN RPAREN
    (76) unaryoperatorprefx -> . INCREMENT
    (77) unaryoperatorprefx -> . DECREMENT
    (78) unaryoperatorprefx -> . MINUS_EQ
    (79) unaryoperatorprefx -> . PLUS
    (80) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 46
    INT_NUMBER      shift and go to state 47
    STRING          shift and go to state 48
    ID              shift and go to state 49
    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52
    MINUS_EQ        shift and go to state 53
    PLUS            shift and go to state 54
    NOT             shift and go to state 55

    expression                     shift and go to state 110
    operator                       shift and go to state 44
    call                           shift and go to state 45
    unaryoperatorprefx             shift and go to state 50

state 64

    (47) operator -> expression operatorbittobit .

    SEMICOLON       reduce using rule 47 (operator -> expression operatorbittobit .)
    TIMES           reduce using rule 47 (operator -> expression operatorbittobit .)
    DIVIDE          reduce using rule 47 (operator -> expression operatorbittobit .)
    MODULE          reduce using rule 47 (operator -> expression operatorbittobit .)
    PLUS            reduce using rule 47 (operator -> expression operatorbittobit .)
    MINUS           reduce using rule 47 (operator -> expression operatorbittobit .)
    LEQ             reduce using rule 47 (operator -> expression operatorbittobit .)
    GEQ             reduce using rule 47 (operator -> expression operatorbittobit .)
    LT              reduce using rule 47 (operator -> expression operatorbittobit .)
    GT              reduce using rule 47 (operator -> expression operatorbittobit .)
    NEQ             reduce using rule 47 (operator -> expression operatorbittobit .)
    EQ              reduce using rule 47 (operator -> expression operatorbittobit .)
    AND             reduce using rule 47 (operator -> expression operatorbittobit .)
    OR              reduce using rule 47 (operator -> expression operatorbittobit .)
    BITWISE_AND     reduce using rule 47 (operator -> expression operatorbittobit .)
    BITWISE_OR      reduce using rule 47 (operator -> expression operatorbittobit .)
    BITWISE_XOR     reduce using rule 47 (operator -> expression operatorbittobit .)
    URSHIFT         reduce using rule 47 (operator -> expression operatorbittobit .)
    LSHIFT          reduce using rule 47 (operator -> expression operatorbittobit .)
    RSHIFT          reduce using rule 47 (operator -> expression operatorbittobit .)
    RPAREN          reduce using rule 47 (operator -> expression operatorbittobit .)
    COMMA           reduce using rule 47 (operator -> expression operatorbittobit .)


state 65

    (48) arithmetic -> TIMES .

    FLOAT_NUMBER    reduce using rule 48 (arithmetic -> TIMES .)
    INT_NUMBER      reduce using rule 48 (arithmetic -> TIMES .)
    STRING          reduce using rule 48 (arithmetic -> TIMES .)
    ID              reduce using rule 48 (arithmetic -> TIMES .)
    INCREMENT       reduce using rule 48 (arithmetic -> TIMES .)
    DECREMENT       reduce using rule 48 (arithmetic -> TIMES .)
    MINUS_EQ        reduce using rule 48 (arithmetic -> TIMES .)
    PLUS            reduce using rule 48 (arithmetic -> TIMES .)
    NOT             reduce using rule 48 (arithmetic -> TIMES .)


state 66

    (49) arithmetic -> DIVIDE .

    FLOAT_NUMBER    reduce using rule 49 (arithmetic -> DIVIDE .)
    INT_NUMBER      reduce using rule 49 (arithmetic -> DIVIDE .)
    STRING          reduce using rule 49 (arithmetic -> DIVIDE .)
    ID              reduce using rule 49 (arithmetic -> DIVIDE .)
    INCREMENT       reduce using rule 49 (arithmetic -> DIVIDE .)
    DECREMENT       reduce using rule 49 (arithmetic -> DIVIDE .)
    MINUS_EQ        reduce using rule 49 (arithmetic -> DIVIDE .)
    PLUS            reduce using rule 49 (arithmetic -> DIVIDE .)
    NOT             reduce using rule 49 (arithmetic -> DIVIDE .)


state 67

    (50) arithmetic -> MODULE .

    FLOAT_NUMBER    reduce using rule 50 (arithmetic -> MODULE .)
    INT_NUMBER      reduce using rule 50 (arithmetic -> MODULE .)
    STRING          reduce using rule 50 (arithmetic -> MODULE .)
    ID              reduce using rule 50 (arithmetic -> MODULE .)
    INCREMENT       reduce using rule 50 (arithmetic -> MODULE .)
    DECREMENT       reduce using rule 50 (arithmetic -> MODULE .)
    MINUS_EQ        reduce using rule 50 (arithmetic -> MODULE .)
    PLUS            reduce using rule 50 (arithmetic -> MODULE .)
    NOT             reduce using rule 50 (arithmetic -> MODULE .)


state 68

    (51) arithmetic -> PLUS .

    FLOAT_NUMBER    reduce using rule 51 (arithmetic -> PLUS .)
    INT_NUMBER      reduce using rule 51 (arithmetic -> PLUS .)
    STRING          reduce using rule 51 (arithmetic -> PLUS .)
    ID              reduce using rule 51 (arithmetic -> PLUS .)
    INCREMENT       reduce using rule 51 (arithmetic -> PLUS .)
    DECREMENT       reduce using rule 51 (arithmetic -> PLUS .)
    MINUS_EQ        reduce using rule 51 (arithmetic -> PLUS .)
    PLUS            reduce using rule 51 (arithmetic -> PLUS .)
    NOT             reduce using rule 51 (arithmetic -> PLUS .)


state 69

    (52) arithmetic -> MINUS .

    FLOAT_NUMBER    reduce using rule 52 (arithmetic -> MINUS .)
    INT_NUMBER      reduce using rule 52 (arithmetic -> MINUS .)
    STRING          reduce using rule 52 (arithmetic -> MINUS .)
    ID              reduce using rule 52 (arithmetic -> MINUS .)
    INCREMENT       reduce using rule 52 (arithmetic -> MINUS .)
    DECREMENT       reduce using rule 52 (arithmetic -> MINUS .)
    MINUS_EQ        reduce using rule 52 (arithmetic -> MINUS .)
    PLUS            reduce using rule 52 (arithmetic -> MINUS .)
    NOT             reduce using rule 52 (arithmetic -> MINUS .)


state 70

    (65) operatorcomparator -> LEQ .

    FLOAT_NUMBER    reduce using rule 65 (operatorcomparator -> LEQ .)
    INT_NUMBER      reduce using rule 65 (operatorcomparator -> LEQ .)
    STRING          reduce using rule 65 (operatorcomparator -> LEQ .)
    ID              reduce using rule 65 (operatorcomparator -> LEQ .)
    INCREMENT       reduce using rule 65 (operatorcomparator -> LEQ .)
    DECREMENT       reduce using rule 65 (operatorcomparator -> LEQ .)
    MINUS_EQ        reduce using rule 65 (operatorcomparator -> LEQ .)
    PLUS            reduce using rule 65 (operatorcomparator -> LEQ .)
    NOT             reduce using rule 65 (operatorcomparator -> LEQ .)


state 71

    (66) operatorcomparator -> GEQ .

    FLOAT_NUMBER    reduce using rule 66 (operatorcomparator -> GEQ .)
    INT_NUMBER      reduce using rule 66 (operatorcomparator -> GEQ .)
    STRING          reduce using rule 66 (operatorcomparator -> GEQ .)
    ID              reduce using rule 66 (operatorcomparator -> GEQ .)
    INCREMENT       reduce using rule 66 (operatorcomparator -> GEQ .)
    DECREMENT       reduce using rule 66 (operatorcomparator -> GEQ .)
    MINUS_EQ        reduce using rule 66 (operatorcomparator -> GEQ .)
    PLUS            reduce using rule 66 (operatorcomparator -> GEQ .)
    NOT             reduce using rule 66 (operatorcomparator -> GEQ .)


state 72

    (67) operatorcomparator -> LT .

    FLOAT_NUMBER    reduce using rule 67 (operatorcomparator -> LT .)
    INT_NUMBER      reduce using rule 67 (operatorcomparator -> LT .)
    STRING          reduce using rule 67 (operatorcomparator -> LT .)
    ID              reduce using rule 67 (operatorcomparator -> LT .)
    INCREMENT       reduce using rule 67 (operatorcomparator -> LT .)
    DECREMENT       reduce using rule 67 (operatorcomparator -> LT .)
    MINUS_EQ        reduce using rule 67 (operatorcomparator -> LT .)
    PLUS            reduce using rule 67 (operatorcomparator -> LT .)
    NOT             reduce using rule 67 (operatorcomparator -> LT .)


state 73

    (68) operatorcomparator -> GT .

    FLOAT_NUMBER    reduce using rule 68 (operatorcomparator -> GT .)
    INT_NUMBER      reduce using rule 68 (operatorcomparator -> GT .)
    STRING          reduce using rule 68 (operatorcomparator -> GT .)
    ID              reduce using rule 68 (operatorcomparator -> GT .)
    INCREMENT       reduce using rule 68 (operatorcomparator -> GT .)
    DECREMENT       reduce using rule 68 (operatorcomparator -> GT .)
    MINUS_EQ        reduce using rule 68 (operatorcomparator -> GT .)
    PLUS            reduce using rule 68 (operatorcomparator -> GT .)
    NOT             reduce using rule 68 (operatorcomparator -> GT .)


state 74

    (69) operatorcomparator -> NEQ .

    FLOAT_NUMBER    reduce using rule 69 (operatorcomparator -> NEQ .)
    INT_NUMBER      reduce using rule 69 (operatorcomparator -> NEQ .)
    STRING          reduce using rule 69 (operatorcomparator -> NEQ .)
    ID              reduce using rule 69 (operatorcomparator -> NEQ .)
    INCREMENT       reduce using rule 69 (operatorcomparator -> NEQ .)
    DECREMENT       reduce using rule 69 (operatorcomparator -> NEQ .)
    MINUS_EQ        reduce using rule 69 (operatorcomparator -> NEQ .)
    PLUS            reduce using rule 69 (operatorcomparator -> NEQ .)
    NOT             reduce using rule 69 (operatorcomparator -> NEQ .)


state 75

    (70) operatorcomparator -> EQ .

    FLOAT_NUMBER    reduce using rule 70 (operatorcomparator -> EQ .)
    INT_NUMBER      reduce using rule 70 (operatorcomparator -> EQ .)
    STRING          reduce using rule 70 (operatorcomparator -> EQ .)
    ID              reduce using rule 70 (operatorcomparator -> EQ .)
    INCREMENT       reduce using rule 70 (operatorcomparator -> EQ .)
    DECREMENT       reduce using rule 70 (operatorcomparator -> EQ .)
    MINUS_EQ        reduce using rule 70 (operatorcomparator -> EQ .)
    PLUS            reduce using rule 70 (operatorcomparator -> EQ .)
    NOT             reduce using rule 70 (operatorcomparator -> EQ .)


state 76

    (71) operatorcomparator -> AND .

    FLOAT_NUMBER    reduce using rule 71 (operatorcomparator -> AND .)
    INT_NUMBER      reduce using rule 71 (operatorcomparator -> AND .)
    STRING          reduce using rule 71 (operatorcomparator -> AND .)
    ID              reduce using rule 71 (operatorcomparator -> AND .)
    INCREMENT       reduce using rule 71 (operatorcomparator -> AND .)
    DECREMENT       reduce using rule 71 (operatorcomparator -> AND .)
    MINUS_EQ        reduce using rule 71 (operatorcomparator -> AND .)
    PLUS            reduce using rule 71 (operatorcomparator -> AND .)
    NOT             reduce using rule 71 (operatorcomparator -> AND .)


state 77

    (72) operatorcomparator -> OR .

    FLOAT_NUMBER    reduce using rule 72 (operatorcomparator -> OR .)
    INT_NUMBER      reduce using rule 72 (operatorcomparator -> OR .)
    STRING          reduce using rule 72 (operatorcomparator -> OR .)
    ID              reduce using rule 72 (operatorcomparator -> OR .)
    INCREMENT       reduce using rule 72 (operatorcomparator -> OR .)
    DECREMENT       reduce using rule 72 (operatorcomparator -> OR .)
    MINUS_EQ        reduce using rule 72 (operatorcomparator -> OR .)
    PLUS            reduce using rule 72 (operatorcomparator -> OR .)
    NOT             reduce using rule 72 (operatorcomparator -> OR .)


state 78

    (73) operatorcomparator -> BITWISE_AND .

    FLOAT_NUMBER    reduce using rule 73 (operatorcomparator -> BITWISE_AND .)
    INT_NUMBER      reduce using rule 73 (operatorcomparator -> BITWISE_AND .)
    STRING          reduce using rule 73 (operatorcomparator -> BITWISE_AND .)
    ID              reduce using rule 73 (operatorcomparator -> BITWISE_AND .)
    INCREMENT       reduce using rule 73 (operatorcomparator -> BITWISE_AND .)
    DECREMENT       reduce using rule 73 (operatorcomparator -> BITWISE_AND .)
    MINUS_EQ        reduce using rule 73 (operatorcomparator -> BITWISE_AND .)
    PLUS            reduce using rule 73 (operatorcomparator -> BITWISE_AND .)
    NOT             reduce using rule 73 (operatorcomparator -> BITWISE_AND .)


state 79

    (74) operatorcomparator -> BITWISE_OR .

    FLOAT_NUMBER    reduce using rule 74 (operatorcomparator -> BITWISE_OR .)
    INT_NUMBER      reduce using rule 74 (operatorcomparator -> BITWISE_OR .)
    STRING          reduce using rule 74 (operatorcomparator -> BITWISE_OR .)
    ID              reduce using rule 74 (operatorcomparator -> BITWISE_OR .)
    INCREMENT       reduce using rule 74 (operatorcomparator -> BITWISE_OR .)
    DECREMENT       reduce using rule 74 (operatorcomparator -> BITWISE_OR .)
    MINUS_EQ        reduce using rule 74 (operatorcomparator -> BITWISE_OR .)
    PLUS            reduce using rule 74 (operatorcomparator -> BITWISE_OR .)
    NOT             reduce using rule 74 (operatorcomparator -> BITWISE_OR .)


state 80

    (75) operatorcomparator -> BITWISE_XOR .

    FLOAT_NUMBER    reduce using rule 75 (operatorcomparator -> BITWISE_XOR .)
    INT_NUMBER      reduce using rule 75 (operatorcomparator -> BITWISE_XOR .)
    STRING          reduce using rule 75 (operatorcomparator -> BITWISE_XOR .)
    ID              reduce using rule 75 (operatorcomparator -> BITWISE_XOR .)
    INCREMENT       reduce using rule 75 (operatorcomparator -> BITWISE_XOR .)
    DECREMENT       reduce using rule 75 (operatorcomparator -> BITWISE_XOR .)
    MINUS_EQ        reduce using rule 75 (operatorcomparator -> BITWISE_XOR .)
    PLUS            reduce using rule 75 (operatorcomparator -> BITWISE_XOR .)
    NOT             reduce using rule 75 (operatorcomparator -> BITWISE_XOR .)


state 81

    (83) operatorbittobit -> URSHIFT .

    SEMICOLON       reduce using rule 83 (operatorbittobit -> URSHIFT .)
    TIMES           reduce using rule 83 (operatorbittobit -> URSHIFT .)
    DIVIDE          reduce using rule 83 (operatorbittobit -> URSHIFT .)
    MODULE          reduce using rule 83 (operatorbittobit -> URSHIFT .)
    PLUS            reduce using rule 83 (operatorbittobit -> URSHIFT .)
    MINUS           reduce using rule 83 (operatorbittobit -> URSHIFT .)
    LEQ             reduce using rule 83 (operatorbittobit -> URSHIFT .)
    GEQ             reduce using rule 83 (operatorbittobit -> URSHIFT .)
    LT              reduce using rule 83 (operatorbittobit -> URSHIFT .)
    GT              reduce using rule 83 (operatorbittobit -> URSHIFT .)
    NEQ             reduce using rule 83 (operatorbittobit -> URSHIFT .)
    EQ              reduce using rule 83 (operatorbittobit -> URSHIFT .)
    AND             reduce using rule 83 (operatorbittobit -> URSHIFT .)
    OR              reduce using rule 83 (operatorbittobit -> URSHIFT .)
    BITWISE_AND     reduce using rule 83 (operatorbittobit -> URSHIFT .)
    BITWISE_OR      reduce using rule 83 (operatorbittobit -> URSHIFT .)
    BITWISE_XOR     reduce using rule 83 (operatorbittobit -> URSHIFT .)
    URSHIFT         reduce using rule 83 (operatorbittobit -> URSHIFT .)
    LSHIFT          reduce using rule 83 (operatorbittobit -> URSHIFT .)
    RSHIFT          reduce using rule 83 (operatorbittobit -> URSHIFT .)
    RPAREN          reduce using rule 83 (operatorbittobit -> URSHIFT .)
    COMMA           reduce using rule 83 (operatorbittobit -> URSHIFT .)


state 82

    (84) operatorbittobit -> LSHIFT .

    SEMICOLON       reduce using rule 84 (operatorbittobit -> LSHIFT .)
    TIMES           reduce using rule 84 (operatorbittobit -> LSHIFT .)
    DIVIDE          reduce using rule 84 (operatorbittobit -> LSHIFT .)
    MODULE          reduce using rule 84 (operatorbittobit -> LSHIFT .)
    PLUS            reduce using rule 84 (operatorbittobit -> LSHIFT .)
    MINUS           reduce using rule 84 (operatorbittobit -> LSHIFT .)
    LEQ             reduce using rule 84 (operatorbittobit -> LSHIFT .)
    GEQ             reduce using rule 84 (operatorbittobit -> LSHIFT .)
    LT              reduce using rule 84 (operatorbittobit -> LSHIFT .)
    GT              reduce using rule 84 (operatorbittobit -> LSHIFT .)
    NEQ             reduce using rule 84 (operatorbittobit -> LSHIFT .)
    EQ              reduce using rule 84 (operatorbittobit -> LSHIFT .)
    AND             reduce using rule 84 (operatorbittobit -> LSHIFT .)
    OR              reduce using rule 84 (operatorbittobit -> LSHIFT .)
    BITWISE_AND     reduce using rule 84 (operatorbittobit -> LSHIFT .)
    BITWISE_OR      reduce using rule 84 (operatorbittobit -> LSHIFT .)
    BITWISE_XOR     reduce using rule 84 (operatorbittobit -> LSHIFT .)
    URSHIFT         reduce using rule 84 (operatorbittobit -> LSHIFT .)
    LSHIFT          reduce using rule 84 (operatorbittobit -> LSHIFT .)
    RSHIFT          reduce using rule 84 (operatorbittobit -> LSHIFT .)
    RPAREN          reduce using rule 84 (operatorbittobit -> LSHIFT .)
    COMMA           reduce using rule 84 (operatorbittobit -> LSHIFT .)


state 83

    (85) operatorbittobit -> RSHIFT .

    SEMICOLON       reduce using rule 85 (operatorbittobit -> RSHIFT .)
    TIMES           reduce using rule 85 (operatorbittobit -> RSHIFT .)
    DIVIDE          reduce using rule 85 (operatorbittobit -> RSHIFT .)
    MODULE          reduce using rule 85 (operatorbittobit -> RSHIFT .)
    PLUS            reduce using rule 85 (operatorbittobit -> RSHIFT .)
    MINUS           reduce using rule 85 (operatorbittobit -> RSHIFT .)
    LEQ             reduce using rule 85 (operatorbittobit -> RSHIFT .)
    GEQ             reduce using rule 85 (operatorbittobit -> RSHIFT .)
    LT              reduce using rule 85 (operatorbittobit -> RSHIFT .)
    GT              reduce using rule 85 (operatorbittobit -> RSHIFT .)
    NEQ             reduce using rule 85 (operatorbittobit -> RSHIFT .)
    EQ              reduce using rule 85 (operatorbittobit -> RSHIFT .)
    AND             reduce using rule 85 (operatorbittobit -> RSHIFT .)
    OR              reduce using rule 85 (operatorbittobit -> RSHIFT .)
    BITWISE_AND     reduce using rule 85 (operatorbittobit -> RSHIFT .)
    BITWISE_OR      reduce using rule 85 (operatorbittobit -> RSHIFT .)
    BITWISE_XOR     reduce using rule 85 (operatorbittobit -> RSHIFT .)
    URSHIFT         reduce using rule 85 (operatorbittobit -> RSHIFT .)
    LSHIFT          reduce using rule 85 (operatorbittobit -> RSHIFT .)
    RSHIFT          reduce using rule 85 (operatorbittobit -> RSHIFT .)
    RPAREN          reduce using rule 85 (operatorbittobit -> RSHIFT .)
    COMMA           reduce using rule 85 (operatorbittobit -> RSHIFT .)


state 84

    (28) stm -> WHILE LPAREN . expression RPAREN bodyorstm
    (36) expression -> . operator
    (37) expression -> . call
    (38) expression -> . FLOAT_NUMBER
    (39) expression -> . INT_NUMBER
    (40) expression -> . STRING
    (41) expression -> . ID
    (42) operator -> . expression arithmetic expression
    (43) operator -> . ID assign expression
    (44) operator -> . expression operatorcomparator expression
    (45) operator -> . unaryoperatorprefx ID
    (46) operator -> . ID unaryoperatorsufx
    (47) operator -> . expression operatorbittobit
    (86) call -> . ID LPAREN params RPAREN
    (87) call -> . ID LPAREN RPAREN
    (76) unaryoperatorprefx -> . INCREMENT
    (77) unaryoperatorprefx -> . DECREMENT
    (78) unaryoperatorprefx -> . MINUS_EQ
    (79) unaryoperatorprefx -> . PLUS
    (80) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 46
    INT_NUMBER      shift and go to state 47
    STRING          shift and go to state 48
    ID              shift and go to state 49
    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52
    MINUS_EQ        shift and go to state 53
    PLUS            shift and go to state 54
    NOT             shift and go to state 55

    expression                     shift and go to state 111
    operator                       shift and go to state 44
    call                           shift and go to state 45
    unaryoperatorprefx             shift and go to state 50

state 85

    (29) stm -> DO bodyorstm . WHILE LPAREN expression RPAREN SEMICOLON

    WHILE           shift and go to state 112


state 86

    (35) bodyorstm -> body .

    WHILE           reduce using rule 35 (bodyorstm -> body .)
    DO              reduce using rule 35 (bodyorstm -> body .)
    FOR             reduce using rule 35 (bodyorstm -> body .)
    IF              reduce using rule 35 (bodyorstm -> body .)
    SEMICOLON       reduce using rule 35 (bodyorstm -> body .)
    FLOAT_NUMBER    reduce using rule 35 (bodyorstm -> body .)
    INT_NUMBER      reduce using rule 35 (bodyorstm -> body .)
    STRING          reduce using rule 35 (bodyorstm -> body .)
    ID              reduce using rule 35 (bodyorstm -> body .)
    INCREMENT       reduce using rule 35 (bodyorstm -> body .)
    DECREMENT       reduce using rule 35 (bodyorstm -> body .)
    MINUS_EQ        reduce using rule 35 (bodyorstm -> body .)
    PLUS            reduce using rule 35 (bodyorstm -> body .)
    NOT             reduce using rule 35 (bodyorstm -> body .)
    RCHAV           reduce using rule 35 (bodyorstm -> body .)
    ELSE            reduce using rule 35 (bodyorstm -> body .)


state 87

    (30) stm -> FOR LPAREN . expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm
    (36) expression -> . operator
    (37) expression -> . call
    (38) expression -> . FLOAT_NUMBER
    (39) expression -> . INT_NUMBER
    (40) expression -> . STRING
    (41) expression -> . ID
    (42) operator -> . expression arithmetic expression
    (43) operator -> . ID assign expression
    (44) operator -> . expression operatorcomparator expression
    (45) operator -> . unaryoperatorprefx ID
    (46) operator -> . ID unaryoperatorsufx
    (47) operator -> . expression operatorbittobit
    (86) call -> . ID LPAREN params RPAREN
    (87) call -> . ID LPAREN RPAREN
    (76) unaryoperatorprefx -> . INCREMENT
    (77) unaryoperatorprefx -> . DECREMENT
    (78) unaryoperatorprefx -> . MINUS_EQ
    (79) unaryoperatorprefx -> . PLUS
    (80) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 46
    INT_NUMBER      shift and go to state 47
    STRING          shift and go to state 48
    ID              shift and go to state 49
    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52
    MINUS_EQ        shift and go to state 53
    PLUS            shift and go to state 54
    NOT             shift and go to state 55

    expression                     shift and go to state 113
    operator                       shift and go to state 44
    call                           shift and go to state 45
    unaryoperatorprefx             shift and go to state 50

state 88

    (31) stm -> IF LPAREN . expression RPAREN bodyorstm
    (32) stm -> IF LPAREN . expression RPAREN bodyorstm ELSE bodyorstm
    (33) stm -> IF LPAREN . expression RPAREN bodyorstm ELSE IF bodyorstm
    (36) expression -> . operator
    (37) expression -> . call
    (38) expression -> . FLOAT_NUMBER
    (39) expression -> . INT_NUMBER
    (40) expression -> . STRING
    (41) expression -> . ID
    (42) operator -> . expression arithmetic expression
    (43) operator -> . ID assign expression
    (44) operator -> . expression operatorcomparator expression
    (45) operator -> . unaryoperatorprefx ID
    (46) operator -> . ID unaryoperatorsufx
    (47) operator -> . expression operatorbittobit
    (86) call -> . ID LPAREN params RPAREN
    (87) call -> . ID LPAREN RPAREN
    (76) unaryoperatorprefx -> . INCREMENT
    (77) unaryoperatorprefx -> . DECREMENT
    (78) unaryoperatorprefx -> . MINUS_EQ
    (79) unaryoperatorprefx -> . PLUS
    (80) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 46
    INT_NUMBER      shift and go to state 47
    STRING          shift and go to state 48
    ID              shift and go to state 49
    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52
    MINUS_EQ        shift and go to state 53
    PLUS            shift and go to state 54
    NOT             shift and go to state 55

    expression                     shift and go to state 114
    operator                       shift and go to state 44
    call                           shift and go to state 45
    unaryoperatorprefx             shift and go to state 50

state 89

    (43) operator -> ID assign . expression
    (36) expression -> . operator
    (37) expression -> . call
    (38) expression -> . FLOAT_NUMBER
    (39) expression -> . INT_NUMBER
    (40) expression -> . STRING
    (41) expression -> . ID
    (42) operator -> . expression arithmetic expression
    (43) operator -> . ID assign expression
    (44) operator -> . expression operatorcomparator expression
    (45) operator -> . unaryoperatorprefx ID
    (46) operator -> . ID unaryoperatorsufx
    (47) operator -> . expression operatorbittobit
    (86) call -> . ID LPAREN params RPAREN
    (87) call -> . ID LPAREN RPAREN
    (76) unaryoperatorprefx -> . INCREMENT
    (77) unaryoperatorprefx -> . DECREMENT
    (78) unaryoperatorprefx -> . MINUS_EQ
    (79) unaryoperatorprefx -> . PLUS
    (80) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 46
    INT_NUMBER      shift and go to state 47
    STRING          shift and go to state 48
    ID              shift and go to state 49
    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52
    MINUS_EQ        shift and go to state 53
    PLUS            shift and go to state 54
    NOT             shift and go to state 55

    expression                     shift and go to state 115
    operator                       shift and go to state 44
    call                           shift and go to state 45
    unaryoperatorprefx             shift and go to state 50

state 90

    (46) operator -> ID unaryoperatorsufx .

    SEMICOLON       reduce using rule 46 (operator -> ID unaryoperatorsufx .)
    TIMES           reduce using rule 46 (operator -> ID unaryoperatorsufx .)
    DIVIDE          reduce using rule 46 (operator -> ID unaryoperatorsufx .)
    MODULE          reduce using rule 46 (operator -> ID unaryoperatorsufx .)
    PLUS            reduce using rule 46 (operator -> ID unaryoperatorsufx .)
    MINUS           reduce using rule 46 (operator -> ID unaryoperatorsufx .)
    LEQ             reduce using rule 46 (operator -> ID unaryoperatorsufx .)
    GEQ             reduce using rule 46 (operator -> ID unaryoperatorsufx .)
    LT              reduce using rule 46 (operator -> ID unaryoperatorsufx .)
    GT              reduce using rule 46 (operator -> ID unaryoperatorsufx .)
    NEQ             reduce using rule 46 (operator -> ID unaryoperatorsufx .)
    EQ              reduce using rule 46 (operator -> ID unaryoperatorsufx .)
    AND             reduce using rule 46 (operator -> ID unaryoperatorsufx .)
    OR              reduce using rule 46 (operator -> ID unaryoperatorsufx .)
    BITWISE_AND     reduce using rule 46 (operator -> ID unaryoperatorsufx .)
    BITWISE_OR      reduce using rule 46 (operator -> ID unaryoperatorsufx .)
    BITWISE_XOR     reduce using rule 46 (operator -> ID unaryoperatorsufx .)
    URSHIFT         reduce using rule 46 (operator -> ID unaryoperatorsufx .)
    LSHIFT          reduce using rule 46 (operator -> ID unaryoperatorsufx .)
    RSHIFT          reduce using rule 46 (operator -> ID unaryoperatorsufx .)
    RPAREN          reduce using rule 46 (operator -> ID unaryoperatorsufx .)
    COMMA           reduce using rule 46 (operator -> ID unaryoperatorsufx .)


state 91

    (86) call -> ID LPAREN . params RPAREN
    (87) call -> ID LPAREN . RPAREN
    (88) params -> . expression COMMA params
    (89) params -> . expression
    (36) expression -> . operator
    (37) expression -> . call
    (38) expression -> . FLOAT_NUMBER
    (39) expression -> . INT_NUMBER
    (40) expression -> . STRING
    (41) expression -> . ID
    (42) operator -> . expression arithmetic expression
    (43) operator -> . ID assign expression
    (44) operator -> . expression operatorcomparator expression
    (45) operator -> . unaryoperatorprefx ID
    (46) operator -> . ID unaryoperatorsufx
    (47) operator -> . expression operatorbittobit
    (86) call -> . ID LPAREN params RPAREN
    (87) call -> . ID LPAREN RPAREN
    (76) unaryoperatorprefx -> . INCREMENT
    (77) unaryoperatorprefx -> . DECREMENT
    (78) unaryoperatorprefx -> . MINUS_EQ
    (79) unaryoperatorprefx -> . PLUS
    (80) unaryoperatorprefx -> . NOT

    RPAREN          shift and go to state 117
    FLOAT_NUMBER    shift and go to state 46
    INT_NUMBER      shift and go to state 47
    STRING          shift and go to state 48
    ID              shift and go to state 49
    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52
    MINUS_EQ        shift and go to state 53
    PLUS            shift and go to state 54
    NOT             shift and go to state 55

    params                         shift and go to state 116
    expression                     shift and go to state 118
    operator                       shift and go to state 44
    call                           shift and go to state 45
    unaryoperatorprefx             shift and go to state 50

state 92

    (53) assign -> EQUAL .

    FLOAT_NUMBER    reduce using rule 53 (assign -> EQUAL .)
    INT_NUMBER      reduce using rule 53 (assign -> EQUAL .)
    STRING          reduce using rule 53 (assign -> EQUAL .)
    ID              reduce using rule 53 (assign -> EQUAL .)
    INCREMENT       reduce using rule 53 (assign -> EQUAL .)
    DECREMENT       reduce using rule 53 (assign -> EQUAL .)
    MINUS_EQ        reduce using rule 53 (assign -> EQUAL .)
    PLUS            reduce using rule 53 (assign -> EQUAL .)
    NOT             reduce using rule 53 (assign -> EQUAL .)


state 93

    (54) assign -> PLUS_EQ .

    FLOAT_NUMBER    reduce using rule 54 (assign -> PLUS_EQ .)
    INT_NUMBER      reduce using rule 54 (assign -> PLUS_EQ .)
    STRING          reduce using rule 54 (assign -> PLUS_EQ .)
    ID              reduce using rule 54 (assign -> PLUS_EQ .)
    INCREMENT       reduce using rule 54 (assign -> PLUS_EQ .)
    DECREMENT       reduce using rule 54 (assign -> PLUS_EQ .)
    MINUS_EQ        reduce using rule 54 (assign -> PLUS_EQ .)
    PLUS            reduce using rule 54 (assign -> PLUS_EQ .)
    NOT             reduce using rule 54 (assign -> PLUS_EQ .)


state 94

    (55) assign -> MINUS_EQ .

    FLOAT_NUMBER    reduce using rule 55 (assign -> MINUS_EQ .)
    INT_NUMBER      reduce using rule 55 (assign -> MINUS_EQ .)
    STRING          reduce using rule 55 (assign -> MINUS_EQ .)
    ID              reduce using rule 55 (assign -> MINUS_EQ .)
    INCREMENT       reduce using rule 55 (assign -> MINUS_EQ .)
    DECREMENT       reduce using rule 55 (assign -> MINUS_EQ .)
    MINUS_EQ        reduce using rule 55 (assign -> MINUS_EQ .)
    PLUS            reduce using rule 55 (assign -> MINUS_EQ .)
    NOT             reduce using rule 55 (assign -> MINUS_EQ .)


state 95

    (56) assign -> TIMES_EQ .

    FLOAT_NUMBER    reduce using rule 56 (assign -> TIMES_EQ .)
    INT_NUMBER      reduce using rule 56 (assign -> TIMES_EQ .)
    STRING          reduce using rule 56 (assign -> TIMES_EQ .)
    ID              reduce using rule 56 (assign -> TIMES_EQ .)
    INCREMENT       reduce using rule 56 (assign -> TIMES_EQ .)
    DECREMENT       reduce using rule 56 (assign -> TIMES_EQ .)
    MINUS_EQ        reduce using rule 56 (assign -> TIMES_EQ .)
    PLUS            reduce using rule 56 (assign -> TIMES_EQ .)
    NOT             reduce using rule 56 (assign -> TIMES_EQ .)


state 96

    (57) assign -> DIVIDE_EQ .

    FLOAT_NUMBER    reduce using rule 57 (assign -> DIVIDE_EQ .)
    INT_NUMBER      reduce using rule 57 (assign -> DIVIDE_EQ .)
    STRING          reduce using rule 57 (assign -> DIVIDE_EQ .)
    ID              reduce using rule 57 (assign -> DIVIDE_EQ .)
    INCREMENT       reduce using rule 57 (assign -> DIVIDE_EQ .)
    DECREMENT       reduce using rule 57 (assign -> DIVIDE_EQ .)
    MINUS_EQ        reduce using rule 57 (assign -> DIVIDE_EQ .)
    PLUS            reduce using rule 57 (assign -> DIVIDE_EQ .)
    NOT             reduce using rule 57 (assign -> DIVIDE_EQ .)


state 97

    (58) assign -> MOD_EQ .

    FLOAT_NUMBER    reduce using rule 58 (assign -> MOD_EQ .)
    INT_NUMBER      reduce using rule 58 (assign -> MOD_EQ .)
    STRING          reduce using rule 58 (assign -> MOD_EQ .)
    ID              reduce using rule 58 (assign -> MOD_EQ .)
    INCREMENT       reduce using rule 58 (assign -> MOD_EQ .)
    DECREMENT       reduce using rule 58 (assign -> MOD_EQ .)
    MINUS_EQ        reduce using rule 58 (assign -> MOD_EQ .)
    PLUS            reduce using rule 58 (assign -> MOD_EQ .)
    NOT             reduce using rule 58 (assign -> MOD_EQ .)


state 98

    (59) assign -> BITWISE_AND_EQ .

    FLOAT_NUMBER    reduce using rule 59 (assign -> BITWISE_AND_EQ .)
    INT_NUMBER      reduce using rule 59 (assign -> BITWISE_AND_EQ .)
    STRING          reduce using rule 59 (assign -> BITWISE_AND_EQ .)
    ID              reduce using rule 59 (assign -> BITWISE_AND_EQ .)
    INCREMENT       reduce using rule 59 (assign -> BITWISE_AND_EQ .)
    DECREMENT       reduce using rule 59 (assign -> BITWISE_AND_EQ .)
    MINUS_EQ        reduce using rule 59 (assign -> BITWISE_AND_EQ .)
    PLUS            reduce using rule 59 (assign -> BITWISE_AND_EQ .)
    NOT             reduce using rule 59 (assign -> BITWISE_AND_EQ .)


state 99

    (60) assign -> BITWISE_OR_EQ .

    FLOAT_NUMBER    reduce using rule 60 (assign -> BITWISE_OR_EQ .)
    INT_NUMBER      reduce using rule 60 (assign -> BITWISE_OR_EQ .)
    STRING          reduce using rule 60 (assign -> BITWISE_OR_EQ .)
    ID              reduce using rule 60 (assign -> BITWISE_OR_EQ .)
    INCREMENT       reduce using rule 60 (assign -> BITWISE_OR_EQ .)
    DECREMENT       reduce using rule 60 (assign -> BITWISE_OR_EQ .)
    MINUS_EQ        reduce using rule 60 (assign -> BITWISE_OR_EQ .)
    PLUS            reduce using rule 60 (assign -> BITWISE_OR_EQ .)
    NOT             reduce using rule 60 (assign -> BITWISE_OR_EQ .)


state 100

    (61) assign -> BITWISE_XOR_EQ .

    FLOAT_NUMBER    reduce using rule 61 (assign -> BITWISE_XOR_EQ .)
    INT_NUMBER      reduce using rule 61 (assign -> BITWISE_XOR_EQ .)
    STRING          reduce using rule 61 (assign -> BITWISE_XOR_EQ .)
    ID              reduce using rule 61 (assign -> BITWISE_XOR_EQ .)
    INCREMENT       reduce using rule 61 (assign -> BITWISE_XOR_EQ .)
    DECREMENT       reduce using rule 61 (assign -> BITWISE_XOR_EQ .)
    MINUS_EQ        reduce using rule 61 (assign -> BITWISE_XOR_EQ .)
    PLUS            reduce using rule 61 (assign -> BITWISE_XOR_EQ .)
    NOT             reduce using rule 61 (assign -> BITWISE_XOR_EQ .)


state 101

    (62) assign -> URSHIFT_EQ .

    FLOAT_NUMBER    reduce using rule 62 (assign -> URSHIFT_EQ .)
    INT_NUMBER      reduce using rule 62 (assign -> URSHIFT_EQ .)
    STRING          reduce using rule 62 (assign -> URSHIFT_EQ .)
    ID              reduce using rule 62 (assign -> URSHIFT_EQ .)
    INCREMENT       reduce using rule 62 (assign -> URSHIFT_EQ .)
    DECREMENT       reduce using rule 62 (assign -> URSHIFT_EQ .)
    MINUS_EQ        reduce using rule 62 (assign -> URSHIFT_EQ .)
    PLUS            reduce using rule 62 (assign -> URSHIFT_EQ .)
    NOT             reduce using rule 62 (assign -> URSHIFT_EQ .)


state 102

    (63) assign -> LSHIFT_EQ .

    FLOAT_NUMBER    reduce using rule 63 (assign -> LSHIFT_EQ .)
    INT_NUMBER      reduce using rule 63 (assign -> LSHIFT_EQ .)
    STRING          reduce using rule 63 (assign -> LSHIFT_EQ .)
    ID              reduce using rule 63 (assign -> LSHIFT_EQ .)
    INCREMENT       reduce using rule 63 (assign -> LSHIFT_EQ .)
    DECREMENT       reduce using rule 63 (assign -> LSHIFT_EQ .)
    MINUS_EQ        reduce using rule 63 (assign -> LSHIFT_EQ .)
    PLUS            reduce using rule 63 (assign -> LSHIFT_EQ .)
    NOT             reduce using rule 63 (assign -> LSHIFT_EQ .)


state 103

    (64) assign -> RSHIFT_EQ .

    FLOAT_NUMBER    reduce using rule 64 (assign -> RSHIFT_EQ .)
    INT_NUMBER      reduce using rule 64 (assign -> RSHIFT_EQ .)
    STRING          reduce using rule 64 (assign -> RSHIFT_EQ .)
    ID              reduce using rule 64 (assign -> RSHIFT_EQ .)
    INCREMENT       reduce using rule 64 (assign -> RSHIFT_EQ .)
    DECREMENT       reduce using rule 64 (assign -> RSHIFT_EQ .)
    MINUS_EQ        reduce using rule 64 (assign -> RSHIFT_EQ .)
    PLUS            reduce using rule 64 (assign -> RSHIFT_EQ .)
    NOT             reduce using rule 64 (assign -> RSHIFT_EQ .)


state 104

    (81) unaryoperatorsufx -> INCREMENT .

    SEMICOLON       reduce using rule 81 (unaryoperatorsufx -> INCREMENT .)
    TIMES           reduce using rule 81 (unaryoperatorsufx -> INCREMENT .)
    DIVIDE          reduce using rule 81 (unaryoperatorsufx -> INCREMENT .)
    MODULE          reduce using rule 81 (unaryoperatorsufx -> INCREMENT .)
    PLUS            reduce using rule 81 (unaryoperatorsufx -> INCREMENT .)
    MINUS           reduce using rule 81 (unaryoperatorsufx -> INCREMENT .)
    LEQ             reduce using rule 81 (unaryoperatorsufx -> INCREMENT .)
    GEQ             reduce using rule 81 (unaryoperatorsufx -> INCREMENT .)
    LT              reduce using rule 81 (unaryoperatorsufx -> INCREMENT .)
    GT              reduce using rule 81 (unaryoperatorsufx -> INCREMENT .)
    NEQ             reduce using rule 81 (unaryoperatorsufx -> INCREMENT .)
    EQ              reduce using rule 81 (unaryoperatorsufx -> INCREMENT .)
    AND             reduce using rule 81 (unaryoperatorsufx -> INCREMENT .)
    OR              reduce using rule 81 (unaryoperatorsufx -> INCREMENT .)
    BITWISE_AND     reduce using rule 81 (unaryoperatorsufx -> INCREMENT .)
    BITWISE_OR      reduce using rule 81 (unaryoperatorsufx -> INCREMENT .)
    BITWISE_XOR     reduce using rule 81 (unaryoperatorsufx -> INCREMENT .)
    URSHIFT         reduce using rule 81 (unaryoperatorsufx -> INCREMENT .)
    LSHIFT          reduce using rule 81 (unaryoperatorsufx -> INCREMENT .)
    RSHIFT          reduce using rule 81 (unaryoperatorsufx -> INCREMENT .)
    RPAREN          reduce using rule 81 (unaryoperatorsufx -> INCREMENT .)
    COMMA           reduce using rule 81 (unaryoperatorsufx -> INCREMENT .)


state 105

    (82) unaryoperatorsufx -> DECREMENT .

    SEMICOLON       reduce using rule 82 (unaryoperatorsufx -> DECREMENT .)
    TIMES           reduce using rule 82 (unaryoperatorsufx -> DECREMENT .)
    DIVIDE          reduce using rule 82 (unaryoperatorsufx -> DECREMENT .)
    MODULE          reduce using rule 82 (unaryoperatorsufx -> DECREMENT .)
    PLUS            reduce using rule 82 (unaryoperatorsufx -> DECREMENT .)
    MINUS           reduce using rule 82 (unaryoperatorsufx -> DECREMENT .)
    LEQ             reduce using rule 82 (unaryoperatorsufx -> DECREMENT .)
    GEQ             reduce using rule 82 (unaryoperatorsufx -> DECREMENT .)
    LT              reduce using rule 82 (unaryoperatorsufx -> DECREMENT .)
    GT              reduce using rule 82 (unaryoperatorsufx -> DECREMENT .)
    NEQ             reduce using rule 82 (unaryoperatorsufx -> DECREMENT .)
    EQ              reduce using rule 82 (unaryoperatorsufx -> DECREMENT .)
    AND             reduce using rule 82 (unaryoperatorsufx -> DECREMENT .)
    OR              reduce using rule 82 (unaryoperatorsufx -> DECREMENT .)
    BITWISE_AND     reduce using rule 82 (unaryoperatorsufx -> DECREMENT .)
    BITWISE_OR      reduce using rule 82 (unaryoperatorsufx -> DECREMENT .)
    BITWISE_XOR     reduce using rule 82 (unaryoperatorsufx -> DECREMENT .)
    URSHIFT         reduce using rule 82 (unaryoperatorsufx -> DECREMENT .)
    LSHIFT          reduce using rule 82 (unaryoperatorsufx -> DECREMENT .)
    RSHIFT          reduce using rule 82 (unaryoperatorsufx -> DECREMENT .)
    RPAREN          reduce using rule 82 (unaryoperatorsufx -> DECREMENT .)
    COMMA           reduce using rule 82 (unaryoperatorsufx -> DECREMENT .)


state 106

    (45) operator -> unaryoperatorprefx ID .

    SEMICOLON       reduce using rule 45 (operator -> unaryoperatorprefx ID .)
    TIMES           reduce using rule 45 (operator -> unaryoperatorprefx ID .)
    DIVIDE          reduce using rule 45 (operator -> unaryoperatorprefx ID .)
    MODULE          reduce using rule 45 (operator -> unaryoperatorprefx ID .)
    PLUS            reduce using rule 45 (operator -> unaryoperatorprefx ID .)
    MINUS           reduce using rule 45 (operator -> unaryoperatorprefx ID .)
    LEQ             reduce using rule 45 (operator -> unaryoperatorprefx ID .)
    GEQ             reduce using rule 45 (operator -> unaryoperatorprefx ID .)
    LT              reduce using rule 45 (operator -> unaryoperatorprefx ID .)
    GT              reduce using rule 45 (operator -> unaryoperatorprefx ID .)
    NEQ             reduce using rule 45 (operator -> unaryoperatorprefx ID .)
    EQ              reduce using rule 45 (operator -> unaryoperatorprefx ID .)
    AND             reduce using rule 45 (operator -> unaryoperatorprefx ID .)
    OR              reduce using rule 45 (operator -> unaryoperatorprefx ID .)
    BITWISE_AND     reduce using rule 45 (operator -> unaryoperatorprefx ID .)
    BITWISE_OR      reduce using rule 45 (operator -> unaryoperatorprefx ID .)
    BITWISE_XOR     reduce using rule 45 (operator -> unaryoperatorprefx ID .)
    URSHIFT         reduce using rule 45 (operator -> unaryoperatorprefx ID .)
    LSHIFT          reduce using rule 45 (operator -> unaryoperatorprefx ID .)
    RSHIFT          reduce using rule 45 (operator -> unaryoperatorprefx ID .)
    RPAREN          reduce using rule 45 (operator -> unaryoperatorprefx ID .)
    COMMA           reduce using rule 45 (operator -> unaryoperatorprefx ID .)


state 107

    (22) sigparams -> ID .
    (23) sigparams -> ID . COMMA sigparams

    RPAREN          reduce using rule 22 (sigparams -> ID .)
    COMMA           shift and go to state 119


state 108

    (21) signature -> visibility ID ID LPAREN sigparams . RPAREN

    RPAREN          shift and go to state 120


state 109

    (42) operator -> expression arithmetic expression .
    (42) operator -> expression . arithmetic expression
    (44) operator -> expression . operatorcomparator expression
    (47) operator -> expression . operatorbittobit
    (48) arithmetic -> . TIMES
    (49) arithmetic -> . DIVIDE
    (50) arithmetic -> . MODULE
    (51) arithmetic -> . PLUS
    (52) arithmetic -> . MINUS
    (65) operatorcomparator -> . LEQ
    (66) operatorcomparator -> . GEQ
    (67) operatorcomparator -> . LT
    (68) operatorcomparator -> . GT
    (69) operatorcomparator -> . NEQ
    (70) operatorcomparator -> . EQ
    (71) operatorcomparator -> . AND
    (72) operatorcomparator -> . OR
    (73) operatorcomparator -> . BITWISE_AND
    (74) operatorcomparator -> . BITWISE_OR
    (75) operatorcomparator -> . BITWISE_XOR
    (83) operatorbittobit -> . URSHIFT
    (84) operatorbittobit -> . LSHIFT
    (85) operatorbittobit -> . RSHIFT

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for BITWISE_AND resolved as shift
  ! shift/reduce conflict for BITWISE_OR resolved as shift
  ! shift/reduce conflict for BITWISE_XOR resolved as shift
  ! shift/reduce conflict for URSHIFT resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
    SEMICOLON       reduce using rule 42 (operator -> expression arithmetic expression .)
    RPAREN          reduce using rule 42 (operator -> expression arithmetic expression .)
    COMMA           reduce using rule 42 (operator -> expression arithmetic expression .)
    TIMES           shift and go to state 65
    DIVIDE          shift and go to state 66
    MODULE          shift and go to state 67
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    LEQ             shift and go to state 70
    GEQ             shift and go to state 71
    LT              shift and go to state 72
    GT              shift and go to state 73
    NEQ             shift and go to state 74
    EQ              shift and go to state 75
    AND             shift and go to state 76
    OR              shift and go to state 77
    BITWISE_AND     shift and go to state 78
    BITWISE_OR      shift and go to state 79
    BITWISE_XOR     shift and go to state 80
    URSHIFT         shift and go to state 81
    LSHIFT          shift and go to state 82
    RSHIFT          shift and go to state 83

  ! TIMES           [ reduce using rule 42 (operator -> expression arithmetic expression .) ]
  ! DIVIDE          [ reduce using rule 42 (operator -> expression arithmetic expression .) ]
  ! MODULE          [ reduce using rule 42 (operator -> expression arithmetic expression .) ]
  ! PLUS            [ reduce using rule 42 (operator -> expression arithmetic expression .) ]
  ! MINUS           [ reduce using rule 42 (operator -> expression arithmetic expression .) ]
  ! LEQ             [ reduce using rule 42 (operator -> expression arithmetic expression .) ]
  ! GEQ             [ reduce using rule 42 (operator -> expression arithmetic expression .) ]
  ! LT              [ reduce using rule 42 (operator -> expression arithmetic expression .) ]
  ! GT              [ reduce using rule 42 (operator -> expression arithmetic expression .) ]
  ! NEQ             [ reduce using rule 42 (operator -> expression arithmetic expression .) ]
  ! EQ              [ reduce using rule 42 (operator -> expression arithmetic expression .) ]
  ! AND             [ reduce using rule 42 (operator -> expression arithmetic expression .) ]
  ! OR              [ reduce using rule 42 (operator -> expression arithmetic expression .) ]
  ! BITWISE_AND     [ reduce using rule 42 (operator -> expression arithmetic expression .) ]
  ! BITWISE_OR      [ reduce using rule 42 (operator -> expression arithmetic expression .) ]
  ! BITWISE_XOR     [ reduce using rule 42 (operator -> expression arithmetic expression .) ]
  ! URSHIFT         [ reduce using rule 42 (operator -> expression arithmetic expression .) ]
  ! LSHIFT          [ reduce using rule 42 (operator -> expression arithmetic expression .) ]
  ! RSHIFT          [ reduce using rule 42 (operator -> expression arithmetic expression .) ]

    arithmetic                     shift and go to state 62
    operatorcomparator             shift and go to state 63
    operatorbittobit               shift and go to state 64

state 110

    (44) operator -> expression operatorcomparator expression .
    (42) operator -> expression . arithmetic expression
    (44) operator -> expression . operatorcomparator expression
    (47) operator -> expression . operatorbittobit
    (48) arithmetic -> . TIMES
    (49) arithmetic -> . DIVIDE
    (50) arithmetic -> . MODULE
    (51) arithmetic -> . PLUS
    (52) arithmetic -> . MINUS
    (65) operatorcomparator -> . LEQ
    (66) operatorcomparator -> . GEQ
    (67) operatorcomparator -> . LT
    (68) operatorcomparator -> . GT
    (69) operatorcomparator -> . NEQ
    (70) operatorcomparator -> . EQ
    (71) operatorcomparator -> . AND
    (72) operatorcomparator -> . OR
    (73) operatorcomparator -> . BITWISE_AND
    (74) operatorcomparator -> . BITWISE_OR
    (75) operatorcomparator -> . BITWISE_XOR
    (83) operatorbittobit -> . URSHIFT
    (84) operatorbittobit -> . LSHIFT
    (85) operatorbittobit -> . RSHIFT

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for BITWISE_AND resolved as shift
  ! shift/reduce conflict for BITWISE_OR resolved as shift
  ! shift/reduce conflict for BITWISE_XOR resolved as shift
  ! shift/reduce conflict for URSHIFT resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
    SEMICOLON       reduce using rule 44 (operator -> expression operatorcomparator expression .)
    RPAREN          reduce using rule 44 (operator -> expression operatorcomparator expression .)
    COMMA           reduce using rule 44 (operator -> expression operatorcomparator expression .)
    TIMES           shift and go to state 65
    DIVIDE          shift and go to state 66
    MODULE          shift and go to state 67
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    LEQ             shift and go to state 70
    GEQ             shift and go to state 71
    LT              shift and go to state 72
    GT              shift and go to state 73
    NEQ             shift and go to state 74
    EQ              shift and go to state 75
    AND             shift and go to state 76
    OR              shift and go to state 77
    BITWISE_AND     shift and go to state 78
    BITWISE_OR      shift and go to state 79
    BITWISE_XOR     shift and go to state 80
    URSHIFT         shift and go to state 81
    LSHIFT          shift and go to state 82
    RSHIFT          shift and go to state 83

  ! TIMES           [ reduce using rule 44 (operator -> expression operatorcomparator expression .) ]
  ! DIVIDE          [ reduce using rule 44 (operator -> expression operatorcomparator expression .) ]
  ! MODULE          [ reduce using rule 44 (operator -> expression operatorcomparator expression .) ]
  ! PLUS            [ reduce using rule 44 (operator -> expression operatorcomparator expression .) ]
  ! MINUS           [ reduce using rule 44 (operator -> expression operatorcomparator expression .) ]
  ! LEQ             [ reduce using rule 44 (operator -> expression operatorcomparator expression .) ]
  ! GEQ             [ reduce using rule 44 (operator -> expression operatorcomparator expression .) ]
  ! LT              [ reduce using rule 44 (operator -> expression operatorcomparator expression .) ]
  ! GT              [ reduce using rule 44 (operator -> expression operatorcomparator expression .) ]
  ! NEQ             [ reduce using rule 44 (operator -> expression operatorcomparator expression .) ]
  ! EQ              [ reduce using rule 44 (operator -> expression operatorcomparator expression .) ]
  ! AND             [ reduce using rule 44 (operator -> expression operatorcomparator expression .) ]
  ! OR              [ reduce using rule 44 (operator -> expression operatorcomparator expression .) ]
  ! BITWISE_AND     [ reduce using rule 44 (operator -> expression operatorcomparator expression .) ]
  ! BITWISE_OR      [ reduce using rule 44 (operator -> expression operatorcomparator expression .) ]
  ! BITWISE_XOR     [ reduce using rule 44 (operator -> expression operatorcomparator expression .) ]
  ! URSHIFT         [ reduce using rule 44 (operator -> expression operatorcomparator expression .) ]
  ! LSHIFT          [ reduce using rule 44 (operator -> expression operatorcomparator expression .) ]
  ! RSHIFT          [ reduce using rule 44 (operator -> expression operatorcomparator expression .) ]

    operatorcomparator             shift and go to state 63
    arithmetic                     shift and go to state 62
    operatorbittobit               shift and go to state 64

state 111

    (28) stm -> WHILE LPAREN expression . RPAREN bodyorstm
    (42) operator -> expression . arithmetic expression
    (44) operator -> expression . operatorcomparator expression
    (47) operator -> expression . operatorbittobit
    (48) arithmetic -> . TIMES
    (49) arithmetic -> . DIVIDE
    (50) arithmetic -> . MODULE
    (51) arithmetic -> . PLUS
    (52) arithmetic -> . MINUS
    (65) operatorcomparator -> . LEQ
    (66) operatorcomparator -> . GEQ
    (67) operatorcomparator -> . LT
    (68) operatorcomparator -> . GT
    (69) operatorcomparator -> . NEQ
    (70) operatorcomparator -> . EQ
    (71) operatorcomparator -> . AND
    (72) operatorcomparator -> . OR
    (73) operatorcomparator -> . BITWISE_AND
    (74) operatorcomparator -> . BITWISE_OR
    (75) operatorcomparator -> . BITWISE_XOR
    (83) operatorbittobit -> . URSHIFT
    (84) operatorbittobit -> . LSHIFT
    (85) operatorbittobit -> . RSHIFT

    RPAREN          shift and go to state 121
    TIMES           shift and go to state 65
    DIVIDE          shift and go to state 66
    MODULE          shift and go to state 67
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    LEQ             shift and go to state 70
    GEQ             shift and go to state 71
    LT              shift and go to state 72
    GT              shift and go to state 73
    NEQ             shift and go to state 74
    EQ              shift and go to state 75
    AND             shift and go to state 76
    OR              shift and go to state 77
    BITWISE_AND     shift and go to state 78
    BITWISE_OR      shift and go to state 79
    BITWISE_XOR     shift and go to state 80
    URSHIFT         shift and go to state 81
    LSHIFT          shift and go to state 82
    RSHIFT          shift and go to state 83

    arithmetic                     shift and go to state 62
    operatorcomparator             shift and go to state 63
    operatorbittobit               shift and go to state 64

state 112

    (29) stm -> DO bodyorstm WHILE . LPAREN expression RPAREN SEMICOLON

    LPAREN          shift and go to state 122


state 113

    (30) stm -> FOR LPAREN expression . SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm
    (42) operator -> expression . arithmetic expression
    (44) operator -> expression . operatorcomparator expression
    (47) operator -> expression . operatorbittobit
    (48) arithmetic -> . TIMES
    (49) arithmetic -> . DIVIDE
    (50) arithmetic -> . MODULE
    (51) arithmetic -> . PLUS
    (52) arithmetic -> . MINUS
    (65) operatorcomparator -> . LEQ
    (66) operatorcomparator -> . GEQ
    (67) operatorcomparator -> . LT
    (68) operatorcomparator -> . GT
    (69) operatorcomparator -> . NEQ
    (70) operatorcomparator -> . EQ
    (71) operatorcomparator -> . AND
    (72) operatorcomparator -> . OR
    (73) operatorcomparator -> . BITWISE_AND
    (74) operatorcomparator -> . BITWISE_OR
    (75) operatorcomparator -> . BITWISE_XOR
    (83) operatorbittobit -> . URSHIFT
    (84) operatorbittobit -> . LSHIFT
    (85) operatorbittobit -> . RSHIFT

    SEMICOLON       shift and go to state 123
    TIMES           shift and go to state 65
    DIVIDE          shift and go to state 66
    MODULE          shift and go to state 67
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    LEQ             shift and go to state 70
    GEQ             shift and go to state 71
    LT              shift and go to state 72
    GT              shift and go to state 73
    NEQ             shift and go to state 74
    EQ              shift and go to state 75
    AND             shift and go to state 76
    OR              shift and go to state 77
    BITWISE_AND     shift and go to state 78
    BITWISE_OR      shift and go to state 79
    BITWISE_XOR     shift and go to state 80
    URSHIFT         shift and go to state 81
    LSHIFT          shift and go to state 82
    RSHIFT          shift and go to state 83

    arithmetic                     shift and go to state 62
    operatorcomparator             shift and go to state 63
    operatorbittobit               shift and go to state 64

state 114

    (31) stm -> IF LPAREN expression . RPAREN bodyorstm
    (32) stm -> IF LPAREN expression . RPAREN bodyorstm ELSE bodyorstm
    (33) stm -> IF LPAREN expression . RPAREN bodyorstm ELSE IF bodyorstm
    (42) operator -> expression . arithmetic expression
    (44) operator -> expression . operatorcomparator expression
    (47) operator -> expression . operatorbittobit
    (48) arithmetic -> . TIMES
    (49) arithmetic -> . DIVIDE
    (50) arithmetic -> . MODULE
    (51) arithmetic -> . PLUS
    (52) arithmetic -> . MINUS
    (65) operatorcomparator -> . LEQ
    (66) operatorcomparator -> . GEQ
    (67) operatorcomparator -> . LT
    (68) operatorcomparator -> . GT
    (69) operatorcomparator -> . NEQ
    (70) operatorcomparator -> . EQ
    (71) operatorcomparator -> . AND
    (72) operatorcomparator -> . OR
    (73) operatorcomparator -> . BITWISE_AND
    (74) operatorcomparator -> . BITWISE_OR
    (75) operatorcomparator -> . BITWISE_XOR
    (83) operatorbittobit -> . URSHIFT
    (84) operatorbittobit -> . LSHIFT
    (85) operatorbittobit -> . RSHIFT

    RPAREN          shift and go to state 124
    TIMES           shift and go to state 65
    DIVIDE          shift and go to state 66
    MODULE          shift and go to state 67
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    LEQ             shift and go to state 70
    GEQ             shift and go to state 71
    LT              shift and go to state 72
    GT              shift and go to state 73
    NEQ             shift and go to state 74
    EQ              shift and go to state 75
    AND             shift and go to state 76
    OR              shift and go to state 77
    BITWISE_AND     shift and go to state 78
    BITWISE_OR      shift and go to state 79
    BITWISE_XOR     shift and go to state 80
    URSHIFT         shift and go to state 81
    LSHIFT          shift and go to state 82
    RSHIFT          shift and go to state 83

    arithmetic                     shift and go to state 62
    operatorcomparator             shift and go to state 63
    operatorbittobit               shift and go to state 64

state 115

    (43) operator -> ID assign expression .
    (42) operator -> expression . arithmetic expression
    (44) operator -> expression . operatorcomparator expression
    (47) operator -> expression . operatorbittobit
    (48) arithmetic -> . TIMES
    (49) arithmetic -> . DIVIDE
    (50) arithmetic -> . MODULE
    (51) arithmetic -> . PLUS
    (52) arithmetic -> . MINUS
    (65) operatorcomparator -> . LEQ
    (66) operatorcomparator -> . GEQ
    (67) operatorcomparator -> . LT
    (68) operatorcomparator -> . GT
    (69) operatorcomparator -> . NEQ
    (70) operatorcomparator -> . EQ
    (71) operatorcomparator -> . AND
    (72) operatorcomparator -> . OR
    (73) operatorcomparator -> . BITWISE_AND
    (74) operatorcomparator -> . BITWISE_OR
    (75) operatorcomparator -> . BITWISE_XOR
    (83) operatorbittobit -> . URSHIFT
    (84) operatorbittobit -> . LSHIFT
    (85) operatorbittobit -> . RSHIFT

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for BITWISE_AND resolved as shift
  ! shift/reduce conflict for BITWISE_OR resolved as shift
  ! shift/reduce conflict for BITWISE_XOR resolved as shift
  ! shift/reduce conflict for URSHIFT resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
    SEMICOLON       reduce using rule 43 (operator -> ID assign expression .)
    RPAREN          reduce using rule 43 (operator -> ID assign expression .)
    COMMA           reduce using rule 43 (operator -> ID assign expression .)
    TIMES           shift and go to state 65
    DIVIDE          shift and go to state 66
    MODULE          shift and go to state 67
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    LEQ             shift and go to state 70
    GEQ             shift and go to state 71
    LT              shift and go to state 72
    GT              shift and go to state 73
    NEQ             shift and go to state 74
    EQ              shift and go to state 75
    AND             shift and go to state 76
    OR              shift and go to state 77
    BITWISE_AND     shift and go to state 78
    BITWISE_OR      shift and go to state 79
    BITWISE_XOR     shift and go to state 80
    URSHIFT         shift and go to state 81
    LSHIFT          shift and go to state 82
    RSHIFT          shift and go to state 83

  ! TIMES           [ reduce using rule 43 (operator -> ID assign expression .) ]
  ! DIVIDE          [ reduce using rule 43 (operator -> ID assign expression .) ]
  ! MODULE          [ reduce using rule 43 (operator -> ID assign expression .) ]
  ! PLUS            [ reduce using rule 43 (operator -> ID assign expression .) ]
  ! MINUS           [ reduce using rule 43 (operator -> ID assign expression .) ]
  ! LEQ             [ reduce using rule 43 (operator -> ID assign expression .) ]
  ! GEQ             [ reduce using rule 43 (operator -> ID assign expression .) ]
  ! LT              [ reduce using rule 43 (operator -> ID assign expression .) ]
  ! GT              [ reduce using rule 43 (operator -> ID assign expression .) ]
  ! NEQ             [ reduce using rule 43 (operator -> ID assign expression .) ]
  ! EQ              [ reduce using rule 43 (operator -> ID assign expression .) ]
  ! AND             [ reduce using rule 43 (operator -> ID assign expression .) ]
  ! OR              [ reduce using rule 43 (operator -> ID assign expression .) ]
  ! BITWISE_AND     [ reduce using rule 43 (operator -> ID assign expression .) ]
  ! BITWISE_OR      [ reduce using rule 43 (operator -> ID assign expression .) ]
  ! BITWISE_XOR     [ reduce using rule 43 (operator -> ID assign expression .) ]
  ! URSHIFT         [ reduce using rule 43 (operator -> ID assign expression .) ]
  ! LSHIFT          [ reduce using rule 43 (operator -> ID assign expression .) ]
  ! RSHIFT          [ reduce using rule 43 (operator -> ID assign expression .) ]

    arithmetic                     shift and go to state 62
    operatorcomparator             shift and go to state 63
    operatorbittobit               shift and go to state 64

state 116

    (86) call -> ID LPAREN params . RPAREN

    RPAREN          shift and go to state 125


state 117

    (87) call -> ID LPAREN RPAREN .

    SEMICOLON       reduce using rule 87 (call -> ID LPAREN RPAREN .)
    TIMES           reduce using rule 87 (call -> ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 87 (call -> ID LPAREN RPAREN .)
    MODULE          reduce using rule 87 (call -> ID LPAREN RPAREN .)
    PLUS            reduce using rule 87 (call -> ID LPAREN RPAREN .)
    MINUS           reduce using rule 87 (call -> ID LPAREN RPAREN .)
    LEQ             reduce using rule 87 (call -> ID LPAREN RPAREN .)
    GEQ             reduce using rule 87 (call -> ID LPAREN RPAREN .)
    LT              reduce using rule 87 (call -> ID LPAREN RPAREN .)
    GT              reduce using rule 87 (call -> ID LPAREN RPAREN .)
    NEQ             reduce using rule 87 (call -> ID LPAREN RPAREN .)
    EQ              reduce using rule 87 (call -> ID LPAREN RPAREN .)
    AND             reduce using rule 87 (call -> ID LPAREN RPAREN .)
    OR              reduce using rule 87 (call -> ID LPAREN RPAREN .)
    BITWISE_AND     reduce using rule 87 (call -> ID LPAREN RPAREN .)
    BITWISE_OR      reduce using rule 87 (call -> ID LPAREN RPAREN .)
    BITWISE_XOR     reduce using rule 87 (call -> ID LPAREN RPAREN .)
    URSHIFT         reduce using rule 87 (call -> ID LPAREN RPAREN .)
    LSHIFT          reduce using rule 87 (call -> ID LPAREN RPAREN .)
    RSHIFT          reduce using rule 87 (call -> ID LPAREN RPAREN .)
    RPAREN          reduce using rule 87 (call -> ID LPAREN RPAREN .)
    COMMA           reduce using rule 87 (call -> ID LPAREN RPAREN .)


state 118

    (88) params -> expression . COMMA params
    (89) params -> expression .
    (42) operator -> expression . arithmetic expression
    (44) operator -> expression . operatorcomparator expression
    (47) operator -> expression . operatorbittobit
    (48) arithmetic -> . TIMES
    (49) arithmetic -> . DIVIDE
    (50) arithmetic -> . MODULE
    (51) arithmetic -> . PLUS
    (52) arithmetic -> . MINUS
    (65) operatorcomparator -> . LEQ
    (66) operatorcomparator -> . GEQ
    (67) operatorcomparator -> . LT
    (68) operatorcomparator -> . GT
    (69) operatorcomparator -> . NEQ
    (70) operatorcomparator -> . EQ
    (71) operatorcomparator -> . AND
    (72) operatorcomparator -> . OR
    (73) operatorcomparator -> . BITWISE_AND
    (74) operatorcomparator -> . BITWISE_OR
    (75) operatorcomparator -> . BITWISE_XOR
    (83) operatorbittobit -> . URSHIFT
    (84) operatorbittobit -> . LSHIFT
    (85) operatorbittobit -> . RSHIFT

    COMMA           shift and go to state 126
    RPAREN          reduce using rule 89 (params -> expression .)
    TIMES           shift and go to state 65
    DIVIDE          shift and go to state 66
    MODULE          shift and go to state 67
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    LEQ             shift and go to state 70
    GEQ             shift and go to state 71
    LT              shift and go to state 72
    GT              shift and go to state 73
    NEQ             shift and go to state 74
    EQ              shift and go to state 75
    AND             shift and go to state 76
    OR              shift and go to state 77
    BITWISE_AND     shift and go to state 78
    BITWISE_OR      shift and go to state 79
    BITWISE_XOR     shift and go to state 80
    URSHIFT         shift and go to state 81
    LSHIFT          shift and go to state 82
    RSHIFT          shift and go to state 83

    arithmetic                     shift and go to state 62
    operatorcomparator             shift and go to state 63
    operatorbittobit               shift and go to state 64

state 119

    (23) sigparams -> ID COMMA . sigparams
    (22) sigparams -> . ID
    (23) sigparams -> . ID COMMA sigparams

    ID              shift and go to state 107

    sigparams                      shift and go to state 127

state 120

    (21) signature -> visibility ID ID LPAREN sigparams RPAREN .

    LCHAV           reduce using rule 21 (signature -> visibility ID ID LPAREN sigparams RPAREN .)


state 121

    (28) stm -> WHILE LPAREN expression RPAREN . bodyorstm
    (35) bodyorstm -> . body
    (24) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 31

    bodyorstm                      shift and go to state 128
    body                           shift and go to state 86

state 122

    (29) stm -> DO bodyorstm WHILE LPAREN . expression RPAREN SEMICOLON
    (36) expression -> . operator
    (37) expression -> . call
    (38) expression -> . FLOAT_NUMBER
    (39) expression -> . INT_NUMBER
    (40) expression -> . STRING
    (41) expression -> . ID
    (42) operator -> . expression arithmetic expression
    (43) operator -> . ID assign expression
    (44) operator -> . expression operatorcomparator expression
    (45) operator -> . unaryoperatorprefx ID
    (46) operator -> . ID unaryoperatorsufx
    (47) operator -> . expression operatorbittobit
    (86) call -> . ID LPAREN params RPAREN
    (87) call -> . ID LPAREN RPAREN
    (76) unaryoperatorprefx -> . INCREMENT
    (77) unaryoperatorprefx -> . DECREMENT
    (78) unaryoperatorprefx -> . MINUS_EQ
    (79) unaryoperatorprefx -> . PLUS
    (80) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 46
    INT_NUMBER      shift and go to state 47
    STRING          shift and go to state 48
    ID              shift and go to state 49
    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52
    MINUS_EQ        shift and go to state 53
    PLUS            shift and go to state 54
    NOT             shift and go to state 55

    expression                     shift and go to state 129
    operator                       shift and go to state 44
    call                           shift and go to state 45
    unaryoperatorprefx             shift and go to state 50

state 123

    (30) stm -> FOR LPAREN expression SEMICOLON . expression SEMICOLON expression SEMICOLON RPAREN bodyorstm
    (36) expression -> . operator
    (37) expression -> . call
    (38) expression -> . FLOAT_NUMBER
    (39) expression -> . INT_NUMBER
    (40) expression -> . STRING
    (41) expression -> . ID
    (42) operator -> . expression arithmetic expression
    (43) operator -> . ID assign expression
    (44) operator -> . expression operatorcomparator expression
    (45) operator -> . unaryoperatorprefx ID
    (46) operator -> . ID unaryoperatorsufx
    (47) operator -> . expression operatorbittobit
    (86) call -> . ID LPAREN params RPAREN
    (87) call -> . ID LPAREN RPAREN
    (76) unaryoperatorprefx -> . INCREMENT
    (77) unaryoperatorprefx -> . DECREMENT
    (78) unaryoperatorprefx -> . MINUS_EQ
    (79) unaryoperatorprefx -> . PLUS
    (80) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 46
    INT_NUMBER      shift and go to state 47
    STRING          shift and go to state 48
    ID              shift and go to state 49
    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52
    MINUS_EQ        shift and go to state 53
    PLUS            shift and go to state 54
    NOT             shift and go to state 55

    expression                     shift and go to state 130
    operator                       shift and go to state 44
    call                           shift and go to state 45
    unaryoperatorprefx             shift and go to state 50

state 124

    (31) stm -> IF LPAREN expression RPAREN . bodyorstm
    (32) stm -> IF LPAREN expression RPAREN . bodyorstm ELSE bodyorstm
    (33) stm -> IF LPAREN expression RPAREN . bodyorstm ELSE IF bodyorstm
    (35) bodyorstm -> . body
    (24) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 31

    bodyorstm                      shift and go to state 131
    body                           shift and go to state 86

state 125

    (86) call -> ID LPAREN params RPAREN .

    SEMICOLON       reduce using rule 86 (call -> ID LPAREN params RPAREN .)
    TIMES           reduce using rule 86 (call -> ID LPAREN params RPAREN .)
    DIVIDE          reduce using rule 86 (call -> ID LPAREN params RPAREN .)
    MODULE          reduce using rule 86 (call -> ID LPAREN params RPAREN .)
    PLUS            reduce using rule 86 (call -> ID LPAREN params RPAREN .)
    MINUS           reduce using rule 86 (call -> ID LPAREN params RPAREN .)
    LEQ             reduce using rule 86 (call -> ID LPAREN params RPAREN .)
    GEQ             reduce using rule 86 (call -> ID LPAREN params RPAREN .)
    LT              reduce using rule 86 (call -> ID LPAREN params RPAREN .)
    GT              reduce using rule 86 (call -> ID LPAREN params RPAREN .)
    NEQ             reduce using rule 86 (call -> ID LPAREN params RPAREN .)
    EQ              reduce using rule 86 (call -> ID LPAREN params RPAREN .)
    AND             reduce using rule 86 (call -> ID LPAREN params RPAREN .)
    OR              reduce using rule 86 (call -> ID LPAREN params RPAREN .)
    BITWISE_AND     reduce using rule 86 (call -> ID LPAREN params RPAREN .)
    BITWISE_OR      reduce using rule 86 (call -> ID LPAREN params RPAREN .)
    BITWISE_XOR     reduce using rule 86 (call -> ID LPAREN params RPAREN .)
    URSHIFT         reduce using rule 86 (call -> ID LPAREN params RPAREN .)
    LSHIFT          reduce using rule 86 (call -> ID LPAREN params RPAREN .)
    RSHIFT          reduce using rule 86 (call -> ID LPAREN params RPAREN .)
    RPAREN          reduce using rule 86 (call -> ID LPAREN params RPAREN .)
    COMMA           reduce using rule 86 (call -> ID LPAREN params RPAREN .)


state 126

    (88) params -> expression COMMA . params
    (88) params -> . expression COMMA params
    (89) params -> . expression
    (36) expression -> . operator
    (37) expression -> . call
    (38) expression -> . FLOAT_NUMBER
    (39) expression -> . INT_NUMBER
    (40) expression -> . STRING
    (41) expression -> . ID
    (42) operator -> . expression arithmetic expression
    (43) operator -> . ID assign expression
    (44) operator -> . expression operatorcomparator expression
    (45) operator -> . unaryoperatorprefx ID
    (46) operator -> . ID unaryoperatorsufx
    (47) operator -> . expression operatorbittobit
    (86) call -> . ID LPAREN params RPAREN
    (87) call -> . ID LPAREN RPAREN
    (76) unaryoperatorprefx -> . INCREMENT
    (77) unaryoperatorprefx -> . DECREMENT
    (78) unaryoperatorprefx -> . MINUS_EQ
    (79) unaryoperatorprefx -> . PLUS
    (80) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 46
    INT_NUMBER      shift and go to state 47
    STRING          shift and go to state 48
    ID              shift and go to state 49
    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52
    MINUS_EQ        shift and go to state 53
    PLUS            shift and go to state 54
    NOT             shift and go to state 55

    expression                     shift and go to state 118
    params                         shift and go to state 132
    operator                       shift and go to state 44
    call                           shift and go to state 45
    unaryoperatorprefx             shift and go to state 50

state 127

    (23) sigparams -> ID COMMA sigparams .

    RPAREN          reduce using rule 23 (sigparams -> ID COMMA sigparams .)


state 128

    (28) stm -> WHILE LPAREN expression RPAREN bodyorstm .

    WHILE           reduce using rule 28 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    DO              reduce using rule 28 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    FOR             reduce using rule 28 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    IF              reduce using rule 28 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    SEMICOLON       reduce using rule 28 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    FLOAT_NUMBER    reduce using rule 28 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    INT_NUMBER      reduce using rule 28 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    STRING          reduce using rule 28 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    ID              reduce using rule 28 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    INCREMENT       reduce using rule 28 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    DECREMENT       reduce using rule 28 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    MINUS_EQ        reduce using rule 28 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    PLUS            reduce using rule 28 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    NOT             reduce using rule 28 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)
    RCHAV           reduce using rule 28 (stm -> WHILE LPAREN expression RPAREN bodyorstm .)


state 129

    (29) stm -> DO bodyorstm WHILE LPAREN expression . RPAREN SEMICOLON
    (42) operator -> expression . arithmetic expression
    (44) operator -> expression . operatorcomparator expression
    (47) operator -> expression . operatorbittobit
    (48) arithmetic -> . TIMES
    (49) arithmetic -> . DIVIDE
    (50) arithmetic -> . MODULE
    (51) arithmetic -> . PLUS
    (52) arithmetic -> . MINUS
    (65) operatorcomparator -> . LEQ
    (66) operatorcomparator -> . GEQ
    (67) operatorcomparator -> . LT
    (68) operatorcomparator -> . GT
    (69) operatorcomparator -> . NEQ
    (70) operatorcomparator -> . EQ
    (71) operatorcomparator -> . AND
    (72) operatorcomparator -> . OR
    (73) operatorcomparator -> . BITWISE_AND
    (74) operatorcomparator -> . BITWISE_OR
    (75) operatorcomparator -> . BITWISE_XOR
    (83) operatorbittobit -> . URSHIFT
    (84) operatorbittobit -> . LSHIFT
    (85) operatorbittobit -> . RSHIFT

    RPAREN          shift and go to state 133
    TIMES           shift and go to state 65
    DIVIDE          shift and go to state 66
    MODULE          shift and go to state 67
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    LEQ             shift and go to state 70
    GEQ             shift and go to state 71
    LT              shift and go to state 72
    GT              shift and go to state 73
    NEQ             shift and go to state 74
    EQ              shift and go to state 75
    AND             shift and go to state 76
    OR              shift and go to state 77
    BITWISE_AND     shift and go to state 78
    BITWISE_OR      shift and go to state 79
    BITWISE_XOR     shift and go to state 80
    URSHIFT         shift and go to state 81
    LSHIFT          shift and go to state 82
    RSHIFT          shift and go to state 83

    arithmetic                     shift and go to state 62
    operatorcomparator             shift and go to state 63
    operatorbittobit               shift and go to state 64

state 130

    (30) stm -> FOR LPAREN expression SEMICOLON expression . SEMICOLON expression SEMICOLON RPAREN bodyorstm
    (42) operator -> expression . arithmetic expression
    (44) operator -> expression . operatorcomparator expression
    (47) operator -> expression . operatorbittobit
    (48) arithmetic -> . TIMES
    (49) arithmetic -> . DIVIDE
    (50) arithmetic -> . MODULE
    (51) arithmetic -> . PLUS
    (52) arithmetic -> . MINUS
    (65) operatorcomparator -> . LEQ
    (66) operatorcomparator -> . GEQ
    (67) operatorcomparator -> . LT
    (68) operatorcomparator -> . GT
    (69) operatorcomparator -> . NEQ
    (70) operatorcomparator -> . EQ
    (71) operatorcomparator -> . AND
    (72) operatorcomparator -> . OR
    (73) operatorcomparator -> . BITWISE_AND
    (74) operatorcomparator -> . BITWISE_OR
    (75) operatorcomparator -> . BITWISE_XOR
    (83) operatorbittobit -> . URSHIFT
    (84) operatorbittobit -> . LSHIFT
    (85) operatorbittobit -> . RSHIFT

    SEMICOLON       shift and go to state 134
    TIMES           shift and go to state 65
    DIVIDE          shift and go to state 66
    MODULE          shift and go to state 67
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    LEQ             shift and go to state 70
    GEQ             shift and go to state 71
    LT              shift and go to state 72
    GT              shift and go to state 73
    NEQ             shift and go to state 74
    EQ              shift and go to state 75
    AND             shift and go to state 76
    OR              shift and go to state 77
    BITWISE_AND     shift and go to state 78
    BITWISE_OR      shift and go to state 79
    BITWISE_XOR     shift and go to state 80
    URSHIFT         shift and go to state 81
    LSHIFT          shift and go to state 82
    RSHIFT          shift and go to state 83

    arithmetic                     shift and go to state 62
    operatorcomparator             shift and go to state 63
    operatorbittobit               shift and go to state 64

state 131

    (31) stm -> IF LPAREN expression RPAREN bodyorstm .
    (32) stm -> IF LPAREN expression RPAREN bodyorstm . ELSE bodyorstm
    (33) stm -> IF LPAREN expression RPAREN bodyorstm . ELSE IF bodyorstm

    WHILE           reduce using rule 31 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    DO              reduce using rule 31 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    FOR             reduce using rule 31 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    IF              reduce using rule 31 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    SEMICOLON       reduce using rule 31 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    FLOAT_NUMBER    reduce using rule 31 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    INT_NUMBER      reduce using rule 31 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    STRING          reduce using rule 31 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    ID              reduce using rule 31 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    INCREMENT       reduce using rule 31 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    DECREMENT       reduce using rule 31 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    MINUS_EQ        reduce using rule 31 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    PLUS            reduce using rule 31 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    NOT             reduce using rule 31 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    RCHAV           reduce using rule 31 (stm -> IF LPAREN expression RPAREN bodyorstm .)
    ELSE            shift and go to state 135


state 132

    (88) params -> expression COMMA params .

    RPAREN          reduce using rule 88 (params -> expression COMMA params .)


state 133

    (29) stm -> DO bodyorstm WHILE LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 136


state 134

    (30) stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON . expression SEMICOLON RPAREN bodyorstm
    (36) expression -> . operator
    (37) expression -> . call
    (38) expression -> . FLOAT_NUMBER
    (39) expression -> . INT_NUMBER
    (40) expression -> . STRING
    (41) expression -> . ID
    (42) operator -> . expression arithmetic expression
    (43) operator -> . ID assign expression
    (44) operator -> . expression operatorcomparator expression
    (45) operator -> . unaryoperatorprefx ID
    (46) operator -> . ID unaryoperatorsufx
    (47) operator -> . expression operatorbittobit
    (86) call -> . ID LPAREN params RPAREN
    (87) call -> . ID LPAREN RPAREN
    (76) unaryoperatorprefx -> . INCREMENT
    (77) unaryoperatorprefx -> . DECREMENT
    (78) unaryoperatorprefx -> . MINUS_EQ
    (79) unaryoperatorprefx -> . PLUS
    (80) unaryoperatorprefx -> . NOT

    FLOAT_NUMBER    shift and go to state 46
    INT_NUMBER      shift and go to state 47
    STRING          shift and go to state 48
    ID              shift and go to state 49
    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52
    MINUS_EQ        shift and go to state 53
    PLUS            shift and go to state 54
    NOT             shift and go to state 55

    expression                     shift and go to state 137
    operator                       shift and go to state 44
    call                           shift and go to state 45
    unaryoperatorprefx             shift and go to state 50

state 135

    (32) stm -> IF LPAREN expression RPAREN bodyorstm ELSE . bodyorstm
    (33) stm -> IF LPAREN expression RPAREN bodyorstm ELSE . IF bodyorstm
    (35) bodyorstm -> . body
    (24) body -> . LCHAV stms RCHAV

    IF              shift and go to state 138
    LCHAV           shift and go to state 31

    bodyorstm                      shift and go to state 139
    body                           shift and go to state 86

state 136

    (29) stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .

    WHILE           reduce using rule 29 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    DO              reduce using rule 29 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    FOR             reduce using rule 29 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    IF              reduce using rule 29 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 29 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 29 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    INT_NUMBER      reduce using rule 29 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    STRING          reduce using rule 29 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    ID              reduce using rule 29 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 29 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    DECREMENT       reduce using rule 29 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    MINUS_EQ        reduce using rule 29 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    PLUS            reduce using rule 29 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    NOT             reduce using rule 29 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)
    RCHAV           reduce using rule 29 (stm -> DO bodyorstm WHILE LPAREN expression RPAREN SEMICOLON .)


state 137

    (30) stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression . SEMICOLON RPAREN bodyorstm
    (42) operator -> expression . arithmetic expression
    (44) operator -> expression . operatorcomparator expression
    (47) operator -> expression . operatorbittobit
    (48) arithmetic -> . TIMES
    (49) arithmetic -> . DIVIDE
    (50) arithmetic -> . MODULE
    (51) arithmetic -> . PLUS
    (52) arithmetic -> . MINUS
    (65) operatorcomparator -> . LEQ
    (66) operatorcomparator -> . GEQ
    (67) operatorcomparator -> . LT
    (68) operatorcomparator -> . GT
    (69) operatorcomparator -> . NEQ
    (70) operatorcomparator -> . EQ
    (71) operatorcomparator -> . AND
    (72) operatorcomparator -> . OR
    (73) operatorcomparator -> . BITWISE_AND
    (74) operatorcomparator -> . BITWISE_OR
    (75) operatorcomparator -> . BITWISE_XOR
    (83) operatorbittobit -> . URSHIFT
    (84) operatorbittobit -> . LSHIFT
    (85) operatorbittobit -> . RSHIFT

    SEMICOLON       shift and go to state 140
    TIMES           shift and go to state 65
    DIVIDE          shift and go to state 66
    MODULE          shift and go to state 67
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    LEQ             shift and go to state 70
    GEQ             shift and go to state 71
    LT              shift and go to state 72
    GT              shift and go to state 73
    NEQ             shift and go to state 74
    EQ              shift and go to state 75
    AND             shift and go to state 76
    OR              shift and go to state 77
    BITWISE_AND     shift and go to state 78
    BITWISE_OR      shift and go to state 79
    BITWISE_XOR     shift and go to state 80
    URSHIFT         shift and go to state 81
    LSHIFT          shift and go to state 82
    RSHIFT          shift and go to state 83

    arithmetic                     shift and go to state 62
    operatorcomparator             shift and go to state 63
    operatorbittobit               shift and go to state 64

state 138

    (33) stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF . bodyorstm
    (35) bodyorstm -> . body
    (24) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 31

    bodyorstm                      shift and go to state 141
    body                           shift and go to state 86

state 139

    (32) stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .

    WHILE           reduce using rule 32 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    DO              reduce using rule 32 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    FOR             reduce using rule 32 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    IF              reduce using rule 32 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    SEMICOLON       reduce using rule 32 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    FLOAT_NUMBER    reduce using rule 32 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    INT_NUMBER      reduce using rule 32 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    STRING          reduce using rule 32 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    ID              reduce using rule 32 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    INCREMENT       reduce using rule 32 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    DECREMENT       reduce using rule 32 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    MINUS_EQ        reduce using rule 32 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    PLUS            reduce using rule 32 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    NOT             reduce using rule 32 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)
    RCHAV           reduce using rule 32 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE bodyorstm .)


state 140

    (30) stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON . RPAREN bodyorstm

    RPAREN          shift and go to state 142


state 141

    (33) stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .

    WHILE           reduce using rule 33 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    DO              reduce using rule 33 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    FOR             reduce using rule 33 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    IF              reduce using rule 33 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    SEMICOLON       reduce using rule 33 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    FLOAT_NUMBER    reduce using rule 33 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    INT_NUMBER      reduce using rule 33 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    STRING          reduce using rule 33 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    ID              reduce using rule 33 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    INCREMENT       reduce using rule 33 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    DECREMENT       reduce using rule 33 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    MINUS_EQ        reduce using rule 33 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    PLUS            reduce using rule 33 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    NOT             reduce using rule 33 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)
    RCHAV           reduce using rule 33 (stm -> IF LPAREN expression RPAREN bodyorstm ELSE IF bodyorstm .)


state 142

    (30) stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN . bodyorstm
    (35) bodyorstm -> . body
    (24) body -> . LCHAV stms RCHAV

    LCHAV           shift and go to state 31

    bodyorstm                      shift and go to state 143
    body                           shift and go to state 86

state 143

    (30) stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .

    WHILE           reduce using rule 30 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)
    DO              reduce using rule 30 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)
    FOR             reduce using rule 30 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)
    IF              reduce using rule 30 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)
    SEMICOLON       reduce using rule 30 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)
    FLOAT_NUMBER    reduce using rule 30 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)
    INT_NUMBER      reduce using rule 30 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)
    STRING          reduce using rule 30 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)
    ID              reduce using rule 30 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)
    INCREMENT       reduce using rule 30 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)
    DECREMENT       reduce using rule 30 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)
    MINUS_EQ        reduce using rule 30 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)
    PLUS            reduce using rule 30 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)
    NOT             reduce using rule 30 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)
    RCHAV           reduce using rule 30 (stm -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression SEMICOLON RPAREN bodyorstm .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 16 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 109 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 109 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 109 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 109 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 109 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 109 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 109 resolved as shift
WARNING: shift/reduce conflict for LT in state 109 resolved as shift
WARNING: shift/reduce conflict for GT in state 109 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 109 resolved as shift
WARNING: shift/reduce conflict for EQ in state 109 resolved as shift
WARNING: shift/reduce conflict for AND in state 109 resolved as shift
WARNING: shift/reduce conflict for OR in state 109 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 109 resolved as shift
WARNING: shift/reduce conflict for BITWISE_OR in state 109 resolved as shift
WARNING: shift/reduce conflict for BITWISE_XOR in state 109 resolved as shift
WARNING: shift/reduce conflict for URSHIFT in state 109 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 109 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 109 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 110 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 110 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 110 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 110 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 110 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 110 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 110 resolved as shift
WARNING: shift/reduce conflict for LT in state 110 resolved as shift
WARNING: shift/reduce conflict for GT in state 110 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 110 resolved as shift
WARNING: shift/reduce conflict for EQ in state 110 resolved as shift
WARNING: shift/reduce conflict for AND in state 110 resolved as shift
WARNING: shift/reduce conflict for OR in state 110 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 110 resolved as shift
WARNING: shift/reduce conflict for BITWISE_OR in state 110 resolved as shift
WARNING: shift/reduce conflict for BITWISE_XOR in state 110 resolved as shift
WARNING: shift/reduce conflict for URSHIFT in state 110 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 110 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 110 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 115 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 115 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 115 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 115 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 115 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 115 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 115 resolved as shift
WARNING: shift/reduce conflict for LT in state 115 resolved as shift
WARNING: shift/reduce conflict for GT in state 115 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 115 resolved as shift
WARNING: shift/reduce conflict for EQ in state 115 resolved as shift
WARNING: shift/reduce conflict for AND in state 115 resolved as shift
WARNING: shift/reduce conflict for OR in state 115 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 115 resolved as shift
WARNING: shift/reduce conflict for BITWISE_OR in state 115 resolved as shift
WARNING: shift/reduce conflict for BITWISE_XOR in state 115 resolved as shift
WARNING: shift/reduce conflict for URSHIFT in state 115 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 115 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 115 resolved as shift
